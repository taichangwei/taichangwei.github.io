<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞</title>
  <icon>https://blog.taichangwei.com/icon.png</icon>
  <subtitle>信念之于人，犹翅膀之于鸟，信念是飞翔的翅膀</subtitle>
  <link href="https://blog.taichangwei.com/atom.xml" rel="self"/>
  
  <link href="https://blog.taichangwei.com/"/>
  <updated>2020-11-23T14:38:34.883Z</updated>
  <id>https://blog.taichangwei.com/</id>
  
  <author>
    <name>taichangwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM参数类型</title>
    <link href="https://blog.taichangwei.com/20200501/jvmParamType/218e2c7235be.html"/>
    <id>https://blog.taichangwei.com/20200501/jvmParamType/218e2c7235be.html</id>
    <published>2020-05-01T05:53:05.000Z</published>
    <updated>2020-11-23T14:38:34.883Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-参数分类&quot;&gt;&lt;a href=&quot;#1-参数分类&quot; class=&quot;headerlink&quot; title=&quot;1. 参数分类&quot;&gt;&lt;/a&gt;1. 参数分类&lt;/h1&gt;&lt;p&gt;jvm 参数可分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准参数：以 “&lt;code&gt;-&lt;/code&gt;“ 开头的参数&lt;/li&gt;
&lt;li&gt;非标准参数：以 “&lt;code&gt;-X&lt;/code&gt;“ 开头的参数&lt;/li&gt;
&lt;li&gt;不稳定参数：以”&lt;code&gt;-XX&lt;/code&gt;“ 开头的参数&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="jvm" scheme="https://blog.taichangwei.com/categories/jvm/"/>
    
    
    <category term="jvm参数" scheme="https://blog.taichangwei.com/tags/jvm%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux分区与挂载</title>
    <link href="https://blog.taichangwei.com/20200207/linux1/9694dab2a110.html"/>
    <id>https://blog.taichangwei.com/20200207/linux1/9694dab2a110.html</id>
    <published>2020-02-07T13:47:33.000Z</published>
    <updated>2020-11-24T14:15:18.337Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-Linux版本&quot;&gt;&lt;a href=&quot;#1-Linux版本&quot; class=&quot;headerlink&quot; title=&quot;1.Linux版本&quot;&gt;&lt;/a&gt;1.Linux版本&lt;/h2&gt;&lt;p&gt;Linux分为&lt;strong&gt;内核版&lt;/strong&gt;和&lt;strong&gt;发行版&lt;/strong&gt;，Linux内核其实就是一个操作系统最底层的核心及其提供的核心工具，仅有内核而没有应用软件的操作系统是无法使用的，为了让使用者能够接触到Linux，于是很多的商业公司或非营利团体，就将 Linux Kernel(含 tools)与可运行的软件整合起来，加上自己具有创意的工具程序，这个工具程序可以让用户以光盘/DVD 或者透过网络直接安装/管理 Linux 系统，这个『Kernel + Softwares + Tools + 可完全安装程序』的咚咚，我们称之为Linux发行版。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://blog.taichangwei.com/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.taichangwei.com/tags/linux/"/>
    
    <category term="分区" scheme="https://blog.taichangwei.com/tags/%E5%88%86%E5%8C%BA/"/>
    
    <category term="挂载" scheme="https://blog.taichangwei.com/tags/%E6%8C%82%E8%BD%BD/"/>
    
    <category term="目录结构" scheme="https://blog.taichangwei.com/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件之ActiveMQ入门</title>
    <link href="https://blog.taichangwei.com/20190816/post/191434a07b67.html"/>
    <id>https://blog.taichangwei.com/20190816/post/191434a07b67.html</id>
    <published>2019-08-16T14:51:16.000Z</published>
    <updated>2020-11-23T15:39:15.464Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-JMS与消息中间件&quot;&gt;&lt;a href=&quot;#1-JMS与消息中间件&quot; class=&quot;headerlink&quot; title=&quot;1. JMS与消息中间件&quot;&gt;&lt;/a&gt;1. JMS与消息中间件&lt;/h1&gt;&lt;h2 id=&quot;1-1-jms介绍&quot;&gt;&lt;a href=&quot;#1-1-jms介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 jms介绍&quot;&gt;&lt;/a&gt;1.1 jms介绍&lt;/h2&gt;&lt;p&gt;jms是java消息服务接口规范，主要包含四大元素：&lt;strong&gt;生产者&lt;/strong&gt;、&lt;strong&gt;消费者&lt;/strong&gt;、&lt;strong&gt;消息&lt;/strong&gt;、&lt;strong&gt;消息服务&lt;/strong&gt;。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;生产者：创建消息，并把消息发动到消息服务；  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者：从消息服务接收消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息服务：即MQ消息服务（broker），而生产者与消费者相对其均为客服端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息：整个消息服务的传输对象，消息包含消息头、消息属性、消息体；&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://blog.taichangwei.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="activeMQ" scheme="https://blog.taichangwei.com/tags/activeMQ/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式（二）——方法引用</title>
    <link href="https://blog.taichangwei.com/20190202/lambda2/076a298db052.html"/>
    <id>https://blog.taichangwei.com/20190202/lambda2/076a298db052.html</id>
    <published>2019-02-02T07:57:33.000Z</published>
    <updated>2020-11-23T14:38:34.885Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们在使用lambda去表示某个函数式接口的实例时，需要在lambda表达式的主体里去编写函数式接口抽象方法的实现，如果在现有的类中已经存在与抽象方法类似的方法了，我们希望直接引用现有的方法，而不用再去重新写实现了。方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。&lt;/p&gt;
&lt;p&gt;方法引用和lambda表达式拥有相同的特性，它们都需要代表一个&lt;strong&gt;目标类型&lt;/strong&gt;，并需要被转化为函数式接口的实例，不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法方。&lt;strong&gt;法引用要使用到操作符 “::”，左边是类名或者对象名，右边是方法名或者关键字&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先被引用方法的返回值类型要和函数式接口抽象方法的返回值类型一致，至于参数列表要根据每种引用方式而定。&lt;/p&gt;</summary>
    
    
    
    <category term="lambda" scheme="https://blog.taichangwei.com/categories/lambda/"/>
    
    
    <category term="java" scheme="https://blog.taichangwei.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式（一）——函数式接口</title>
    <link href="https://blog.taichangwei.com/20190201/lambda1/c673d3a38bb1.html"/>
    <id>https://blog.taichangwei.com/20190201/lambda1/c673d3a38bb1.html</id>
    <published>2019-02-01T07:57:33.000Z</published>
    <updated>2020-11-23T14:38:34.884Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是lambda&quot;&gt;&lt;a href=&quot;#1-什么是lambda&quot; class=&quot;headerlink&quot; title=&quot;1.什么是lambda?&quot;&gt;&lt;/a&gt;1.什么是lambda?&lt;/h2&gt;&lt;p&gt;如果我们想要起一个线程来打印一串字符串，我们之前的写法通常是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executorService = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executorService.execute(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executorService.shutdown();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用lambda表达式后，可以改写为这个样：&lt;/p&gt;</summary>
    
    
    
    <category term="lambda" scheme="https://blog.taichangwei.com/categories/lambda/"/>
    
    
    <category term="java" scheme="https://blog.taichangwei.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>反射基础运用</title>
    <link href="https://blog.taichangwei.com/20190101/reflect/b01167aa3bca.html"/>
    <id>https://blog.taichangwei.com/20190101/reflect/b01167aa3bca.html</id>
    <published>2019-01-01T02:12:37.000Z</published>
    <updated>2020-11-23T14:38:34.886Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是反射？&quot;&gt;&lt;a href=&quot;#1-什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是反射？&quot;&gt;&lt;/a&gt;1.什么是反射？&lt;/h2&gt;&lt;p&gt;反射是指在程序运行时期可以动态的加载类并访问、检测和修改对象的一种能力。 那为什么要使用反射呢？编程时一般会遇到这种情况，编译时期无法确定对象类型，只有在运行时期才能确定，比如Spring的配置中就大量使用了反射机制。通过反射能够获取到类的一切信息，访问到对象的一切属性和方法，包括private修饰的属性和方法。  &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://blog.taichangwei.com/categories/java/"/>
    
    
    <category term="java" scheme="https://blog.taichangwei.com/tags/java/"/>
    
    <category term="反射" scheme="https://blog.taichangwei.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
