<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="java,博客,技术分享" />
   
  <meta name="description" content="分享学习心得，记录技术成长之路" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="google-site-verification" content="6PdDXp1HiBYOLkCarskqmK02dk0ftfxa7N1J-Em2fes" />
  <meta name="baidu-site-verification" content="code-qU3aOUJvyN" />
  <title>
    消息中间件之ActiveMQ入门 |  飞
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="飞" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-消息中间件之ActiveMQ入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  消息中间件之ActiveMQ入门
</h1>
 

    </header>
     
    <div class="article-meta">
      
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">28 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-JMS与消息中间件"><a href="#1-JMS与消息中间件" class="headerlink" title="1. JMS与消息中间件"></a>1. JMS与消息中间件</h1><h2 id="1-1-jms介绍"><a href="#1-1-jms介绍" class="headerlink" title="1.1 jms介绍"></a>1.1 jms介绍</h2><p>jms是java消息服务接口规范，主要包含四大元素：<strong>生产者</strong>、<strong>消费者</strong>、<strong>消息</strong>、<strong>消息服务</strong>。  </p>
<ul>
<li><p>生产者：创建消息，并把消息发动到消息服务；  </p>
</li>
<li><p>消费者：从消息服务接收消息；</p>
</li>
<li><p>消息服务：即MQ消息服务（broker），而生产者与消费者相对其均为客服端；</p>
</li>
<li><p>消息：整个消息服务的传输对象，消息包含消息头、消息属性、消息体；</p>
<a id="more"></a>

</li>
</ul>
<blockquote>
<p><strong>常用消息头属性</strong>：JMSDestination(消息目的地，如果生产者指定了目的地，在发送时会改为生产者绑定的目的地)、JMSDeliveryMode(是持久还是非持久)、JMSExpiration(过期时间，默认永久)、JMSPriority(优先级，0-9，数值越大优先级越高，默认为4)、JMSMessageId(唯一的消息ID)；<br><strong>消息属性</strong>：可视为消息头属性的扩展，通过setXxxProperty(k,v)设置；<br><strong>消息体</strong>：封装消息的具体数据，发送与接收的消息体类型必须一致，消息体类型总共有5种，TextMessage、Mapmessage、BytesMessage、StreamMessage、ObjectMessage；</p>
</blockquote>
<h2 id="1-2-jms消息传递模式"><a href="#1-2-jms消息传递模式" class="headerlink" title="1.2 jms消息传递模式"></a>1.2 jms消息传递模式</h2><p>jms消息传递模式有如下两种，<br><strong>点对点消息传递模式（P2P）</strong>：消息发送到一个特殊队列(queue), 消费者从队列获取消息，一条消息只能被只能被一个消费者消费；<br>**发布/订阅消息传递模式(publish-subscribe)**：消息被发送到一个主题上(topic)，所有订阅了该主题的消费者，都能接收到消息。</p>
<h2 id="1-3-jms编码总体架构"><a href="#1-3-jms编码总体架构" class="headerlink" title="1.3 jms编码总体架构"></a>1.3 jms编码总体架构</h2><p>JMS应用程序由如下基本模块组成，</p>
<ol>
<li>连接工厂对象，创建消息客户端(生产者、消费者)与消息服务端的连接(connection)；</li>
<li>连接对象，创建回话对象(session);</li>
<li>会话对象，创建生产者对象(producer)、消费者对象(consumer)以及消息对象(message)；</li>
<li>目的地(queue/topic)，点对点模式下目的地是队列(queue)，发布/订阅模式下目的地是主题(topic)，生产者把消息发送到目的地，消费者从目的地接收消息</li>
</ol>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq1.png?x-oss-process=style/watermarking"></p>
<h2 id="1-4-消息中间件"><a href="#1-4-消息中间件" class="headerlink" title="1.4 消息中间件"></a>1.4 消息中间件</h2><p>  消息中间件是实现了jms规范的落地产品，目前市场上主流的消息中间件有 ActiveMQ、Kafka、RocketMQ、RabbitMQ等。企业开发中使用消息中间件的主要目的是<strong>解决耦合调用</strong>、**抵御洪峰流量(削峰)**等。 以下主要讲解ActiveMQ的使用。</p>
<h1 id="2-ActiveMQ安装并启动"><a href="#2-ActiveMQ安装并启动" class="headerlink" title="2. ActiveMQ安装并启动"></a>2. ActiveMQ安装并启动</h1><p>具体安装步骤这里不再详述，可参考官网[<a href="http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行">http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行</a> <code>./activemq start</code>命令，即可启动MQ服务，如果启动服务需要指定配置文件，命令为 <code>./activemq start xbean:file:../conf/myConfig.xml</code>，不指定默认为conf目录下的activemq.xml。停止MQ服务的命令为 <code>./activemq stop</code>。</p>
<p>在conf目录下找到<code>activemq.xml</code>配置文件打开，里面包含如下内容,</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里配置的是MQ服务的各种传输协议连接和默认端口。再往下会发现这行内容<code>&lt;import resource=&quot;jetty.xml&quot;/&gt;</code>，activemq.xml文件中导入了一个名为<code>jetty.xml</code>的配置文件，在conf目录下找到jetty.xml文件打开，里面配置了访问MQ服务web控制台的一些信息，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jettyPort&quot; class&#x3D;&quot;org.apache.activemq.web.WebConsolePort&quot; init-method&#x3D;&quot;start&quot;&gt;</span><br><span class="line">    &lt;!-- the default port number for the web console --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;0.0.0.0&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;8161&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>其中8161为web控制台端口，MQ服务启动后，浏览器中访问[<a target="_blank" rel="noopener" href="http://localhost:8161/admin][3]%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%83%BD%E4%B8%BAadmin%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C">http://localhost:8161/admin][3]，输入用户名和密码，默认都为admin，即可看到如下页面，</a></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq2.png?x-oss-process=style/watermarking"></p>
<h1 id="3-编码实战"><a href="#3-编码实战" class="headerlink" title="3. 编码实战"></a>3. 编码实战</h1><p>ActiveMQ服务启动成功后，可以编写生产者客户端往MQ服务发送消息，消费者客户端从MQ服务获取消息。项目建好之后需要先引入ActiveMQ相关依赖，以gradle为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile group: &#39;org.apache.activemq&#39;, name: &#39;activemq-all&#39;, version: &#39;5.15.9&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-点对点消息"><a href="#3-1-点对点消息" class="headerlink" title="3.1 点对点消息"></a>3.1 点对点消息</h2><h3 id="3-1-1-生产者"><a href="#3-1-1-生产者" class="headerlink" title="3.1.1 生产者"></a>3.1.1 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂。这里传入ActiveMQ消息服务连接地址，并使用默认用户名和密码。</span></span><br><span class="line">        <span class="comment">// 也可使用ActiveMQConnectionFactory()构造器或者ActiveMQConnectionFactory(String userName, String password, String brokerURL)构造器，连接接信息全部使用默认值或者全部指定</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        <span class="comment">//2、通过工厂对象创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">//3、通过连接对象创建会话。第一个参数是否开启事务，第二参数指定签收类型</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4、通过会话对象创建目的地（队列或者主题）。这里创建了一个名为 &quot;queue001&quot; 的队列</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        <span class="comment">//5、通过会话对象创建生产者，并指定目的地</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line">        <span class="comment">//6、连续创建3条消息，并有生产者发送到消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">            System.out.println(textMessage.getJMSDestination());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息&quot;</span> + textMessage.getText() + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main()方法后，进入web控制台可以看到待消费消息有3条，入队消息有3条，说明消息已经成功发送至MQ服务器。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq3.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-2-消费者"><a href="#3-1-2-消费者" class="headerlink" title="3.1.2 消费者"></a>3.1.2 消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line">        connection.start();</span><br><span class="line">        Message message = consumer.receive();</span><br><span class="line">        <span class="keyword">while</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String text = ((TextMessage) message).getText();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            message = consumer.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者客户端编码过程与生产者基本一致，只不过一个是生产者发送调用<code>send()</code>方法，一个是消费者接收调用<code>receive()</code>方法。其中需要注意的是<code>receive()</code>方法是一个阻塞方法，接收不到消息会一直阻塞等待，并且调用<code>receive()</code>之前必须调用<code>connection.start()</code>启动连接，否者接收不到消息。<br>执行main()方法后，进入web控制台可以看到待消费消息变为0条，出队消息变为3条，并且有一个消费者，说明消息被消费成功。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq4.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-3-消息监听器实现异步非阻塞消费消息"><a href="#3-1-3-消息监听器实现异步非阻塞消费消息" class="headerlink" title="3.1.3 消息监听器实现异步非阻塞消费消息"></a>3.1.3 消息监听器实现异步非阻塞消费消息</h3><p>上面我们了解到<code>MessageConsumer#receive()</code>方法是个阻塞方法，实际开发中不可能一直去阻塞等待，可以为消费者对象设置消息监听器来实现异步非阻塞消费消息，修改消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line"><span class="comment">//        connection.start();</span></span><br><span class="line"><span class="comment">//        Message message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        while (message != null) &#123;</span></span><br><span class="line"><span class="comment">//            String text = ((TextMessage) message).getText();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;接收queue消息：&quot; + text);</span></span><br><span class="line"><span class="comment">//            message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line">        consumer.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String text = ((TextMessage) message).getText();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep为了使程序不退出</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMessageListener()</code>方法需要传入一个<code>MessageListener</code>实例对象，并实现<code>onMessage()</code>，这里使用的是lambda表达式。</p>
<h2 id="3-2-发布-订阅消息"><a href="#3-2-发布-订阅消息" class="headerlink" title="3.2 发布/订阅消息"></a>3.2 发布/订阅消息</h2><p>发布订阅消息与上面点对点消息的生产者与消费者编码一致，唯一要改变的是把消息目的地由queue改为topic。</p>
<ul>
<li>生产者<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME); </span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure></li>
<li>消费者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic &#x3D; session.createTopic(TOPIC_NAME);</span><br><span class="line">MessageConsumer consumer &#x3D; session.createConsumer(topic);</span><br><span class="line">...省略... </span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>1.在点对点消息示例中，当同时启动多个消费者时(即同时执行多次main()方法)，生产者发布的每条消息只能被其中一个消费者消费一次；<br>2.在发布/订阅消息示例中，消费者不能消费订阅主题之前的消息，当同时启动多个消费者时，生产者发布的每条消息可以同时被多个消费者消费；</p>
</blockquote>
<h1 id="4-传输协议"><a href="#4-传输协议" class="headerlink" title="4. 传输协议"></a>4. 传输协议</h1><h2 id="4-1-ActiveMQ默认支持的传输协议"><a href="#4-1-ActiveMQ默认支持的传输协议" class="headerlink" title="4.1 ActiveMQ默认支持的传输协议"></a>4.1 ActiveMQ默认支持的传输协议</h2><p>ActiveMQ出厂默认支持的传输协议有<code>tcp</code>、<code>amqp</code>、<code>stomp</code>、<code>mqtt</code>、<code>ws</code>，在<code>activemq.xml</code>配置文件可以找到这几种协议的配置，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于java开发后四种协议不经常使用，这里主要说一次tcp协议。tcp协议的client监听端口默认是61616，在网络上传输数据，必须序列化数据，消息是通过一个write protocol来序列化为字节流。默认情况 ActiveMQ会把wire protocol叫做Open Wire，它的目的是促使网络上的效率和数据快速交互。<br>tcp传输的优点：</p>
<ol>
<li>传输可靠性高、稳定性强</li>
<li>高效性：字节流方式传递，效率高</li>
<li>有效性、可用性：应用广泛，支持任何平台<br>tcp连接的URL形式如：<strong>tcp://hostname:port?key=value</strong>。更多协议的可配置参数请参考 <a target="_blank" rel="noopener" href="http://activemq.apache.org/tcp-transport-reference">http://activemq.apache.org/tcp-transport-reference</a></li>
</ol>
<h2 id="4-2-使用NIO传输协议提供更好的性能"><a href="#4-2-使用NIO传输协议提供更好的性能" class="headerlink" title="4.2 使用NIO传输协议提供更好的性能"></a>4.2 使用NIO传输协议提供更好的性能</h2><p>使用tcp协议，每一个连接都会创建一个线程，当client连接较多时需要大量的系统开销，nio支持多个连接使用同一个线程，相比tcp需要更少的线程数。  </p>
<p>nio协议基于tcp协议之上进行了扩展和优化。要使ActiveMQ支持nio协议，只需要做少量的修改即可。打开<code>activemq.xml</code>配置文件，在<code>&lt;transportConnectors&gt;</code> 节点内添加，<code>&lt;transportConnector name=&quot;nio&quot; uri=&quot;nio://0.0.0.0:61617&quot;/&gt;</code>，同时客户端代码url连接形式要改为 <code>nio://hostname:port?key=value</code>，后面的可选参数与tcp协议一致。  </p>
<blockquote>
<p>tcp协议也好nio协议也好，都绑定了特定的端口，如何实现一个端口可以支持多种协议呢？ActiveMQ提供了一个auto协议，类似于一个适配器协议，在不改变端口的情况下可以切换协议。详细配置参考官方文档 <a target="_blank" rel="noopener" href="http://activemq.apache.org/auto">http://activemq.apache.org/auto</a>  </p>
</blockquote>
<p>其他协议配置参见官网文档 <a target="_blank" rel="noopener" href="http://activemq.apache.org/configuring-transports.html">http://activemq.apache.org/configuring-transports.html</a></p>
<h1 id="5-ActiveMQ消息高可用"><a href="#5-ActiveMQ消息高可用" class="headerlink" title="5 ActiveMQ消息高可用"></a>5 ActiveMQ消息高可用</h1><h2 id="5-1-消息持久化"><a href="#5-1-消息持久化" class="headerlink" title="5.1 消息持久化"></a>5.1 消息持久化</h2><h3 id="5-1-1-持久化编码"><a href="#5-1-1-持久化编码" class="headerlink" title="5.1.1 持久化编码"></a>5.1.1 持久化编码</h3><p>如果生产者把消息发送到了MQ消息服务，消费者还没有来得及消费，此时MQ服务停止或意外宕机，那么这些未被消费的消息改怎么处理呢？分为消息非持久化和消息持久化两种情况，<strong>消息非持久化</strong>这些未被处理的消息直接丢失，<strong>消息持久化</strong>会把这些未被消费的消息暂时存储起来，当MQ消息服务重新启动时恢复这些消息，消费者可以继续消费。</p>
<ul>
<li><strong>队列消息持久化</strong><br>基于上面的示例代码，只需要为生产者客户端代码添加一行通过MessageProducer对象设置就可以了。（队列消息默认开启持久化这一行实际上可以省略）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li>
<li><strong>主题消息持久化</strong><br>主题消息默认不持久化，支持主题消息持久化，只需要修改消费者客户端代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">connection.setClientID(<span class="string">&quot;client_0001&quot;</span>);</span><br><span class="line"> ...</span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">TopicSubscriber subscriber =  session.createDurableSubscriber(topic, <span class="string">&quot;remark...&quot;</span>);</span><br><span class="line">connection.start();</span><br><span class="line">subscriber.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先必须要通过<code>connection.setClientID(&quot;client_0001&quot;)</code>指定订阅者ID，因为如果不指定唯一ID,订阅者（非持久化订阅者）每次连接时都会随机创建一个ID，在消息持久化状态下，订阅者需要保证从离线到重新在线ClientID唯一不变，这样MQ消息服务才能确定主题消息是否被所有持久化订阅者消费了（如果MQ服务停止或宕机时，主题消息未被所有持久化订阅者消费的会被存储起来，已经被所有持久化订阅者消费的主题消息会直接丢弃）。  </p>
<p>然后通过<code>session.createDurableSubscriber(topic, &quot;remark...&quot;)</code>创建一个TopicSubscriber对象，告诉MQ服务其订阅的此主题消息要做持久化处理。</p>
<h3 id="5-1-2-持久化存储机制"><a href="#5-1-2-持久化存储机制" class="headerlink" title="5.1.2 持久化存储机制"></a>5.1.2 持久化存储机制</h3><p>ActiveMQ的消息持久化机制有JDBC、AMQ、KahaDB和LevelDB，无论使用哪种持久化方式，消息的存储逻辑都是一致的，就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等再试图将消息发送给接受者，成功则将消息从存储中删除，失败则继续尝试发送。MQ消息服务启动以后首先要检查指定的存储位置，如果有未发送成功的消息则需要把消息继续发送出去。下面分别介绍一下KahaDB与JDBC持久化机制。</p>
<ul>
<li><strong>KahaDB存储</strong><br>KahaDB是一个基于文件的持久性数据库，消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。KahaDB是目前默认的存储方式，可用于任何场景，提高了性能和恢复能力。在<code>activemq.xml</code>配置文件可查看其配置信息，更多的配置信息可参见官网 <a target="_blank" rel="noopener" href="http://activemq.apache.org/kahadb">http://activemq.apache.org/kahadb</a></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>directory</code>这里指明了kahadb数据存储路径，默认为ActiveMQ安装目录下<code>/data/kahadb</code>，其中主要包含4类文件和一个lock：</p>
<ol>
<li><strong>db-<number>.log</strong>：kahaDB存储消息到预定大小（默认32M）的数据记录文件中，文件命名为db-<number>.log，当数据文件已满时，一个新的文件会随之创建，number数值也会随之递增，当不再有引用到数据文件中的消息时，文件会被删除或者归档；</li>
<li><strong>db.data</strong>：改文件包含了持久化的BTree索引，它是消息的索引文件，使用BTree作为索引指向db-<nubmer>.log里面存储的消息；</li>
<li><strong>db.free</strong>：记录当前db.data文件里哪些页面是空闲的，文件具体内容是所有空闲页的ID;</li>
<li><strong>db.redo</strong>：用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引；</li>
<li><strong>lock</strong>：文件锁，表示当前获得kahaDB读写权限的broker；  </li>
</ol>
<ul>
<li><strong>JDBC存储</strong><br>如果采用JDBC机制存储，需要准备一个第三方数据库，这里以MySql数据库为例，更多信息参考<a target="_blank" rel="noopener" href="http://activemq.apache.org/jdbc-support">http://activemq.apache.org/jdbc-support</a></li>
</ul>
<p>1.首先将mysql数据库的驱动包<code>mysql-connector-java-5.1.41.jar</code>添加到<code>ActiveMQ安装目录/lib</code>目录下，用于连接mysql数据库；</p>
<p>2.打开<code>activemq.xml</code>配置文件，找到<code>&lt;beans&gt;</code>节点添加数据库连接池配置信息<code>dataSource</code> bean，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysql-ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>3.<code>activemq.xml</code>配置文件中找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt; </span><br><span class="line">    &lt;jdbcPersistenceAdapter dataSource&#x3D;&quot;#mysql-ds&quot; createTablesOnStartup&#x3D;&quot;true&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;persistenceAdapter&gt;</span><br></pre></td></tr></table></figure>
<p><code>mysql-ds</code>为上一步配置的beanId，<code>createTablesOnStartup</code>是否在启动的时候自动创建数据表，默认值是true，一般是第一次启动的时候设置为true之后再改为false。</p>
<p>上诉三步都配置完后，启动ActiveMQ服务会自动创建三张表，分别为<code>activemq_msgs</code>消息表，用于保存queue和topic消息， <code>activemq_acks</code>用于存储订阅关系，如果是持久化topic，订阅者和服务器的订阅关系在这个表保存，<code>activemq_lock</code>在集群环境中才有用，保证只有一个borker可以获取消息，用于记录哪个breker是当前的master broker。</p>
<p>JDBC每次消息过来都需要去写库和读库，ActiveMQ Journal使用高速缓存写入技术大大提高了性能，克服了JDBC Store的不足。当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息，比如生产者生产了1000条消息，这1000条消息会先保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的消息，那么这个时候只需要同步剩余的10%的消息到DB。</p>
<p>使用高效的Journal，需要修改持久化配置，打开<code>activemq.xml</code>配置文件，找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceFactory&gt;</span><br><span class="line">    &lt;journalPersistenceAdapterFactory journalLogFiles&#x3D;&quot;5&quot; dataDirectory&#x3D;&quot;activemq-data&quot; dataSource&#x3D;&quot;#mysql-ds&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;persistenceFactory&gt; </span><br></pre></td></tr></table></figure>

<h2 id="5-2-事务"><a href="#5-2-事务" class="headerlink" title="5.2 事务"></a>5.2 事务</h2><p>在上面的示例代码中，创建session时传了两个参数，<code>createSession(false, Session.AUTO_ACKNOWLEDGE)</code>，第一个参数表示<strong>是否开启事务</strong>，第二个参数表示<strong>签收方式</strong>。</p>
<p>当开启事务，即第一个参数为<code>true</code>时，对于生产者而言执行<code>send()</code>方法后，消息不会直接进入消息队列中（没有真正发送到MQ服务），只有执行<code>session.commit()</code>消息才会真正发送成功进入消息队列中；对于消费者而言，消费完消息后，只有执行了<code>session.commit()</code>消息才会从消息队列中出队，如果不执行<code>session.commit()</code>会导致消息被重复消费。</p>
<p>事务开启的意义在于，对于多条必须同批次传输的消息，如果有一条传输失败，可以将事务回滚，再次传输，保证数据的完整性。</p>
<h2 id="5-3-签收（ack）"><a href="#5-3-签收（ack）" class="headerlink" title="5.3 签收（ack）"></a>5.3 签收（ack）</h2><p>签收和事务起到的作用是一样的，事务的优先级高于签收，即如果开启了事务，签收方式不管是哪种都是不起作用的，一般事务倾向于生产者使用，签收倾向于消费者使用。</p>
<p>签收方式总共有4种，<code>AUTO_ACKNOWLEDGE</code>自动签收，<code>CLIENT_ACKNOWLEDGE</code>手动签收，<code>DUPS_OK_ACKNOWLEDGE</code>可重复的签收（不常用），<code>SESSION_TRANSACTED</code>一般表示开启了事务设置任何签收方式是无效的。</p>
<p>如果签收方式为<code>CLIENT_ACKNOWLEDGE</code>手动签收，必须执行<code>message.acknowledge()</code>，消息才能被真正的消费或者发送。</p>
<h1 id="6-高级特性"><a href="#6-高级特性" class="headerlink" title="6 高级特性"></a>6 高级特性</h1><h1 id="6-1-异步投递"><a href="#6-1-异步投递" class="headerlink" title="6.1 异步投递"></a>6.1 异步投递</h1><p>ActiveMQ支持以同步或异步模式向borker发送消息，所使用的模式对发送调用的延迟有很大的影响。由于延迟通常是生产者可以实现的吞吐量中的一个重要因素，因此使用异步发送可以显著提高系统的性能。</p>
<p>ActiveMQ默认以异步模式发送消息，以同步模式发送的情况是除非明确指定使用同步发送或者<strong>事务外部发送持久消息</strong>（即未使用事务的前提下发送持久化消息）。如果不使用事务，而是发送持久消息，那么每次发送都会同步并阻塞，直到broker向生产者发送确认消息已安全持久存储到磁盘为止，此确认机制提供了消息不会丢失的保证，但由于客户端被阻塞需要付出巨大的延迟代价。</p>
<p>异步投递可以最大化producer端的发送效率。通常在发送消息量比较密集的情况下使用异步发送，它可以很大的提升producer的吞吐量，不过这也带来了额外的问题，就是需要消耗很多的client端内存的同时也会导致broker端性能消耗增加，此外<strong>不能有效的确保消失的发送成功</strong>。在使用异步投递的情况下客户端需要容忍消息丢失的可能。</p>
<ul>
<li><p><strong>开启异步投递的三种方式</strong></p>
<ol>
<li><p>通过Connection URI后面添加参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://locahost:61616?jms.useAsyncSend=true&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ConnectionFactory对象属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Connection对象属性，在此级别配置将覆盖ConnectionFactory级别的设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>如何保证一部投递情况下消息不丢失</strong></p>
<p>异步发送消息丢失的情况场景是，UseAsyncSend为true，使用<code>producer.send(message)</code>持续发送消息，消息不会阻塞，生产者会认为所有的消息均会被发送到了MQ服务，如果MQ服务突然宕机，此时生产者端尚未同步到MQ服务的消息均会丢失。所以，正确的异步发送方法需要接收回调的。</p>
<p>同步发送和异步发送的区别就在于，同步发送<code>send()</code>不阻塞就代表消息发送成功，异步发送需要接收回调并由客户端再判断一次是否发送。异步投递编码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...省略...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//producer.send(textMessage);</span></span><br><span class="line">            <span class="comment">//异步投递并确认消息发送结果</span></span><br><span class="line">            textMessage.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line">            String msgId = textMessage.getJMSMessageID();</span><br><span class="line">            ((ActiveMQMessageProducer) producer).send(textMessage, <span class="keyword">new</span> AsyncCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span> </span>&#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">                    <span class="comment">// 对于失败消息后续可以进行重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="6-2-定时与延时投递"><a href="#6-2-定时与延时投递" class="headerlink" title="6.2 定时与延时投递"></a>6.2 定时与延时投递</h2><p>有时候我们需要消息在某个时间点发送或者延迟一段时间发送。</p>
<p>ActiveMQ开启定时与延迟投递，首先编辑<code>activemq.xml</code>配置文件，<code>&lt;broker&gt;</code>标签内添加属性<code>schedulerSupport</code>并且设置为<code>true</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> <span class="attr">brokerName</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;$&#123;activemq.data&#125;&quot;</span> <span class="attr">schedulerSupport</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码中生产者端消息对象<code>message</code>，需要设置时间调度相关属性，主要属性如下：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AMQ_SCHEDULED_DELAY</td>
<td>long</td>
<td>延迟投递时间</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_PERIOD</td>
<td>long</td>
<td>重复投递时间间隔</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_REPEAT</td>
<td>int</td>
<td>重复投递次数</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_CRON</td>
<td>String</td>
<td>cron表达式</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//消息延迟3秒，每隔4秒重复发送，重复5次</span></span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, <span class="number">3000L</span>);</span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, <span class="number">4000L</span>);</span><br><span class="line">            textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, <span class="number">5</span>); <span class="comment">//（加上第一次实际上总共6次）</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>更多介绍参考官网 <a target="_blank" rel="noopener" href="http://activemq.apache.org/delay-and-schedule-message-delivery">http://activemq.apache.org/delay-and-schedule-message-delivery</a></p>
<h2 id="6-3-消费者消息重试策略"><a href="#6-3-消费者消息重试策略" class="headerlink" title="6.3 消费者消息重试策略"></a>6.3 消费者消息重试策略</h2><p>当下列任何一种情况发生时，borker会将消息重新传送至消费端:</p>
<ul>
<li>使用事务会话并调用<code>rollback()</code>；</li>
<li>使用事务会话调用<code>commit()</code>之前关闭已处理的会话；</li>
<li>在手动签收<code>CLIENT_ACKNOWLEDGE</code>传递模式下调用<code>session.recover()</code>；</li>
<li>客户机连接超时(可能正在执行的代码比配置的超时时间更长)。</li>
</ul>
<p>默认重发时间间隔为1秒总共重发6次，超过6次即最大重发次数后，消费端会给broker返送一个<code>poison ack</code>表示这个消息有毒，告诉broker不要再发了，这个时候broker会把这个消息放到DLQ（死信队列），以便稍后对其进行分析并人工干预处理。</p>
<p>定义重发策略，编码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        ActiveMQConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        RedeliveryPolicy policy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        policy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        policy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        policy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        policy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        connectionFactory.setRedeliveryPolicy(policy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从ActiveMQ v5.7.0开始，可以在每个目的地的基础上配置RedeliveryPolicy,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">true</span>, Session.CLIENT_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        </span><br><span class="line">        RedeliveryPolicy queuePolicy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        queuePolicy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        queuePolicy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        queuePolicy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        queuePolicy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        RedeliveryPolicyMap redeliveryPolicyMap =((ActiveMQConnection)connection).getRedeliveryPolicyMap();</span><br><span class="line">        redeliveryPolicyMap.put((ActiveMQQueue)queue, queuePolicy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>常用重发策略配置如下：<br>|属性名称   |默认值   |描述   |<br>| ———— | ———— | ———— |<br>|collisionAvoidanceFactor|    0.15|设置防止冲突范围的正负百分比，只有启用useCollisionAvoidance参数时才生效。也就是在延迟时间上再加一个时间波动范围|<br>|initialRedeliveryDelay|    1000L|    初始重发延迟时间|<br>|maximumRedeliveries|    6|最大重发次数，达到最大重发次数后消息进入死信队列。为-1时不限制次数，为0时表示不进行重发|<br>|maximumRedeliveryDelay|    -1|    最大重发延迟时间，只有useExponentialBackOff为true时有效（v5.5）。假设首次重发间隔为10ms，倍数为2，那么第二次重发时间间隔为20ms，第三次时间间隔为40ms，当重发时间间隔的达到最大传送延迟时间，以后每次重发时间间隔都为最大传送延迟时间。为-1时不限制最大时间间隔<br>|redeliveryDelay|    1000L | 重发延迟时间，当initialRedeliveryDelay=0生效|<br>|useCollisionAvoidance|    false|启用防止冲突功能|<br>|useExponentialBackOff|    false|启用指数倍数递增的方式增加延迟时间|<br>|backOffMultiplier|    5|重发时间间隔递增倍数，只有值大于1和启用useExponentialBackOff参数时才生效|<br>更多重发介绍参考官网 <a target="_blank" rel="noopener" href="http://activemq.apache.org/redelivery-policy">http://activemq.apache.org/redelivery-policy</a></p>
<p>ActiveMQ中的默认死信队列名称为<code>ActiveMQ.DLQ</code>，所有无法交付的消息都将被发送到这个队列，这可能很难管理，因此，你也可以在<code>activemq.xml</code>配置文件为每个目的地配置单独的死信队列，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单独为每个queue目的地设置一个死信队列，前缀为DLQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Set the following policy on all queues using the &#x27;&gt;&#x27; wildcard --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Use the prefix &#x27;DLQ.&#x27; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">&quot;DLQ.&quot;</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>死信队列详细介绍参考官网 <a target="_blank" rel="noopener" href="http://activemq.apache.org/message-redelivery-and-dlq-handling">http://activemq.apache.org/message-redelivery-and-dlq-handling</a></p>
<h1 id="7-内嵌broker"><a href="#7-内嵌broker" class="headerlink" title="7 内嵌broker"></a>7 内嵌broker</h1><p>使用spring boot开发web应用的时候，spring boot提供了内嵌的tomcat或者jetty服务器，使用内嵌服务器运行项目时就不用再单独启动一个servlet服务器了，类似的ActiveMQ也提供了一个内嵌broker，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.broker.BrokerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbedBroker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">        brokerService.setUseJmx(<span class="keyword">true</span>);</span><br><span class="line">        brokerService.addConnector(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        brokerService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细介绍参考官网 <a target="_blank" rel="noopener" href="https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html">https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://blog.taichangwei.com/20190816/post/191434a07b67.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/activeMQ/" rel="tag">activeMQ</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/20200207/linux1/9694dab2a110.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux分区与挂载
          
        </div>
      </a>
    
    
      <a href="/20190202/lambda2/076a298db052.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">lambda表达式（二）——方法引用</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "E5OOqIsMNkJ1drMqHgC0Pb2R-gzGzoHsz",
    app_key: "j5iMiXclL4PzAvAKYj50aulE",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2020
        <i class="ri-heart-fill heart_icon"></i> taichangwei
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1279456387&amp;web_id=1279456387'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side1.png" alt="飞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/common/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/common/weichatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>