<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM参数类型</title>
    <url>/20200501/jvmParamType/218e2c7235be.html</url>
    <content><![CDATA[<h1 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. 参数分类</h1><p>jvm 参数可分为三类：</p>
<ul>
<li>标准参数：以 “<code>-</code>“ 开头的参数</li>
<li>非标准参数：以 “<code>-X</code>“ 开头的参数</li>
<li>不稳定参数：以”<code>-XX</code>“ 开头的参数</li>
</ul>
<a id="more"></a>

<h1 id="2-标准参数（-）"><a href="#2-标准参数（-）" class="headerlink" title="2. 标准参数（-）"></a>2. 标准参数（-）</h1><p><strong>标准参数</strong>是指在各个JVM版本中基本保持不变，相对比较稳定。</p>
<p>标准参数统一都是以 “<code>-</code>“ 开头，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dprofile&#x3D;dev HelloWorld tom jack</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：其中<code>HelloWorld</code>  是被运行的 HelloWorld.class。<code>HelloWorld</code> 之前就是设置的JVM标准参数（-classpath、-D），<code>HelloWorld</code> 之后的参数(tom、jack)是用来传给 <code>main(String[] args)</code> 方法的args数组变量的，两者位置不要放错</p>
</blockquote>
<p><strong>查看所有标准参数</strong>：</p>
<p>打开一个命令终端，执行 “<code>java -help</code>“，就可以展示所有的JVM标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -help</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;&#x3D;&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括&#x2F;排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp&#x3D;help 和 -agentlib:hprof&#x3D;help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;java&#x2F;javase&#x2F;documentation&#x2F;index.html。</span><br></pre></td></tr></table></figure>



<h1 id="2-非标准参数（-X）"><a href="#2-非标准参数（-X）" class="headerlink" title="2. 非标准参数（-X）"></a>2. 非标准参数（-X）</h1><p><strong>非标准参数</strong>表示不保证所有VM实现都支持这些参数，在将来的JVM版本中可能会发生改变</p>
<p>非标准参数统一以 “<code>-X</code>“ 开头，如 <code>-Xmx20M</code> 设置最大java堆大小，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有非标准参数</strong>：</p>
<p>打开一个命令终端，执行 “`java -X”，就可以展示所有的JVM非标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -X</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath&#x2F;a:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath&#x2F;p:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java&#x2F;VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>



<h1 id="3-不稳定参数-（-XX）"><a href="#3-不稳定参数-（-XX）" class="headerlink" title="3. 不稳定参数 （-XX）"></a>3. 不稳定参数 （-XX）</h1><p><strong>不稳定参数</strong>这是我们日常开发中接触到最多的参数类型，也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于JVM调优和debug</p>
<p><strong>不稳定参数</strong>统一以 “<code>-XX</code>“ 开头，书写格式分为两种：</p>
<ul>
<li>bool 类型：<ul>
<li><code>-XX:+&lt;option&gt;</code>：代表启用 true</li>
<li><code>-XX:-&lt;option&gt;</code>：代表禁用 false</li>
</ul>
</li>
<li>数值或字符串类型：<ul>
<li><code>-XX:&lt;option&gt;=&lt;number&gt;</code>。数字如果有单位一般是 兆字节的“ m”或“ M”，千字节的“ k”或“ K”以及千兆字节的“ g”或“ G”（例如32k与32768相同）</li>
<li><code>-XX:&lt;option&gt;=&lt;string&gt;</code>。字符串通常用于指定文件，路径或命令列表</li>
</ul>
</li>
</ul>
<p>如 打印GC日志 <code>-XX:+PrintGCDetails</code>、设置对象最大晋升老年代的年龄 <code>-XX:MaxTenuringThreshold=15</code>，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M -XX:+PrintGCDetails -XX:MaxTenuringThreshold&#x3D;15  HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有不稳定参数（-XX:+PrintFlagsFinal）</strong></p>
<p>执行命令终端，执行 “<code>-XX:+PrintFlagsFinal</code>“，展示所有不稳定参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          &#x3D; 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    &#x3D; 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        &#x3D; 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx AliasLevel                                &#x3D; 3                                   &#123;C2 product&#125;</span><br><span class="line">     bool AlignVector                               &#x3D; false                               &#123;C2 product&#125;</span><br><span class="line">     intx AllocateInstancePrefetchLines             &#x3D; 1                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchDistance                  &#x3D; 192                                 &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchInstr                     &#x3D; 3                                   &#123;product&#125;</span><br><span class="line">     ...省略...</span><br><span class="line">    ccstr TraceJVMTI                                &#x3D;                                     &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                            :&#x3D; true                                &#123;product&#125;</span><br><span class="line">     ......</span><br><span class="line">    uintx YoungGenerationSizeIncrement              &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             &#x3D; 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        &#x3D; 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             &#x3D; 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  &#x3D; 5                                   &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_161&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：参数类型</li>
<li>第二列：参数名称</li>
<li>第三列：”<code>=</code>“ 表示第四列是初始值，”<code>:=</code>“表示参数被用户或者JVM赋值了</li>
<li>第四列：参数值</li>
<li>第五列：参数类别</li>
</ul>
<p>**查看所有参数初始值(-XX:+PrintFlagsInitial)**：<br>相对于<code>-XX:+PrintFlagsFinal</code> 参数，<code>-XX:+PrintFlagsInitial</code>参数打印出的结果中第四列都是初始值</p>
<p><strong>打印已经被用户或者当前虚拟机设置过的参数(-XX:+PrintCommandLineFlags)</strong><br>相当于列举出 <code>-XX:+PrintFlagsFinal</code>的结果中所有第三列是”<code>:=</code>“的参数。一般运行程序时，最好都加上该参数，可以知道该程序运行都设置过哪些JVM参数</p>
<hr>
<p>更多参数使用说明参考官网：<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/20200228/linux2/20f52a23110c.html</url>
    <content><![CDATA[<h2 id="1-命令的基本格式"><a href="#1-命令的基本格式" class="headerlink" title="1 命令的基本格式"></a>1 命令的基本格式</h2><h3 id="1-1-命令的提示符"><a href="#1-1-命令的提示符" class="headerlink" title="1.1 命令的提示符"></a>1.1 命令的提示符</h3><p><strong>[root@localhost ~]#</strong></p>
<ul>
<li><code>[]</code>：这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>：显示的是当前的登录用户， 目前使用的是root用户登录。</li>
<li><code>@</code>：分隔符号，没有特殊含义。</li>
<li><code>localhost</code>：当前系统的简写主机名（完整主机名是 localhost.localdomain）。</li>
<li><code>~</code>：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>：命令提示符。超级用户是#，普通用户是$</li>
</ul>
<h3 id="1-2-命令的基本格式"><a href="#1-2-命令的基本格式" class="headerlink" title="1.2 命令的基本格式"></a>1.2 命令的基本格式</h3><p><strong>[root@localhost ~]# 命令 [选项] [参数]</strong></p>
<ul>
<li><code>选项</code>：是用于调整命令的功能的</li>
<li><code>参数</code>：是命令的操作对象</li>
</ul>
<h2 id="2-目录操作命令"><a href="#2-目录操作命令" class="headerlink" title="2 目录操作命令"></a>2 目录操作命令</h2><h3 id="2-1-ls命令"><a href="#2-1-ls命令" class="headerlink" title="2.1 ls命令"></a>2.1 ls命令</h3><p>ls 是最常见的目录操作命令，主要作用是显示目录下的内容</p>
<ul>
<li>命令名称：ls</li>
<li>英文原意：list</li>
<li>所在路径：/bin/ls</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示目录下的内容</li>
</ul>
<p>命令格式：<code>ls [选项] [目录名]</code></p>
<ul>
<li>选项<ul>
<li>-a: 显示所有文件</li>
<li>–color=when: 支持颜色输出，when的值默认是<em>always</em>(总显示颜色)，也可以是<em>never</em>(从不显示颜色)和<em>auto</em>(自动)</li>
<li>-d: 显示目录信息，而不是目录下的文件</li>
<li>-h: 人性化显示，按照我们习惯的单位显示文件大小</li>
<li>-i: 显示文件的节点号</li>
<li>-l: 长格式显示</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">#权限 引用计数 所有者 所属组 大小 文件修改时间 文件名</span><br><span class="line">-rw-------. 1 root root  1446 12月 19 16:15 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“-l” 选项用于显示文件的详细信息，那么“-l”选项显示的这 7 列分别是什么含义？<br>第一列：权限。<br>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录<br>有多少个一级子目录。<br>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户<br>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。<br>第五列：大小。默认单位是字节。<br>第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个<br>时间不是文件的创建时间。<br>第七列：文件名。</p>
</blockquote>
<h3 id="2-2-cd命令"><a href="#2-2-cd命令" class="headerlink" title="2.2 cd命令"></a>2.2 cd命令</h3><p>cd是切换所在目录的命令，基本信息如下：</p>
<ul>
<li>命令名称：cd</li>
<li>英文原意：change directory</li>
<li>所在路径：shell内置命令</li>
<li>执行权限：所有用户</li>
<li>功能描述：切换所在目录</li>
</ul>
<p>命令格式：<code>cd [-L|-P] [dir]</code></p>
<ul>
<li>选项：<ul>
<li><code>-L</code>:（默认值）如果要切换到的目标目录是一个符号连接，那么切换到符号连接的目录。 </li>
<li><code>-P</code>: 如果要切换到的目标目录是一个符号连接，那么切换到它指向的物理位置目录。</li>
</ul>
</li>
<li>参数:<ul>
<li>可以是绝对路径(以根目录为参照物)或相对路径(以当前目录为参照物)</li>
</ul>
</li>
</ul>
<blockquote>
<p>简化用法<br><code>cd ~</code>: 当前用户的加目录<br><code>cd -</code>：上一次所在目录<br><code>cd .</code>: 当前目录<br><code>cd ..</code>: 上级目录</p>
</blockquote>
<h3 id="2-3-pwd命令"><a href="#2-3-pwd命令" class="headerlink" title="2.3 pwd命令"></a>2.3 pwd命令</h3><p>pwd命令是查询所在目录的命令，基本信息如下：</p>
<ul>
<li>命令名称：pwd</li>
<li>英文原意：print name of current/working directory</li>
<li>所在路径：/bin/pwd</li>
<li>执行权限：所有用户</li>
<li>功能描述：查询当前所在目录</li>
</ul>
<h3 id="2-4-mkdir命令"><a href="#2-4-mkdir命令" class="headerlink" title="2.4 mkdir命令"></a>2.4 mkdir命令</h3><ul>
<li>命令名称：mkdir</li>
<li>英文原意：make directories</li>
<li>所在路径：/bin/mkdir</li>
<li>执行权限：所有用户</li>
<li>功能描述：创建空目录</li>
</ul>
<p>命令格式：mkdir [选项] 目录名</p>
<ul>
<li>选项：<ul>
<li><code>-p</code>: 递归建立所需目录</li>
<li><code>-m 权限</code>：建立目录的同时设置目录的权限</li>
</ul>
</li>
</ul>
<h3 id="2-5-rmdir命令"><a href="#2-5-rmdir命令" class="headerlink" title="2.5 rmdir命令"></a>2.5 rmdir命令</h3><p>rmdir命令删除空目录，基本信息如下：</p>
<ul>
<li>命令名称：rmdir</li>
<li>英文原意：remove empty directories</li>
<li>所在路径：/bin/rmdir</li>
<li>执行权限：所有用户</li>
<li>功能描述：删除空目录</li>
</ul>
<p>命令格式：<code>rmdir [选项] 目录名</code></p>
<ul>
<li>选项：<ul>
<li><code>-p</code>: 递归删除目录</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>rmdir</code>命令的作用十分有限，只能删除空目录，一旦目录中有内容就会报错。所以一般不论删除的是文件还是目录，都会使用<code>rm</code>命令</p>
</blockquote>
<h2 id="3-文件操作命令"><a href="#3-文件操作命令" class="headerlink" title="3 文件操作命令"></a>3 文件操作命令</h2><h3 id="3-1-touch命令"><a href="#3-1-touch命令" class="headerlink" title="3.1 touch命令"></a>3.1 touch命令</h3><p>touch命令创建空文件或修改文件时间，基本信息如下：</p>
<ul>
<li>命令名称：touch</li>
<li>英文原意：change file timestamps</li>
<li>所在路径：/bin/touch</li>
<li>执行权限：所有用户</li>
<li>功能描述：创建文件或改文件时间戳</li>
</ul>
<p>命令格式：<code>touch [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：或–time=atime或–time=access或–time=use 更改存取时间为当前时间(access time)</li>
<li><code>-m</code>：或–time=mtime或–time=modify 更该变动时间为当前时间(modify time)</li>
<li><code>-t 日期时间</code>: 使用指定的日期时间(格式：[[CC]YY]MMDDhhmm[.ss])，而非现在的时间</li>
<li><code>-r 参考文件或目录</code>: 把指定文件或目录的日期时间统统设成参考文件或目录的日期时间<h3 id="3-2-cat命令"><a href="#3-2-cat命令" class="headerlink" title="3.2 cat命令"></a>3.2 cat命令</h3>cat命令用来查看文件内容，进本信息如下：</li>
</ul>
</li>
<li>命令名称：cat</li>
<li>英文原意：concatenate files and print on the standard output</li>
<li>所在路径：/bin/cat</li>
<li>执行权限：所有用户</li>
<li>功能描述：合并文件并打印输出到标准输出</li>
</ul>
<p>命令格式：<code>cat [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-E</code>: 列出每行结尾的回车符$</li>
<li><code>-n</code>: 显示行号</li>
<li><code>-T</code>: 把Tab键用^I显示出来</li>
<li><code>-v</code>: 列出特殊字符</li>
<li><code>-A</code>: 相当于-vET选项的整合，用于列出所有隐藏符号</li>
</ul>
</li>
</ul>
<h3 id="3-3-more-命令"><a href="#3-3-more-命令" class="headerlink" title="3.3 more 命令"></a>3.3 more 命令</h3><p>more是分屏显示文件的命令，基本信息如下：</p>
<ul>
<li>命令名称：more</li>
<li>英文原意：file perusal filter for crt viewin</li>
<li>所在路径：/bin/more</li>
<li>执行权限：所有用户</li>
<li>功能描述：分屏显示文件内容</li>
</ul>
<p>命令格式：<code>more [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：显示“[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions]”；</li>
<li><code>-c</code>：不进行滚屏操作。每次刷新这个屏幕</li>
<li><code>-s</code>：将多个空行压缩成一行显示</li>
<li><code>-u</code>：禁止下划线</li>
<li><code>-数字</code>：指定每屏显示的行数</li>
<li><code>+数字</code>：从指定数字的行开始显示  </li>
</ul>
</li>
</ul>
<blockquote>
<p> more 命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用的交互命令如下：</p>
<ul>
<li>空格键：向下翻页</li>
<li>B键: 向上翻页</li>
<li>/字符串：搜索指定的字符串</li>
<li>q: 退出</li>
</ul>
</blockquote>
<h3 id="3-4-less-命令"><a href="#3-4-less-命令" class="headerlink" title="3.4 less 命令"></a>3.4 less 命令</h3><p>less命令和more命令类似，只是more命令是分屏显示，而less是分行显示命名，less命令允许用户向前(PageUp键)或向后(PageDown键)浏览文件，基本信息如下：</p>
<ul>
<li>命令名称：less</li>
<li>英文原意：opposite of more</li>
<li>所在路径：/usr/bin/more</li>
<li>执行权限：所有用户</li>
<li>功能描述：分行显示文件内容</li>
</ul>
<p>命令格式：<code>less [选项] 文件名</code></p>
<ul>
<li><code>-e</code>：文件内容显示完毕后，自动退出</li>
<li><code>-f</code>：强制显示文件</li>
<li><code>-g</code>：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度</li>
<li><code>-l</code>：搜索时忽略大小写的差异</li>
<li><code>-N</code>：每一行行首显示行号</li>
<li><code>-s</code>：将连续多个空行压缩成一行显示</li>
<li><code>-S</code>：在单行显示较长的内容，而不换行显示</li>
<li><code>-x数字</code>：将TAB字符显示为指定个数的空格字符</li>
</ul>
<h3 id="3-5-head-命令"><a href="#3-5-head-命令" class="headerlink" title="3.5 head 命令"></a>3.5 head 命令</h3><p>head 命令是用来显示文件开头内容的命令，基本信息如下：</p>
<ul>
<li>命令名称：head</li>
<li>英文原意：output the first part files</li>
<li>所在路径：/usr/bin/head</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件开头的内容</li>
</ul>
<p>命令格式：<code>head [选项] 文件名</code></p>
<ul>
<li><code>-n 行数</code>：从文件开头开始，显示指定行数</li>
<li><code>-v</code>：显示文件名</li>
</ul>
<h3 id="3-6-tail-命令"><a href="#3-6-tail-命令" class="headerlink" title="3.6 tail 命令"></a>3.6 tail 命令</h3><p>tail 命令是用来显示文件结尾内容的命令</p>
<ul>
<li>命令名称：tail</li>
<li>英文原意：output the last part files</li>
<li>所在路径：/usr/bin/tail</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件结尾的内容</li>
</ul>
<p>命令格式：<code>tail [选项] 文件名</code></p>
<ul>
<li><code>-n 行数</code>：从文件结尾开始，显示指定行数</li>
<li><code>-v</code>：显示文件名</li>
<li><code>-f</code>: 监听文件新增内容</li>
</ul>
<h3 id="3-7-ln-命令"><a href="#3-7-ln-命令" class="headerlink" title="3.7 ln 命令"></a>3.7 ln 命令</h3><p>ln命令用来为文件创件链接，连接类型分为硬连接和符号连接(软链接)两种，基本信息如下：</p>
<ul>
<li>命令名称：ln</li>
<li>英文原意：make links between file</li>
<li>所在路径：/bin/tail</li>
<li>执行权限：所有用户</li>
<li>功能描述：在文件之间建立链接</li>
</ul>
<p>命令格式：<code>ln [选项] 源文件 [目标文件]</code></p>
<ul>
<li>选项：<ul>
<li>-s: 建立软链接文件。如果不加’-s’选项，则建立硬链接文件</li>
<li>-f: 强行删除已存在的链接文件。如果链接文件已存在，则删除目标文件后再建立链接文件</li>
</ul>
</li>
<li><strong>源文件</strong>：指定链接的源文件。如果使用<code>-s</code>选项创建软链接，则“源文件”可以是<strong>文件或者目录</strong>，创建硬链接时，则“源文件”参数只能是<strong>文件</strong>。（源文件最好用绝对路径名，这样可以在任何工作目录下进行符号链接，而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接）</li>
<li><strong>目标文件</strong>：指定源文件的目标链接文件，省略则在当前目录下新建与源文件名称相同的链接文件</li>
</ul>
<blockquote>
<p>硬链接和源文件实际上是同一个文件，不会创建新的文件（类似于Java中，一个对象有多个引用）；而软链接会创建一个新文件来保存源文件的路径，从而间接读取或修改源文件内容<br>硬链接与软链接的特征<br><strong>硬链接特征</strong>：<br>1.源文件和硬链接文件拥有相同的Indoe和Block<br>2.修改任意一个文件，另一个都改变<br>3.删除任意一个文件，另一个都能使用<br>4.硬链接建立或删除，原文件连接数相应加一或减一<br>5.硬链接不能链接目录<br>6.硬链接不能跨分区<br>7.硬链接标记不清，很难确认硬链接文件位置，不建议使用</p>
<p><strong>软链接特征</strong>：<br>1.软链接和源文件拥有不同的Inode和Block<br>2.两个文件修改任意一个，另一个都改变<br>3.删除软链接，源文件不受影响；删除源文件，软链接不能使用<br>4.软链接建立或删除，原文件链接数不变<br>5.软链接可以链接目录<br>6.软链接可以跨分区<br>7.软链接特征明显，建议使用软链接<br>8.软链接没有实际数据，只是保存源文件的Inode，不论源文件多大，软链接大小不变<br>9.软链接的权限是最大权限<code>lrwxrwxrwx.</code>，但是由于没有实际数据，最终访问时需要参考源文件权限</p>
</blockquote>
<h2 id="4-文件和目录都能操作的命令"><a href="#4-文件和目录都能操作的命令" class="headerlink" title="4 文件和目录都能操作的命令"></a>4 文件和目录都能操作的命令</h2><h3 id="4-1-rm-命令"><a href="#4-1-rm-命令" class="headerlink" title="4.1 rm 命令"></a>4.1 rm 命令</h3><p>rm是最强大的删除命令，不仅可以删除文件，也可以删除目录，基本信息如下：</p>
<ul>
<li>命令名称：rm</li>
<li>英文原意：remove files or directories</li>
<li>所在路径：/bin/rm</li>
<li>执行权限：所有用户</li>
<li>功能描述：删除文件或目录</li>
</ul>
<p>命令格式：<code>rm [选项] 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>: 强制删除</li>
<li><code>-i</code>: 交互删除，在删除之前会询问用户</li>
<li><code>-r</code>: 递归删除，可以删除目录</li>
</ul>
</li>
</ul>
<h3 id="4-2-cp-命令"><a href="#4-2-cp-命令" class="headerlink" title="4.2 cp 命令"></a>4.2 cp 命令</h3><p>cp命令用于复制文件或目录，基本信息入下：</p>
<ul>
<li>命令名称：cp</li>
<li>英文原意：copy files and directories</li>
<li>所在路径：/bin/cp</li>
<li>执行权限：所有用户</li>
<li>功能描述：复制文件或目录</li>
</ul>
<p>命令格式：<code>cp [选项] 源文件 目标文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>: 如果文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接</li>
<li><code>-i</code>: 询问，如果目标文件已经存在，则会询问是否覆盖</li>
<li><code>-p</code>: 复制后目标文件保留源文件的属性(包括所有者、所有组、权限和时间)</li>
<li><code>-r</code>: 递归复制，用于复制目录</li>
<li><code>-a</code>: 相当于<code>-dpr</code>选项的集合</li>
</ul>
</li>
</ul>
<h3 id="4-3-mv-命令"><a href="#4-3-mv-命令" class="headerlink" title="4.3 mv 命令"></a>4.3 mv 命令</h3><p>mv命令用来剪贴文件或目录，基本信息如下：</p>
<ul>
<li>命令名称：mv</li>
<li>英文原意：move(rename) files</li>
<li>所在路径：/bin/mv</li>
<li>执行权限：所有用户</li>
<li>功能描述：移动文件或目录</li>
</ul>
<p>命令格式：<code>cp [选项] 源文件 目标文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>: 强制覆盖，如果目标文件已经存在，则不询问直接强制覆盖</li>
<li><code>-i</code>: 交互模式，如果目标文件已经存在，则询问用户是否覆盖（默认选项）</li>
<li><code>-v</code>：显示详细信息</li>
</ul>
</li>
</ul>
<h3 id="4-4-stat命令"><a href="#4-4-stat命令" class="headerlink" title="4.4 stat命令"></a>4.4 stat命令</h3><p>stat命令是查看文件详细的命令，基本信息如下：</p>
<ul>
<li>命令名称：stat</li>
<li>英文原意：display file or file system status</li>
<li>所在路径：/usr/bin/stat</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件或文件系统的详细信息</li>
</ul>
<p>命令格式：<code>stat [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>：显示文件系统状态而非文件状态</li>
<li><code>-t</code>：以简洁方式输出信息</li>
</ul>
</li>
</ul>
<h2 id="5-基本权限管理"><a href="#5-基本权限管理" class="headerlink" title="5 基本权限管理"></a>5 基本权限管理</h2><h3 id="5-1-权限介绍"><a href="#5-1-权限介绍" class="headerlink" title="5.1 权限介绍"></a>5.1 权限介绍</h3><p>使用ls命令时，长格式显示的第一列就是文件的权限，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l install.log</span><br><span class="line">-rw-r--r--. 1 root root 28425 11月 30 18:50 install.log</span><br></pre></td></tr></table></figure>
<p>第一列的权限位(<code>-rw-r--r--.</code>)如果不计最后的 “<strong>.</strong>“  (这个点代表受SELinux安全上下文保护，这里暂时忽略不做介绍)，则共10位，这10位权限位的含义如下图所示：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux003.png?x-oss-process=style/watermarking" alt="权限位"></p>
<ul>
<li><p><strong>第1位</strong>：代表文件类型。Linux不像Windows使用扩展名表示文件类型，而是使用权限位的第一位表示文件类型。虽然Linux文件的种类不像Windows中那么多，但是分类也不少，详细情况可以使用“<code>info ls</code>” 命令查看。这里列出一些常见的文件类型：</p>
<ul>
<li><code>-</code>: 普通文件</li>
<li><code>d</code>: 目录文件。Linux中一切皆文件，所以目录也是文件的一种</li>
<li><code>l</code>: 软链接文件</li>
<li><code>b</code>: 块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1就是这种文件</li>
<li><code>c</code>: 字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等</li>
<li><code>p</code>: 管道符文件。这是一种非常少见的特殊设备文件。</li>
<li><code>s</code>: 套接字文件。这也是一种特殊设备文件，一些服务支持socket访问就会产生这样的文件</li>
</ul>
</li>
<li><p><strong>第2~4位</strong>：代表文件所有者的权限</p>
<ul>
<li><code>r</code>: 代表read，是读取权限</li>
<li><code>w</code>： 代表write，是写权限</li>
<li><code>x</code>: 代表execute，是执行权限</li>
</ul>
</li>
<li><p><strong>第5~7位</strong>：代表文件所属组的权限，同样拥有“rwx”权限</p>
</li>
<li><p><strong>第8~10位</strong>：代表文件其他人的权限，同样拥有“rwx”权限</p>
</li>
</ul>
<p><strong>权限含义的解释：</strong><br>读、写、执行权限对文件和目录的作用是不同的。</p>
<ul>
<li><p>权限对文件的作用</p>
<ul>
<li>读(r)：对文件有读权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读权限，就可以对文件执行<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code>等文件查看命令</li>
<li>写(w)：对文件有写权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写权限，就可以对文件执行<code>vim</code>、<code>echo</code>等修改文件数据的命令。<strong>注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据，如果想要删除文件，则需要对文件的上级目录拥有写权限</strong>。</li>
<li>执行(x)：对文件有执行权限，代表文件可以运行。在Linux中，只要文件有执行权限，这个文件就是执行文件了，只是这个文件到底能不能正确执行，不仅需要看执行权限，还要看文件的代码是不是正确的语言代码。对文件来说，执行权限是最高权限</li>
</ul>
</li>
<li><p>权限对目录的作用</p>
<ul>
<li>读(r)：对目录有读权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些文件和子目录。如果包权限对应到命令上，那么一旦对目录拥有了读权限，就可以在目录下执行<code>ls</code>命令查看目录下的内容了</li>
<li>写(w)：对目录有写权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪贴子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写权限，就可以在目录下执行<code>touch</code>、<code>rm</code>、<code>cp</code>、<code>mv</code>等命令。对目录来说，写权限是最高权限</li>
<li>执行(x)：目录是不能运行的，那么对目录拥有执行权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行权限，就可以对目录执行<code>cd</code>命令进入目录</li>
</ul>
</li>
</ul>
<h3 id="5-2-chmod-命令"><a href="#5-2-chmod-命令" class="headerlink" title="5.2 chmod 命令"></a>5.2 chmod 命令</h3><p>chmod用来修改文件的权限，基本信息如下：</p>
<ul>
<li>命令名称：chmod</li>
<li>英文原意：change file mode bits</li>
<li>所在路径：/bin/chmod</li>
<li>执行权限：所有用户</li>
<li>功能描述：修改文件的权限模式</li>
</ul>
<p>命令格式：<code>chmod [选项] 权限模式 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-R</code>: 递归设置权限，也就是给予目录中的所有文件设定权限</li>
<li><code>--reference=RFILE</code>：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。</li>
</ul>
</li>
</ul>
<blockquote>
<p>chmod命令的<strong>权限模式</strong>分为<strong>符号组合</strong>和<strong>八进制数组合</strong><br>符号组合的格式是<code>[ugoa][[+-=][permission]]</code>，也就是<code>[用户身份][[赋予方式][权限]]</code>的格式。</p>
<ul>
<li>用户身份<ul>
<li><code>u</code>：代表所有者(user)</li>
<li><code>g</code>：代表所属组(group)</li>
<li><code>o</code>：代表其他人(other)</li>
<li><code>a</code>：代表全部身份(all)</li>
</ul>
</li>
<li>赋予方式<ul>
<li><code>+</code>：加入权限</li>
<li><code>-</code>：减去权限</li>
<li><code>=</code>：设置权限  </li>
</ul>
</li>
<li>权限<ul>
<li><code>r</code>: 读取权限(read)</li>
<li><code>w</code>: 写权限(write)</li>
<li><code>x</code>: 执行权限(execute)<br>八进制数组合的格式是<code>[0-7][0-7][0-7]</code>三位数字组成(每一位数字都是权限之和)，第一位是所有者权限，第二位是所属组权限，第三位其他人权限</li>
</ul>
</li>
<li><code>r</code>读取权限对应的数字是<code>4</code> </li>
<li><code>w</code>写权限对应的数字是<code>2</code> </li>
<li><code>x</code>执行权限对应的数字是<code>1</code></li>
<li>例如读写权限<code>rw</code>八进制数表示 <code>6</code> </li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加组用户的写权限。</span><br><span class="line">chmod g+w .&#x2F;test.log </span><br><span class="line"># 删除其他用户的所有权限。  </span><br><span class="line">chmod o&#x3D; .&#x2F;test.log </span><br><span class="line"># 使得所有用户都没有写权限。  </span><br><span class="line">chmod a-w .&#x2F;test.log </span><br><span class="line"># 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。  </span><br><span class="line">chmod u&#x3D;rwx, g&#x3D;rw, o&#x3D;r .&#x2F;test.log (等价的八进制数表示:chmod 754 .&#x2F;test.log )   </span><br><span class="line"># 将目录以及目录下的文件都设置为所有用户拥有读写权限。注意，使用&#39;-R&#39;选项一定要保留当前用户的执行和读取权限，否则会报错！  </span><br><span class="line">chmod -R a&#x3D;rw .&#x2F;testdir&#x2F; </span><br><span class="line"># 根据其他文件的权限设置文件权限。  </span><br><span class="line">chmod --reference&#x3D;.&#x2F;1.log .&#x2F;test.log</span><br></pre></td></tr></table></figure>

<h3 id="5-3-chown-命令"><a href="#5-3-chown-命令" class="headerlink" title="5.3 chown 命令"></a>5.3 chown 命令</h3><p>chown 命令用来修改文件和目录的所有者和所属组，基本信息如下：</p>
<ul>
<li>命令名称：chown</li>
<li>英文原意：change file owner and group</li>
<li>所在路径：/bin/chown</li>
<li>执行权限：所有用户</li>
<li>功能描述：修改文件和目录的所有者和所属组</li>
</ul>
<p>命令格式：<code>chown [选项] 所有者[:所属组] 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-R</code>：递归设置权限，也就是给予子目录的所有文件设置权限</li>
</ul>
</li>
<li>当省略 “:所属组” ，仅改变文件所有者</li>
</ul>
<blockquote>
<p>注意：普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行。普通用户可以修改所有者是自己的文件权限。</p>
</blockquote>
<h3 id="5-4-umask-命令"><a href="#5-4-umask-命令" class="headerlink" title="5.4 umask 命令"></a>5.4 umask 命令</h3><p>umask命令用来显示或设置创建文件或目录的权限掩码。</p>
<p>我们需要先了解一下新建文件和目录的默认最大权限，对于文件来讲，新建文件的默认最大权限是<code>666</code>，没有执行权限，只是因为执行权限对文件来讲比较危险，不能再新建文件的时候默认赋予，而必须通过用户手工赋予；对于目录来讲，新建目录的默认最大权限是<code>777</code>，这是因为对目录而言，执行权限仅仅代表进入目录，所以即使新建目录时直接默认赋予也没有什么危险。</p>
<p>按照官方的标准算法，<code>umask</code>默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限，这种方法既不好计算也不好理解，不推荐。我们这里按照权限字母来讲解<code>umask</code>权限的计算方。我们就按照默认的<code>umask</code>值是<code>0022</code>(等效于<code>022</code>)分别来计算一下新建文件和目录的默认权限，</p>
<ul>
<li><p>文件的默认权限最大只能是<code>666</code>，而<code>umask</code>的值是<code>022</code>，则 <code>rw-rw-rw-</code> 减去 <code>----w--w-</code>等于<code>rw-r--r--</code>，所以新建文件的默认权限是<code>rw-r--r--</code></p>
</li>
<li><p>目录的默认权限最大是<code>777</code>，而<code>umask</code>的值是<code>022</code>，则 <code>rwxrwxrwx</code> 减去 <code>----w--w-</code>等于<code>rwxr-xr-x</code>，所以新建目录的默认权限是<code>rwxr-xr-x</code></p>
</li>
<li><p>同理，如果<code>umask</code>的值是<code>033</code>，新建文件的默认权限为 <code>rw-rw-rw-</code> 减去 <code>----wx-wx</code>等于<code>rw-r--r--</code> </p>
</li>
</ul>
<p>命令格式：<code>umask  [选项] [模式]</code></p>
<ul>
<li>选项：<ul>
<li><code>-p</code>：输出的权限掩码可直接作为指令来执行 </li>
<li><code>-S</code>：以符号组合的方式输出权限掩码，不使用该选项时以八进制数的形式输出   </li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以八进制数的形式输出权限掩码</span><br><span class="line">[root@localhost tmp]# umask</span><br><span class="line">0022</span><br><span class="line"># 以八进制数的形式输出权限掩码，并作为指令来执行 </span><br><span class="line">[root@localhost tmp]# umask -p</span><br><span class="line">umask 0022</span><br><span class="line"># 以符号组合的方式输出权限掩码。</span><br><span class="line">[root@localhost tmp]# umask -S</span><br><span class="line">u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</span><br><span class="line"></span><br><span class="line">#上条命令以符号组合的方式输出权限掩码，输出的结果u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx转化为八进制数等于0755，</span><br><span class="line">#用八进制数来设置同样的权限，umask需要额外的执行减法&quot;0777 - 0755&quot;即0022</span><br><span class="line">[root@localhost tmp]# umask 0022</span><br><span class="line"></span><br><span class="line"># 为组用户添加写权限</span><br><span class="line">[root@localhost tmp]# umask g+w</span><br><span class="line"># 删除其他用户的写、执行权限</span><br><span class="line">[root@localhost tmp]# umask o-wx</span><br><span class="line"># 赋值全部用户所有权限，等价于umask u&#x3D;rwx,g&#x3D;rwx,o&#x3D;rwx</span><br><span class="line">[root@localhost tmp]# umask a&#x3D;rwx</span><br><span class="line">#清除其他用户的读、写、执行权限</span><br><span class="line">[root@localhost tmp]# umask o&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-帮助命令"><a href="#6-帮助命令" class="headerlink" title="6 帮助命令"></a>6 帮助命令</h2><h3 id="6-1-man-命令"><a href="#6-1-man-命令" class="headerlink" title="6.1 man 命令"></a>6.1 man 命令</h3><p>man命令是最常见的帮助命令，也是Linux最主要的帮助命令，基本信息如下：</p>
<ul>
<li>命令名称：man</li>
<li>英文原意：format and display the on-line manual pages</li>
<li>所在路径：/usr/bin/chown</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示连机帮助手册</li>
</ul>
<p>命令格式：<code>man [选项] [章节] 命令</code></p>
<ul>
<li>选项：<ul>
<li>-f: 查看命令有哪些章节的帮助和简短描述信息，等价于<code>whatis</code>指令</li>
<li>-k: 查看和命令相关的所有帮助</li>
</ul>
</li>
</ul>
<p><code>man</code>命令交互快捷键：</p>
<ul>
<li><code>上箭头</code>：向上移动一行 </li>
<li><code>下箭头</code>：向下移动一行 </li>
<li><code>PgUP</code>：向上翻一页 </li>
<li><code>PgDn</code>：向下翻一页</li>
<li><code>g</code>：移动到第一页</li>
<li><code>G</code>：移动到最后一页</li>
<li><code>q</code>：退出 </li>
<li><code>/字符串</code>：从当前向下搜索字符串 </li>
<li><code>?字符串</code>：从当前向上搜索字符串 </li>
<li><code>n</code>：当搜索字符串时，可以用n键找到下一个字符串</li>
<li><code>N</code>：当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则N键表示向上搜索字符串；如果使用“?字符串”方式搜索，则N键表示向下搜索字符串</li>
</ul>
<p><code>man</code>手册章节：</p>
<ul>
<li><code>1</code>： 用户在shell环境可操作的命令或执行文件</li>
<li><code>2</code>： 系统内核可调用的函数与工具等</li>
<li><code>3</code>： 一些常用的函数(function)与函数库(library)，大部分为C的函数库(libc)</li>
<li><code>4</code>： 设备文件说明，通常在/dev下的文件</li>
<li><code>5</code>： 配置文件或某些文件格式</li>
<li><code>6</code>： 游戏帮助(个人版的Linux中是有游戏的)</li>
<li><code>7</code>： 惯例与协议等，如Linux文件系统，网络协议，ASCII code等说明</li>
<li><code>8</code>： 系统管理员可用的管理命令</li>
<li><code>9</code>： 跟kernel有关的文件</li>
</ul>
<p><code>man</code>手册的格式：</p>
<ul>
<li><code>NAME</code>: 命令名称及功能简要说明</li>
<li><code>SYNOPSIS</code>：用法说明，包括可用的选项<ul>
<li><code>[]</code>：可选内容</li>
<li><code>&lt;&gt;</code>：必选内容</li>
<li><code>a|b</code>：二选一</li>
<li><code>&#123;&#125;</code>：分组</li>
<li><code>...</code>：同意内容可出现多次</li>
</ul>
</li>
<li><code>DESCRIPTION</code>：命令功能的详细说明，可能包括每一个选项的意义</li>
<li><code>OPTIONS</code>：说明每一项的意义</li>
<li><code>EXAMPLES</code>：使用示例</li>
<li> <code>FILES</code>：此命令相关的配置文件</li>
<li> <code>AUTHOR</code>：作者</li>
<li> <code>COPYRIGHT</code>：版本信息</li>
<li> <code>REPORTTING BUGS</code>：bug信息        </li>
<li><code>SEE ALSO</code>：参考其他帮助</li>
</ul>
<p>示例：<br>我们输入 <code>man ls</code>，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输 <code>man ifconfig</code> 它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man [章节号] 手册名称”。</p>
<p><code>man</code>是按照手册的章节号的顺序进行搜索的，比如：<code>man sleep</code> 只会显示sleep命令的手册，如果想查看库函数sleep，就要输入：<code>man 3 sleep</code></p>
<h3 id="6-2-info-命令"><a href="#6-2-info-命令" class="headerlink" title="6.2 info 命令"></a>6.2 info 命令</h3><p>info 命令的帮助信息是一套完整的资料，每个单独命令的<code>man</code>帮助信息只是这套完整资料的某一个区段(节点)，基本信息如下：</p>
<ul>
<li>命令名称：info</li>
<li>英文原意：info</li>
<li>所在路径：/usr/bin/info</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示一套完整的帮助信息资料</li>
</ul>
<p>命令格式：<code>info [选项] 参数</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：添加包含info格式帮助文档的目录</li>
<li><code>-f</code>：指定要读取的info格式的帮助文档</li>
<li><code>-n</code>：指定首先访问的info帮助文件的节点</li>
<li><code>-o</code>：输出被选择的节点内容到指定文件</li>
</ul>
</li>
<li>参数：指定需要获得帮助的主题，可以是指令、函数以及配置文件</li>
</ul>
<p><code>info</code>命令交互快捷键</p>
<ul>
<li><code>上箭头</code>：向上移动一行 </li>
<li><code>下箭头</code>：向下移动一行 </li>
<li><code>PgUP</code>：向上翻一页 </li>
<li><code>PgDn</code>：向下翻一页</li>
<li><code>Tab</code>：在有“*”符号的节点间切换</li>
<li><code>回车</code>：进入有“*” 符号的子页面，查看详细帮助信息</li>
<li><code>u</code>：进入上一层信息(回车是进入下一层信息)</li>
<li><code>q</code>：退出info帮助信息 </li>
<li><code>n</code>：进入下一小节信息</li>
<li><code>p</code>：进入上一下节信息</li>
<li><code>?</code>：查看帮助信息</li>
</ul>
<h3 id="6-3-help-命令"><a href="#6-3-help-命令" class="headerlink" title="6.3 help 命令"></a>6.3 help 命令</h3><p>help 命令只能获取shell内置命令的帮助，基本信息如下：</p>
<ul>
<li>命令名称：help</li>
<li>英文原意：help</li>
<li>所在路径：shell 内置命令</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示shell内置命令的帮助。可以使用shell内置命令<code>type</code>来区分内置命令与外部命令，对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>命令查看</li>
</ul>
<p>命令格式：<code>help [选项] 内置命令</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：显示内建命令的简要描述。 </li>
<li><code>-m</code>：按照man手册的格式输出内置命令的帮助信息。 </li>
<li><code>-s</code>：仅输出内建命令的命令格式。 </li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以man手册的格式查看内置命令type的帮助信息</span><br><span class="line">[root@localhost ~]# help -m type</span><br><span class="line">NAME</span><br><span class="line">    type - Display information about command type.</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    type [-afptP] name [name ...]</span><br><span class="line"> (省略。。。)</span><br><span class="line"></span><br><span class="line"># 查看ls、help命令是否是内置命令</span><br><span class="line">[root@localhost ~]# type ls</span><br><span class="line">ls is aliased to &#96;ls --color&#x3D;auto&#39;</span><br><span class="line">[root@localhost ~]# type help</span><br><span class="line">help is a shell builtin</span><br></pre></td></tr></table></figure>


<h3 id="6-4-–help-选项"><a href="#6-4-–help-选项" class="headerlink" title="6.4 –help 选项"></a>6.4 –help 选项</h3><p>绝大多数命令都可以使用<code>--help</code>选项来查看帮助，者也是一种获取帮助的方法。例如 <code>ls --help</code>，这种方法非常简单，输出的帮助信息基本上是<code>man</code>命令的信息简要版。</p>
<h2 id="7-搜索命令"><a href="#7-搜索命令" class="headerlink" title="7 搜索命令"></a>7 搜索命令</h2><h3 id="7-1-whereis-命令"><a href="#7-1-whereis-命令" class="headerlink" title="7.1 whereis 命令"></a>7.1 whereis 命令</h3><p>whereis 是搜索命令的命令，也就是说whereis不能搜索普通文件，而只能搜索系统命令，基本信息如下：</p>
<ul>
<li>命令名称：whereis</li>
<li>英文原意：locate the binary,source,and manual page files for a command</li>
<li>所在路径：/usr/bin/whereis</li>
<li>执行权限：所有用户</li>
<li>功能描述：查找二进制命令、源文件和帮助文档的路径</li>
</ul>
<p>命令格式：<code>whereis [选项] 参数</code></p>
<ul>
<li>选项：<ul>
<li><code>-b</code>：只查找二进制文件 </li>
<li><code>-B 目录</code>：只在设置的目录下查找二进制文件</li>
<li><code>-m</code>：只查找说明文件</li>
<li><code>-M 目录</code>：只在设置的目录下查找说明文件</li>
<li><code>-s</code>：只查找原始代码文件</li>
<li><code>-S 目录</code>：只在设置的目录下查找原始代码文件</li>
<li><code>-f</code>：不显示文件名前的路径名称 </li>
</ul>
</li>
</ul>
<h3 id="7-2-which-命令"><a href="#7-2-which-命令" class="headerlink" title="7.2 which 命令"></a>7.2 which 命令</h3><p>which 也是搜索系统命令的命令，和<code>whereis</code>的区别在于，<code>whereis</code>命令可以在查找二进制命令的同时，查找帮助文档的位置，而<code>which</code>命令在查找到二进制命令的同时，如果这个命令有别名，则还可以查到别名命令。基本信息如下：</p>
<ul>
<li>命令名称：which</li>
<li>英文原意：shows the full path of (shell) commands</li>
<li>所在路径：/usr/bin/which</li>
<li>执行权限：所有用户</li>
<li>功能描述：列出二进制命令路径和别名。<code>which</code>只会在环境变量$PATH设置的目录里查找符合条件的命令</li>
</ul>
<p>命令格式：<code>which [选项] 参数</code></p>
<h3 id="7-3-find-命令"><a href="#7-3-find-命令" class="headerlink" title="7.3 find 命令"></a>7.3 find 命令</h3><p>find命令用来在指定目录下查找文件，基本信息如下：</p>
<ul>
<li>命令名称：find</li>
<li>英文原意：search for files in a directory hierarchy</li>
<li>所在路径：/bin/find</li>
<li>执行权限：所有用户</li>
<li>功能描述：在指定目录中搜索文件</li>
</ul>
<p>命令格式：<code>find [搜索路径] [选项]</code></p>
<ul>
<li>搜索路径：省略则默认为当目录，相当于 “find .”</li>
<li>选项：<ul>
<li><code>-name 范本样式</code>：按照文件名称搜索，支持通配符模糊查询</li>
<li><code>-iname 范本样式</code>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别</li>
<li><code>-inum inode编号</code>：查找符合指定的inode编号的文件或目录</li>
<li><code>-path 范本样式</code>：查找路径包含范本样式的文件或目录</li>
<li><code>-regex 范本样式</code>：正则表达式搜索</li>
<li><code>-iregex 范本样式</code>：同”-regex”，忽略大小写</li>
<li><code>-size [+|-]文件大小[cwbkMG] </code>：查找符合指定的文件大小的文件<ul>
<li>“+” 的意思是搜索比指定大小还要大的文件，”-“ 的意思是搜索比指定大小还要小的文件</li>
<li>“cwbkMG”是单位，c——字节，w——字(2字节)，b——块(512字节)，k——千字节，M——兆字节，G——吉字节。如果不写单位默认是b</li>
</ul>
</li>
<li><code>-atime [+|-]天数</code>：按照文件最后一次访问时间搜索，单位每天<ul>
<li>“+”、”-“的含义，例如”5”表示恰好5天前的那一天，”+5”超过5天前的时间，”-5”5天内的时间。(以下按时间搜索选项中”+”、”-“含义相同)</li>
</ul>
</li>
<li><code>-mtime [+|-]天数</code>：按照文件数据最后一次修改时间搜索，单位每天</li>
<li><code>-ctime [+|-]天数</code>：按照文件元数据(如权限等)最后一次修改时间搜索，单位每天</li>
<li><code>-amin [+|-]分钟数</code>：按照文件最后一次访问时间搜索，单位每分钟</li>
<li><code>-mmin [+|-]分钟数</code>：按照文件数据最后一次修改时间搜索，单位每分钟</li>
<li><code>-cmin [+|-]分钟数</code>：按照文件元数据(如权限等)最后一次修改时间搜索，单位每分钟</li>
<li><code>-perm [+|-]权限数值</code>：查找符合指定的权限数值的文件或目录。例如，权限数值为”766”表示权限恰好等于766，”-766”表示文件权限必须全部包含766，”+766”表示文件权限包含766任意一个权限</li>
<li><code>-uid 用户ID</code>：查找所有者是指定用户ID的文件</li>
<li><code>-user 用户名</code>：查找所有者是指定用户名的文件</li>
<li><code>-gid 组ID</code>：查找所有组是指定组ID的文件</li>
<li><code>-group 组名</code>：查找所有组是指定组名的文件</li>
<li><code>-nouser</code>：查找没有所有者的文件<ul>
<li>按照所有者和所有组搜索时，”-nouser”选项比较常用，主要用于查找垃圾文件。没有所有者的文件比较少见，那就是外来文件，比如光盘和U盘的文件是由Windows复制的，在Linux中查看就是没有所有者的文件，再比如手工源码包安装的文件也可能没有所有者</li>
</ul>
</li>
<li><code>-type 文件类型</code>：只寻找符合指定的文件类型的文件<ul>
<li><code>f</code>——普通文件，<code>l</code>——符号连接，<code>d</code>——目录，<code>c</code>——字符设备，<code>b</code>——块设备，<code>s</code>——套接字，<code>p</code>——Fifo</li>
</ul>
</li>
<li><code>-empty</code>：查找文件大小为0的文件</li>
<li><code>-maxdepth 目录层级数</code>：设置搜索的最大目录层级</li>
<li><code>-mindepth 目录层级</code>：设置搜索的最小目录层级</li>
<li><code>-exec 执行指令</code>：把find命令查找结果交由”-exec”调用的命令来处理<ul>
<li>格式：<code>find [搜索路径] [选项] -exec 命令 &#123;&#125; \;</code>, 其中”{}”代表find命令的查询结果</li>
</ul>
</li>
<li><code>-ok 执行指令</code>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户是否执行</li>
<li><code>-prune</code>：不寻找字符串作为寻找文件或目录的范本样式</li>
<li><code>-a</code>：and 逻辑与</li>
<li><code>-o</code>: or 逻辑或</li>
<li><code>-not</code>：not 逻辑非</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;根据文件名或者正则表达式进行匹配&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#列出当前目录及子目录下所有文件和文件夹</span><br><span class="line">[root@localhost ~]# find .</span><br><span class="line">#在&#96;&#x2F;home&#96;目录下查找以.txt结尾的文件名</span><br><span class="line">[root@localhost ~]# find &#x2F;home -name &quot;*.txt&quot;</span><br><span class="line">#同上，但忽略大小写</span><br><span class="line">[root@localhost ~]# find &#x2F;home -iname &quot;*.txt&quot;</span><br><span class="line">#当前目录及子目录下查找所有以.txt和.pdf结尾的文件</span><br><span class="line">[root@localhost ~]# find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br><span class="line">#查找路径包含local的文件或者目录</span><br><span class="line">[root@localhost ~]# find &#x2F;usr&#x2F; -path &quot;*local*&quot;</span><br><span class="line">#基于正则表达式匹配文件路径</span><br><span class="line">[root@localhost ~]# find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;借助&#96;-exec&#96;选项与其他命令结合使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#找出当前目录下所有root的文件，并把所有权更改为用户tom</span><br><span class="line">[root@localhost ~]# find .-type f -user root -exec chown tom &#123;&#125; \;</span><br><span class="line">#找出自己家目录下所有的.txt文件并删除，删除前先询问</span><br><span class="line">[root@localhost ~]# find $HOME&#x2F;. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br><span class="line">#查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span><br><span class="line">[root@localhost ~]# find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br><span class="line">#将30天前的.log文件移动到old目录中</span><br><span class="line">[root@localhost ~]# find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br><span class="line">#找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</span><br><span class="line">[root@localhost ~]# find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;逻辑运算符&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#查找文件大小超过2k并且是普通文件类型的文件</span><br><span class="line">[root@localhost ~]# find . -size +2k -a -type f</span><br><span class="line">#找出&#x2F;home下不是以.txt结尾的文件</span><br><span class="line">[root@localhost tmp]# find . -not -name &quot;*.txt&quot;</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# find &#x2F;home ! -name &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;搜索但跳出指定的目录&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span><br><span class="line">[root@localhost ~]# find . -path &quot;.&#x2F;sk&quot; -prune -o -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-locate-命令"><a href="#7-4-locate-命令" class="headerlink" title="7.4 locate 命令"></a>7.4 locate 命令</h3><p>locate命令其实是<code>find -name</code>的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录(<code>find</code> 是去硬盘找)，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code>，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用<code>locate</code>命令查不到最新变动过的文件，为了避免这种情况，可以在使用<code>locate</code>之前，先使用<code>updatedb</code>命令手动更新数据库。locate命令基本信息如下：</p>
<ul>
<li>命令名称：locate</li>
<li>英文原意：find files by name</li>
<li>所在路径：/usr/bin/locate</li>
<li>执行权限：所有用户</li>
<li>功能描述：按照文件名搜索文件</li>
</ul>
<p>命令格式：<code>locate [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>: 指定资料库的路径。默认是/var/lib/mlocate/mlocate.db</li>
<li><code>-n</code>：至多显示n个输出</li>
</ul>
</li>
</ul>
<p>数据库配置文件(<code>/etc/updatedb.conf</code>)内容说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;etc&#x2F;updatedb.conf</span><br><span class="line">#开启搜索限制，也就是让这个文件生效</span><br><span class="line">PRUNE_BIND_MOUNTS &#x3D; &quot;yes&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索这些文件类型</span><br><span class="line">PRUNEFS &#x3D; &quot;9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fusectl gfs gfs2 gpfs hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索这些扩展名的文件</span><br><span class="line">PRUNENAMES &#x3D; &quot;.git .hg .svn&quot;</span><br><span class="line">##在locate执行搜索时，禁止搜索这些系统目录</span><br><span class="line">PRUNEPATHS &#x3D; &quot;&#x2F;afs &#x2F;media &#x2F;net &#x2F;sfs &#x2F;tmp &#x2F;udev &#x2F;var&#x2F;cache&#x2F;ccache &#x2F;var&#x2F;spool&#x2F;cups &#x2F;var&#x2F;spool&#x2F;squid &#x2F;var&#x2F;tmp&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>locate优缺点：<br><strong>优点</strong>：按照数据库搜索，搜索速度快，消耗资源小<br><strong>缺点</strong>：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等</p>
</blockquote>
<h3 id="7-5-grep-命令"><a href="#7-5-grep-命令" class="headerlink" title="7.5 grep 命令"></a>7.5 grep 命令</h3><p>grep命令的作用是在文件中提取和匹配符合条件的字符串行，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。基本信息如下：</p>
<ul>
<li>命令名称：grep</li>
<li>英文原意：global search regular expression(RE) and print out the line</li>
<li>所在路径：/usr/bin/grep</li>
<li>执行权限：所有用户</li>
<li>功能描述：全面搜索正则表达式并把行打印出来</li>
</ul>
<p>命令格式：<code>grep [选项] 搜索内容 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-i</code>：忽略大小写</li>
<li><code>-n</code>：输出行号</li>
<li><code>-v</code>：反向查找</li>
<li><code>-d 动作</code>: 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。动作包含：read、recurse、skip</li>
<li><code>-R</code>或<code>-r</code>: 此参数的效果和指定“-d recurse”参数相同，递归查找目录下的所有文件内容</li>
<li><code>--color=auto</code>：搜素出的关键字用颜色高亮显示</li>
</ul>
</li>
</ul>
<p>find也是搜索命令，那么find与grep命令有什么区别呢？<br><strong>find</strong>：find命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，通配符是完全匹配。(find命令也可以通过”-regex”选项，把匹配规则转为正则表达式规则)<br><strong>grep</strong>：grep命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，正则表达式是包含匹配。</p>
<blockquote>
<p>通配符与正则表达式的区别</p>
<ul>
<li>通配符：一般用于匹配文件名，完全匹配<ul>
<li><code>?</code>：匹配一个任意字符</li>
<li><code>*</code>：匹配0个或多个任意字符，也就是可以匹配任何内容</li>
<li><code>[]</code>：匹配中括号里任意一个字符。例如，[abc]代表一定匹配一个字符，或是a，或是b，或是c</li>
<li><code>[-]</code>：匹配中括号里任意一个字符，”-“代表一个范围。例如，[a-z]代表匹配一个小写字母</li>
<li><code>[^]</code>：逻辑非，表示匹配不是中括号里的一个字符。例如，[^0-9]代表匹配一个不是数字的字符</li>
</ul>
</li>
<li>正则表达式：一般用于匹配字符串<ul>
<li><code>?</code>：匹配前一个字符重复0次或1次</li>
<li><code>*</code>：匹配前一个字符重复0次或多次</li>
<li><code>[]</code>：匹配中括号里任意一个字符。例如，[abc]代表一定匹配一个字符，或是a，或是b，或是c</li>
<li><code>[-]</code>：匹配中括号里任意一个字符，”-“代表一个范围。例如，[a-z]代表匹配一个小写字母</li>
<li><code>[^]</code>：逻辑非，表示匹配不是中括号里的一个字符。例如，[^0-9]代表匹配一个不是数字的字符</li>
<li><code>^</code>：匹配行首</li>
<li><code>$</code>：匹配行尾   </li>
</ul>
</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</span><br><span class="line">[root@localhost ~]# grep match_pattern file_name</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_name</span><br><span class="line">#在多个文件中查找：</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_1 file_2 file_3</span><br><span class="line">#标记匹配颜色 --color&#x3D;auto 选项：</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_name --color&#x3D;auto</span><br><span class="line">#在当前目录中对文本进行递归搜索</span><br><span class="line">[root@localhost ~]# grep -r &quot;match_pattern&quot; .</span><br><span class="line">#正则匹配输出以数字开头的所有行</span><br><span class="line">[root@localhost ~]# grep &quot;^[0-9].*&quot; file_name</span><br></pre></td></tr></table></figure>


<h3 id="7-6-管道符"><a href="#7-6-管道符" class="headerlink" title="7.6 | 管道符"></a>7.6 | 管道符</h3><p>命令格式：<code>命令1 | 命令2</code><br>“|”管道符的作用是把命令1的正确输出作为命令2的操作对象</p>
<p><strong>示例1</strong>：<br>我们经常使用 “ll” 命令查看文件的长格式，不过在有些目录中文件很多，不如/etc/目录使用 “ll” 命令显示的内容就非常多，只能看到最后的内容而不能看到前面输出的内容，这时我们马上想到 “more” 命令可以分屏显示文件内容，一种笨方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用输出重定向，把&quot;ll&quot;命令的输出保存到&#x2F;root&#x2F;testfile</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; &gt; &#x2F;root&#x2F;testfile</span><br><span class="line">#然后用more分屏显示</span><br><span class="line">[root@localhost ~]# more &#x2F;root&#x2F;testfile</span><br></pre></td></tr></table></figure>
<p>这样操作实在是不方便，这时可以利用管道符，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#把&quot;ll&quot;命令的输出作为&quot;more&quot;命令的操作对象</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; | more</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在&quot;ll&quot;命令输出内容中搜索yum的文件名</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; | grep yum</span><br></pre></td></tr></table></figure>


<p><strong>示例3</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#统计具体的网络连接数量（&quot;grep&quot;命令筛选，&quot;wc&quot;命令统计）</span><br><span class="line">[root@localhost ~]# netstat -an | grep -i &quot;ESTABLISHED&quot; | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="7-7-alias-命令"><a href="#7-7-alias-命令" class="headerlink" title="7.7 alias 命令"></a>7.7 alias 命令</h3><p>alias命令用来设置指令的别名，我们可以使用该命令可以将一些较长的命令进行简化。</p>
<p><strong>alias基本使用方法</strong>：</p>
<ul>
<li>打印已经设置的命令别名<ul>
<li><code>alias</code> 或  <code>alias -p</code></li>
</ul>
</li>
<li>给命令设置别名<ul>
<li>格式：<code>alias 新的命令=&#39;实际命令&#39;</code>。必须使用单引号’’实际命令引起来，防止特殊字符导致错误</li>
<li>例如：<code>alias l=&#39;ls -lsh&#39;</code>，现在只用输入 “l” 就可以列出目录了，相当于输入”ls -lsh”；<code>alias ser=&#39;service network restart&#39;</code>，现在输入”ser”就可以重启网络服务了</li>
</ul>
</li>
</ul>
<blockquote>
<p>直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？<br>使用编辑器打开<del>/.bashrc，在文件中加入别名设置，如：alias rm=’rm -i’，保存后执行source ~/.bashrc，这样就可以永久保存命令的别名了。因为修改的是当前用户目录下的</del>/.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc/bashrc文件就可以了。</p>
</blockquote>
<h2 id="8-压缩和解压缩命令"><a href="#8-压缩和解压缩命令" class="headerlink" title="8 压缩和解压缩命令"></a>8 压缩和解压缩命令</h2><p>在Linux中可以识别的常见压缩格式有十几种，比如”.zip”、”.gz”、”.bz2”、”.tar”、”.tar.gz”、”.tar.bz2”等。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间</p>
<h3 id="8-1-“-zip”-格式"><a href="#8-1-“-zip”-格式" class="headerlink" title="8.1 “.zip” 格式"></a>8.1 “.zip” 格式</h3><p>“.zip”是Windows中最常见的压缩格式，Liunx也可以正确识别”.zip”格式，这可以方便地和Windows系统通用压缩文件。</p>
<h4 id="8-1-1-zip-命令"><a href="#8-1-1-zip-命令" class="headerlink" title="8.1.1 zip 命令"></a>8.1.1 zip 命令</h4><p>zip命令就是”.zip”格式的压缩命令，基本信息如下：</p>
<ul>
<li>命令名称：zip</li>
<li>英文原意：package and compress(archive) files</li>
<li>所在路径：/usr/bin/zip</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩文件和目录</li>
</ul>
<p>命令格式：<code>zip [选项] 压缩包名 源文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-r</code>：压缩目录递归处理，将指定目录下的所有文件和子目录一并处理</li>
</ul>
</li>
</ul>
<h4 id="8-1-2-unzip-命令"><a href="#8-1-2-unzip-命令" class="headerlink" title="8.1.2 unzip 命令"></a>8.1.2 unzip 命令</h4><p>unzip命令就是”.zip”格式的解压缩命令，基本信息如下：</p>
<ul>
<li>命令名称：unzip</li>
<li>英文原意：list, test and extract compressed files in a zip archive</li>
<li>所在路径：/usr/bin/unzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：列表、测试和提取压缩文件中的文件</li>
</ul>
<p>命令格式：<code>unzip [选项] 压缩包名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：指定解压的位置</li>
</ul>
</li>
</ul>
<h3 id="8-2-“-gz”-格式"><a href="#8-2-“-gz”-格式" class="headerlink" title="8.2 “.gz” 格式"></a>8.2 “.gz” 格式</h3><p>“.gz”格式是Linux中最常见的压缩格式。</p>
<h4 id="8-2-1-gzip-命令"><a href="#8-2-1-gzip-命令" class="headerlink" title="8.2.1 gzip 命令"></a>8.2.1 gzip 命令</h4><p>gzip命令是”.gz”格式的压缩和解压缩命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。<strong>注意：gzip不会打包文件，压缩的过程源文件会对应变为”.gz”格式的压缩文件(源文件被删除)，解压缩的过程将”.gz”格式的压缩文件再恢复成对应的源文件</strong>。基本信息如下：</p>
<ul>
<li>命令名称：gzip</li>
<li>英文原意：compress or expand files</li>
<li>所在路径：/bin/gzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩或解压缩 “.gz” 格式的文件或目录</li>
</ul>
<p>命令格式：<code>gzip [选项] 源文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：执行解压缩</li>
<li><code>-r</code>：递归处理，将指定目录下的所有文件及子目录一并处理</li>
<li><code>-c</code>：将压缩数据输出到标准输出中，可以保留源文件<ul>
<li>使用”-c”选项，压缩数据会直接输出到屏幕上，为了不让压缩数据输出到屏幕上而是重定向到压缩文件中，并且同时保留源文件，命令可以这样写：<code>gzip -c abc &gt; abc.gz</code></li>
</ul>
</li>
<li><code>-l</code>：列出压缩文件的相关信息 </li>
</ul>
</li>
</ul>
<h4 id="8-2-2-gunzip-命令"><a href="#8-2-2-gunzip-命令" class="headerlink" title="8.2.2 gunzip 命令"></a>8.2.2 gunzip 命令</h4><p>gunzip命令用来解压缩 “.gz” 格式的文件(即使用 “gzip” 命令压缩的文件)，作用相当于 “gzip -d 压缩文件”，因此不论是压缩或解压缩，都可通过 “gzip” 指令单独完成。基本下信息如下：</p>
<ul>
<li>命令名称：gunzip</li>
<li>英文原意：expand files</li>
<li>所在路径：/bin/gunzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：解压缩”.gz” 格式的文件或目录</li>
</ul>
<p>命令格式：<code>gunzip [选项] 压缩文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-r</code>：递归处理，将指定目录下的所有文件及子目录一并处理</li>
<li><code>-c</code>：把解压后的文件数据输出到标准输出中，可以保留压缩文件</li>
<li><code>-l</code>：列出压缩文件的相关信息</li>
</ul>
</li>
</ul>
<h3 id="8-3-“-bz2”-格式"><a href="#8-3-“-bz2”-格式" class="headerlink" title="8.3 “.bz2” 格式"></a>8.3 “.bz2” 格式</h3><p>“.bz2” 格式是Linux的另一种压缩格式，从理论上来讲，”.bz2” 格式的算法更新进、压缩比更好；而 “.gz” 格式相对来讲压缩的时间更快</p>
<h4 id="8-3-1-bzip2-命令"><a href="#8-3-1-bzip2-命令" class="headerlink" title="8.3.1 bzip2 命令"></a>8.3.1 bzip2 命令</h4><p>bzip2 命令是 “.bz2” 格式文件的压缩和解压缩命令。<strong>注意：”bzip2”不能用来压缩目录</strong>。基本信息如下：</p>
<ul>
<li>命令名称：bzip2</li>
<li>英文原意：a block-sorting file compressor</li>
<li>所在路径：/usr/bin/bzip2</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩或解压缩 “.bz2” 格式的文件</li>
</ul>
<p>命令格式：<code>bzip2 [选项] 源文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：执行解压缩</li>
<li><code>-k</code>：压缩或解压缩后，会删除原始文件，若要保留原始文件，请使用此参数</li>
<li><code>-f</code>：在压缩或解压缩时，若输出文件与现有文件同名，强制覆盖现有文件</li>
<li><code>-c</code>：将压缩与解压缩的数据输出到标准输出中</li>
</ul>
</li>
</ul>
<h4 id="8-3-2-bunzip2-命令"><a href="#8-3-2-bunzip2-命令" class="headerlink" title="8.3.2 bunzip2 命令"></a>8.3.2 bunzip2 命令</h4><p>bunzip2命令用来解压缩 “.bz2” 格式的文件(即使用 “bzip2” 命令压缩的文件)，作用相当于 “bzip2 -d 压缩文件”，因此不论是压缩或解压缩，都可通过 “bzip2” 指令单独完成。基本信息如下：</p>
<ul>
<li>命令名称：bunzip2</li>
<li>英文原意：a block-sorting file compressor</li>
<li>所在路径：/usr/bin/bunzip2</li>
<li>执行权限：所有用户</li>
<li>功能描述：解压缩 “.bz2” 格式的文件</li>
</ul>
<p>命令格式：<code>bunzip2 [选项] 压缩文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-k</code>：bzip2在解压缩后，会删除原始压缩文件，若要保留原始压缩文件，请使用此参数</li>
<li><code>-f</code>：解压缩时，若输出的文件与现有文件同名时，强制覆盖现有的文件</li>
<li><code>-c</code>：将解压缩的数据输出到标准输出中</li>
</ul>
</li>
</ul>
<h3 id="8-4-“-tar”、”-tar-gz”、”-tar-bz2”-格式"><a href="#8-4-“-tar”、”-tar-gz”、”-tar-bz2”-格式" class="headerlink" title="8.4 “.tar”、”.tar.gz”、”.tar.bz2” 格式"></a>8.4 “.tar”、”.tar.gz”、”.tar.bz2” 格式</h3><p>tar命令可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。<strong>注意：打包和压缩是两个不同的概念，打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</strong>。为什么要区分这两个概念呢？这源于Linux中很多压缩程序(gzip、bzip2)只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar），然后再用压缩程序进行压缩。tar命令基本信息如下：</p>
<ul>
<li>命令名称：tar</li>
<li>英文原意：tar</li>
<li>所在路径：/usr/bin/tar</li>
<li>执行权限：所有用户</li>
<li>功能描述：打包与解打包文件</li>
</ul>
<p>命令格式：<br><strong>打包</strong>：<code>tar -c [选项] [-f 包文件名] 源文件或目录</code><br><strong>解打包</strong>：<code>tar -x [选项] -f 包文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-c</code>：执行打包</li>
<li><code>-x</code>：执行解打包</li>
<li><code>-z</code>：支持压缩和解压缩 “.tar.gz” 格式文件</li>
<li><code>-j</code>：支持压缩和解压缩 “.tar.bz2” 格式文件</li>
<li><code>-C 目录路径</code>：指定解打包位置</li>
<li><code>-f 包文件名</code>: 指定打包文件名(.tar)或压缩包文件名(.tar.gz、.tar.bz2)。（执行打包时不写此选项，会默认把打包数据输出到屏幕）</li>
<li><code>-v</code>: 显示打包或解打包过程</li>
<li><code>-t</code>：测试，就是不解打包，只是查看包中有哪些文件</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#打包不会压缩</span><br><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line">#解打包到当前目录</span><br><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar</span><br><span class="line">#解打包到指定目录</span><br><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar -C &#x2F;testdir&#x2F;</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar.gz&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#把&#x2F;tmp&#x2F;目录直接打包并压缩为&quot;.tar.gz&quot;格式</span><br><span class="line">[root@localhost ~]# tar -zcvf tmp.tar.gz &#x2F;tmp&#x2F;</span><br><span class="line">#解压缩并解打包&quot;.tar.gz&quot;格式文件</span><br><span class="line">[root@localhost ~]# tar -zxvf tmp.tar.gz</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar.bz2&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#把&#x2F;tmp&#x2F;目录直接打包并压缩为&quot;.tar.bz2&quot;格式</span><br><span class="line">[root@localhost ~]# tar -jcvf tmp.tar.gz &#x2F;tmp&#x2F;</span><br><span class="line">#解压缩并解打包&quot;.tar.bz2&quot;格式文件</span><br><span class="line">[root@localhost ~]# tar -jxvf tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-关机和重启命令"><a href="#9-关机和重启命令" class="headerlink" title="9 关机和重启命令"></a>9 关机和重启命令</h2><h3 id="9-1-sync-数据同步"><a href="#9-1-sync-数据同步" class="headerlink" title="9.1 sync 数据同步"></a>9.1 sync 数据同步</h3><p>sync命令用于强制被改变的内容立刻写入磁盘。在Linux/Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行sync命令，系统会自动执行update或bdflush操作，将缓冲区的数据写入磁盘。<strong>只有在update或bdflush无法执行或用户需要非正常关机时，才需手动执行sync命令</strong>。基本信息如下：</p>
<ul>
<li>命令名称：sync</li>
<li>英文原意：flush file system buffers</li>
<li>所在路径：/bin/sync</li>
<li>执行权限：所有用户</li>
<li>功能描述：刷新文件系统缓冲区</li>
</ul>
<p>命令格式：<code>sync [选项]</code></p>
<h3 id="9-2-shutdown-命令"><a href="#9-2-shutdown-命令" class="headerlink" title="9.2 shutdown 命令"></a>9.2 shutdown 命令</h3><p>shutdown命令用来系统关机。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。基本信息如下：</p>
<ul>
<li>命令名称：shutdown</li>
<li>英文原意：bring the system down</li>
<li>所在路径：/sbin/shutdown</li>
<li>执行权限：超级用户</li>
<li>功能描述：关机和重启</li>
</ul>
<p>命令格式：<code>shutdown [选项] 时间 [警告信息]</code></p>
<ul>
<li><p>选项：</p>
<ul>
<li><code>-c</code>：取消将要执行的shutdown命令</li>
<li><code>-h</code>：系统关机</li>
<li><code>-r</code>：系统重启</li>
</ul>
</li>
<li><p>时间：<code>now</code> 立即执；<code>hh:mm</code> 指定确定时间点执行；<code>+分钟数</code> 延迟指定分钟后执行 </p>
</li>
<li><p>警告信息：执行指令时，同时送出警告信息给登入用户</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#立即关机</span><br><span class="line">[root@localhost ~]# shutdown -h now</span><br><span class="line">#指定5分钟后关机，同时送出警告信息给登入用户：</span><br><span class="line">[root@localhost ~]# shutdown +5 &quot;System will shutdown after 5 minutes&quot;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-reboot-命令"><a href="#9-3-reboot-命令" class="headerlink" title="9.3 reboot 命令"></a>9.3 reboot 命令</h3><p>reboot命令用来重新系统，命令也是安全的，而且不需要过多的选项</p>
<ul>
<li>命令名称：reboot</li>
<li>英文原意：reboot</li>
<li>所在路径：/sbin/reboot</li>
<li>执行权限：超级用户</li>
<li>功能描述：重启系统</li>
</ul>
<p>命令格式：<code>reboot [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有“-n”参数效果；</li>
<li><code>-f</code>：强制重新开机，不调用shutdown指令的功能；</li>
<li><code>-i</code>：在重开机之前，先关闭所有网络界面；</li>
<li><code>-n</code>：重开机之前不检查是否有未结束的程序；</li>
<li><code>-w</code>：仅做测试，并不真正将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件。</li>
</ul>
</li>
</ul>
<h3 id="9-4-halt-和-poweroff-命令"><a href="#9-4-halt-和-poweroff-命令" class="headerlink" title="9.4 halt 和 poweroff 命令"></a>9.4 halt 和 poweroff 命令</h3><p>halt 和 poweroff 这两都是系统关机命令，直接执行即可。但是两个命令不会完整关闭和保存系统的服务，不建议使用。</p>
<h3 id="9-5-init-命令"><a href="#9-5-init-命令" class="headerlink" title="9.5 init 命令"></a>9.5 init 命令</h3><p>init 命令是修改Linux 运行级别的命令，是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。也可以用于关机和重启，这个命令并不安全，不建议使用</p>
<p>命令格式：<code>init [选项] 系统运行级别</code></p>
<ul>
<li>选项：<ul>
<li><code>-b</code>：不执行相关脚本而直接进入单用户模式</li>
<li><code>-s</code>：切换到单用户模式</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关机，也就是调用系统的0级别</span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line">#重启，也就是调用系统的6级别</span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>Linux有7个系统运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为Windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留，没有用到</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<blockquote>
<p><code>runlevel</code> 命令可查看当前系统运行级别</p>
</blockquote>
<h2 id="10-常用网络命令"><a href="#10-常用网络命令" class="headerlink" title="10 常用网络命令"></a>10 常用网络命令</h2><h3 id="10-1-配置IP地址"><a href="#10-1-配置IP地址" class="headerlink" title="10.1 配置IP地址"></a>10.1 配置IP地址</h3><p>IP地址是计算机在互联网中唯一的地址编码，每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的IP地址</p>
<p>IP地址的配置有两种方法：</p>
<ul>
<li><strong>setup 工具</strong></li>
<li><strong>手工修改网卡配置文件</strong><ul>
<li>第一步：编辑网卡文件，<code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code>，”ifcfg-eth0”是第一块网卡，第二块网卡则为”ifcfg-eth1”，以此类推。网卡文件内容配置项如下： <ul>
<li>DEVICE=eth0 #网卡设备名</li>
<li>BOOTPROTO=static  #[none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</li>
<li>HWADDR=00:15:5D:00:46:83 #MAC地址</li>
<li>UUID=5753e2ed-add1-4d1c-8a69-21a89647b050 # 唯一识别码</li>
<li>NM_CONTROLLED=yes  #是否可以由Network Manager图形管理工具托管</li>
<li>ONBOOT=yes  #[yes|no]，是否随网络服务启动，如果配置”no”，使用”ifconfig”命令时看不到该网卡</li>
<li>TYPE=Ethernet # 网络类型</li>
<li>IPADDR=192.168.1.10  #IP地址</li>
<li>NETMASK=255.255.255.0  #子网掩码</li>
<li>NETWORK=192.168.1.0  #网络地址</li>
<li>BROADCAST=192.168.1.255  #广播地址</li>
<li>GATEWAY=192.168.1.1  #网关地址</li>
<li>DNS1=202.109.14.5   #首选DNS服务地址</li>
<li>DNS2=219.141.136.10  #备用DNS服务地址</li>
<li>USERCTL=no  #[yes|no]（非root用户是否可以控制该设备）</li>
</ul>
</li>
<li>第二步：查看DNS服务配置文件，<code>vim /etc/resolv.conf</code>，里面的内容是系统自动生成的，一般不需要修改</li>
<li>第三步：重启网络服务，<code>service network restart</code> 或 <code>/etc/init.d/network restart</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用虚拟机克隆时，UUID可能复制的是一样的，导致网络服务启动失败，需要重置UUID值：<br>第一步：编辑网卡文件，删除UUID和MAC地址<br>第二步: 删除MAC地址和UUID绑定文件，<code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code><br>第三部：重启系统</p>
</blockquote>
<h3 id="10-2-ifconfig-命令"><a href="#10-2-ifconfig-命令" class="headerlink" title="10.2 ifconfig 命令"></a>10.2 ifconfig 命令</h3><p>ifconfig 被用于配置和显示Linux内核中网络接口的网络参数。<strong>用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在</strong>，要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。基本信息如下：</p>
<ul>
<li>命令名称：ifconfig</li>
<li>英文原意：configure a network interface</li>
<li>所在路径：/sbin/ifconfig</li>
<li>执行权限：超级用户</li>
<li>功能描述：配置网络接口</li>
</ul>
<p>命令格式：<code>ifconfig [参数]</code></p>
<ul>
<li>参数：<ul>
<li><code>add 地址</code>：设置网络设备IPv6的ip地址；</li>
<li><code>del 地址</code>：删除网络设备IPv6的IP地址；</li>
<li><code>down</code>：关闭指定的网络设备；</li>
<li><code>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;</code>：设置网络设备的类型与硬件地址；</li>
<li><code>io_addr I/O地址</code>：设置网络设备的I/O地址；</li>
<li><code>irq IRQ地址</code>：设置网络设备的IRQ；</li>
<li><code>media 网络媒介类型</code>：设置网络设备的媒介类型；</li>
<li><code>mem_start 内存地址</code>：设置网络设备在主内存所占用的起始地址；</li>
<li><code>metric 数目</code>：指定在计算数据包的转送次数时，所要加上的数目；</li>
<li><code>mtu 字节</code>：设置网络设备的MTU；</li>
<li><code>netmask 子网掩码</code>：设置网络设备的子网掩码；</li>
<li><code>tunnel 地址</code>：建立IPv4与IPv6之间的隧道通信地址；</li>
<li><code>up</code>：启动指定的网络设备；</li>
<li><code>IP地址</code>：指定网络设备的IP地址；</li>
<li><code>网络设备</code>：指定网络设备的名称。</li>
</ul>
</li>
</ul>
<p>ifconfig 命令最主要的作用就是查看IP地址的信息，直接输入<code>ifconfig</code>命令即可显示激活状态的网络设备信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  </span><br><span class="line">          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)</span><br></pre></td></tr></table></figure>
<p>内容说明：</p>
<ul>
<li><strong>eth0</strong> 表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:16:3E:00:1E:51</li>
<li><strong>inet addr</strong> 用来表示网卡的IP地址，此网卡的IP地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0</li>
<li><strong>lo</strong> 是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回环地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了，但只是本机能看得到，局域网的其它主机或用户无从知道<ul>
<li>第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）</li>
<li>第二行：网卡的IP地址、子网、掩码</li>
<li>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节</li>
<li>第四、五行：接收、发送数据包情况统计</li>
<li>第七行：接收、发送数据字节数统计信息</li>
</ul>
</li>
</ul>
<p>其他示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动和关闭网卡eth0。关闭网卡eth0，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡</span><br><span class="line">[root@localhost ~]# ifconfig eth0 up</span><br><span class="line">[root@localhost ~]# ifconfig eth0 down</span><br><span class="line"></span><br><span class="line">#为网卡eth0配置IPv6地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F;64  </span><br><span class="line"> #为网卡eth0删除IPv6地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F;64 </span><br><span class="line"></span><br><span class="line">#用ifconfig修改MAC地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE</span><br><span class="line">#ifconfig配置IP地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</span><br><span class="line"></span><br><span class="line">#启用和关闭arp协议</span><br><span class="line">[root@localhost ~]# ifconfig eth0 arp   </span><br><span class="line">[root@localhost ~]# ifconfig eth0 -arp</span><br><span class="line"></span><br><span class="line">#设置最大传输单元，这里设置能通过的最大数据包大小为 1500 bytes</span><br><span class="line">[root@localhost ~]# ifconfig eth0 mtu 1500 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-3-ping-命令"><a href="#10-3-ping-命令" class="headerlink" title="10.3 ping 命令"></a>10.3 ping 命令</h3><p>ping 命令是常用的网络命令，主要通过ICMP协议进行网络探测，测试网络中主机的通信情况。基本信息如下：</p>
<ul>
<li>命令名称：ping</li>
<li>英文原意：send ICMP ECHO_REQUEST to network hosts</li>
<li>所在路径：/bin/ping</li>
<li>执行权限：所有用户</li>
<li>功能描述：向网络主机发送ICMP请求</li>
</ul>
<p>命令格式： <code>ping [选项] IP</code></p>
<ul>
<li>选项：<ul>
<li>-b：用于对整个网段进行探测。IP需要为广播地址</li>
<li>-c 次数：设置完成要求回应的次数</li>
<li>-s 字节数：设置数据包的大小</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#探测整个网段中有多少主机是可以和本机通信的，而不是一个一个IP地址地进行探测</span><br><span class="line">[root@localhost ~]# ping -b -c 3 192.168.199.255</span><br><span class="line">WARNING: pinging broadcast address</span><br><span class="line">PING 192.168.199.255 (192.168.199.255) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.199.216: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;77.7 ms</span><br><span class="line">64 bytes from 192.168.199.131: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from 192.168.199.216: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;19.5 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.199.255 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2023ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 19.515&#x2F;66.701&#x2F;102.798&#x2F;34.892 ms</span><br></pre></td></tr></table></figure>

<h3 id="10-4-netstat-命令"><a href="#10-4-netstat-命令" class="headerlink" title="10.4 netstat 命令"></a>10.4 netstat 命令</h3><p>netstat是网络状态查看命令，既可以查看到本机开启的端口，也可以查看哪些客户端连接。在CentOS 7.x中 netstat 命令默认没有安装，如果需要使用，需要先安装 “net-snmp” 和 “net-tools” 软件包。基本信息如下：</p>
<ul>
<li>命令名称：network</li>
<li>英文原意：print network connections, routing tables, interface statistics, masquerade connections, and mulicast memberships</li>
<li>所在路径：/bin/netstat</li>
<li>执行权限：所有用户</li>
<li>功能描述：打印网络连接、路由表、接口统计信息、伪装连接和多播成员身份</li>
</ul>
<p>命令格式：<code>netstat [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：列出所有网络状态，包括Socket程序</li>
<li><code>-c 秒数</code>：制定每隔几秒刷一次网络状态</li>
<li><code>-n</code>：使用IP地址和端口号显示，不使用域名与服务名</li>
<li><code>-p</code>：显示PID和程序</li>
<li><code>-t</code>：显示使用TCP协议端口的连接情况</li>
<li><code>-u</code>：显示使用UDP协议端口的连接情况</li>
<li><code>-l</code>：仅显示监听状态的连接</li>
<li><code>-r</code>：显示路由表</li>
</ul>
</li>
</ul>
<p><strong>示例 1：查看本机开启的端口</strong><br>这是本机最常用的方式，使用”-tuln”选项。因为使用了”-l”选项，所以只能看到监听状态的连接，而不能看到已经建立连接状态的连接，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tuln</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State            </span><br><span class="line">tcp        0      0 0.0.0.0:3306                0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:11211               0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 :::11211                    :::*                        LISTEN</span><br><span class="line">tcp        0      0 :::80                       :::*                        LISTEN</span><br><span class="line">tcp        0      0 :::22                       :::*                        LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:11211               0.0.0.0:* </span><br><span class="line">udp        0      0 :::11211                    :::*  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个命令输出内容较多，下面对每列进行说明：</p>
<ul>
<li><strong>Proto</strong>：网络连接的协议，一般就是 TCP 协议或者 UDP 协议</li>
<li><strong>Recv-Q</strong>：接收队列。表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走</li>
<li><strong>Send-Q</strong>：发送队列。表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备ACK标志的数据包</li>
<li><strong>Local Address</strong>：本机的 IP 地址和端口号。</li>
<li><strong>Foreign Address</strong>：远程主机的 IP 地址和端口号。</li>
<li><strong>State</strong>：状态。常见的状态主要有以下几种：<ul>
<li>LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听</li>
<li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态</li>
<li>SYN_SENT：SYN 发起包，就是主动发起连接的数据包</li>
<li>SYN_RECV：接收到主动连接的数据包</li>
<li>FIN_WAIT1：正在中断的连接</li>
<li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认</li>
<li>TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束</li>
<li>CLOSED：套接字没有被使用</li>
<li>在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种代表已经建立连接</li>
</ul>
</li>
</ul>
<p><strong>示例 2：查看本机有哪些程序开启的端口</strong><br>如果使用“-p”选项，查询结果会多出一列”PID/Program name”，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tulnp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address      Foreign Address     State      PID&#x2F;Program name       </span><br><span class="line">tcp        0      0 0.0.0.0:3306       0.0.0.0:*           LISTEN     2359&#x2F;mysqld</span><br><span class="line">tcp        0      0 0.0.0.0:11211      0.0.0.0:*           LISTEN     1563&#x2F;memcached</span><br><span class="line">tcp        0      0 0.0.0.0:22         0.0.0.0:*           LISTEN     1490&#x2F;sshd</span><br><span class="line">tcp        0      0 :::11211           :::*                LISTEN     1563&#x2F;memcached</span><br><span class="line">tcp        0      0 :::80              :::*                LISTEN     21025&#x2F;httpd</span><br><span class="line">tcp        0      0 :::22              :::*                LISTEN     1490&#x2F;sshd</span><br><span class="line">udp        0      0 0.0.0.0:11211      0.0.0.0:*                      1563&#x2F;memcached</span><br><span class="line">udp        0      0 :::11211           :::*                           1563&#x2F;memcached</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：查看所有连接</strong><br>使用选项“-an”可以查看所有连接，包括监听状态的连接（LISTEN）、已经建立连接状态的<br>连接（ESTABLISHED）、Socket 程序连接等。因为连接较多，所以输出的内容有很多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -an</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State            </span><br><span class="line">tcp        0      0 0.0.0.0:3306                0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:11211               0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 117.79.130.170:80           78.46.174.55:58815          SYN_RECV</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 117.79.130.170:22           124.205.129.99:10379        ESTABLISHED</span><br><span class="line">tcp        0      0 117.79.130.170:22           124.205.129.99:11811        ESTABLISHED</span><br><span class="line">...省略部分内容...</span><br><span class="line">udp        0      0 0.0.0.0:11211               0.0.0.0:* </span><br><span class="line">udp        0      0 :::11211                    :::* </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12668  &#x2F;var&#x2F;run&#x2F;mcelog-client</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12193  @&#x2F;var&#x2F;run&#x2F;hald&#x2F;dbus-ZeYsMXZ7Uf</span><br><span class="line">...省略部分内容...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 “Active UNIX domain sockets” 开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网<br>络服务产生的连接。我们可以在“-an”选项的输出中看到各种网络连接状态，而之前的“-tuln”选项则只能看到监听状态的连接</p>
<h3 id="10-5-write-命令"><a href="#10-5-write-命令" class="headerlink" title="10.5 write 命令"></a>10.5 write 命令</h3><p>write 命令用于向指定登录用户终端上发送信息。通过write命令可传递信息给另一位登入系统的用户，当输入完毕后，键入 “回车” 表示发送，键入 “Ctrl+C” 表示信息结束。如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。基本信息：</p>
<ul>
<li>命令名称：write</li>
<li>英文原意：send a message to another user</li>
<li>所在路径：/usr/bin/write</li>
<li>执行权限：所有用户</li>
<li>功能描述：向其他用户发送消息</li>
</ul>
<p>命令格式 ：<code>write 用户名 [终端编号]</code></p>
<ul>
<li><code>用户名</code>：指定要接受信息的登录用户</li>
<li><code>终端编号</code>：指定接收信息的用户的登录终端，如果省略，且用户在多个终端登录，会发送给其中一个终端</li>
</ul>
<h3 id="10-6-wall-命令"><a href="#10-6-wall-命令" class="headerlink" title="10.6 wall 命令"></a>10.6 wall 命令</h3><p>wall命令用于向系统当前所有打开的终端上输出信息，而 “write” 命令用于给指定用户发送消息。</p>
<p>命令格式：<code>wall 消息</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wall &quot;I will be in 5 minutes to restart, please save your data&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-系统痕迹命令"><a href="#11-系统痕迹命令" class="headerlink" title="11 系统痕迹命令"></a>11 系统痕迹命令</h2><p>系统中有一些重要的痕迹日志文件，如 /var/log/wtmp、 /var/run/utmp、 /var/log/btmp、/var/log/lastlog 等日志文件，如果你用 vim 打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误登录等重要的系统信息。这些信息要是可以通过 vim 打开，就能编辑，这样痕迹信息就不准确，所以这些重要的痕迹日志，只能通过对应的命令来进行查看。</p>
<h3 id="11-1-w-命令"><a href="#11-1-w-命令" class="headerlink" title="11.1 w 命令"></a>11.1 w 命令</h3><p>w 命令是显示系统中正在登录的用户信息的命令，这个命令查看的痕迹日志是 “/var/run/utmp”。基础信息如下：</p>
<ul>
<li>命令名称：w</li>
<li>英文原意：show who is logged on and what they are doing</li>
<li>所在路径：/usr/bin/w</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示登录用户和他们正在做什么</li>
</ul>
<p>命令格式：<code>w [选项] [用户名]</code></p>
<ul>
<li>选项：<ul>
<li><code>-h</code>：不打印头信息；</li>
<li><code>-u</code>：当显示当前进程和cpu时间时忽略用户名；</li>
<li><code>-s</code>：使用短输出格式；</li>
<li><code>-f</code>：显示用户从哪登录；</li>
</ul>
</li>
<li>用户：仅显示指定用户</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 18:31:08 up 1 day, 16 min,  3 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     tty1     -                Sat18   49:23   0.07s  0.07s -bash</span><br><span class="line">root     pts&#x2F;0    192.168.199.119  18:22    8:17   0.02s  0.02s -bash</span><br><span class="line">root     pts&#x2F;1    192.168.199.119  18:22    0.00s  0.03s  0.00s w</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>第一行内容：<ul>
<li>18:31:08：系统当前时间</li>
<li>up 1 day, 16 min：系统的运行时间</li>
<li>3 users：当前登录终端数量</li>
<li>load average: 0.00, 0.00, 0.00：系统在之前1分钟、5分钟、15分钟的平均负载。如果CPU是单核的，则这个数据超过1就是高负载；如果CPU是四核的，则这个数值超过4就是高负载</li>
</ul>
</li>
<li>第二行内容：<ul>
<li>USER：当前登录的用户</li>
<li>TTY：登录的终端。tty1-6: 本地字符终端(alt+F1-6 切换)，tty7: 本地图形终端(ctrl+F7切换，必须安装启动图形界面)，pts/0-255: 远程终端</li>
<li>FROM：登录的IP地址，如果是本地终端，则是空</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户空闲时间  </li>
<li>JCPU：所有的进程占用的CPU时间   </li>
<li>PCPU：当前进程占用的CPU时间 </li>
<li>WHAT：用户正在进行的操作</li>
</ul>
</li>
</ul>
<h3 id="11-2-who-命令"><a href="#11-2-who-命令" class="headerlink" title="11.2 who 命令"></a>11.2 who 命令</h3><p>who 命令和 w 命令类似，用于查看正在登录的用户，但显示的内容更加简单，也是查看 “/var/run/utmp” 日志。</p>
<p>命令格式：<code>who [选项] [查询文件]</code></p>
<ul>
<li>选项：<ul>
<li><code>-H</code>：显示各栏位的标题信息列</li>
<li><code>-q</code>：只显示登入系统的帐号名称和总人数</li>
<li><code>-w</code>：显示用户的信息状态栏</li>
<li><code>-u</code>：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串</li>
</ul>
</li>
<li>查询文件：指定要查询的文件，默认是/var/run/utmp</li>
</ul>
<h3 id="11-3-last-命令"><a href="#11-3-last-命令" class="headerlink" title="11.3 last 命令"></a>11.3 last 命令</h3><p>last 命令查看系统所有登录过的用户信息，包括正在登录的用户和之前登录的用户，这个命令查看的是 “/var/log/wtmp” 痕迹日志文件</p>
<p>命令格式：<code>last [选项] [用户|终端]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：把从何处登入系统的主机名称或ip地址，显示在最后一行</li>
<li><code>-d</code>：将IP地址转换成主机名称</li>
<li><code>-f 记录文件</code>：指定记录文件</li>
<li><code>-n 显示列数</code>或<code>-显示列数</code>：设置列出名单的显示列数</li>
<li><code>-R</code>：不显示登入系统的主机名称或IP地址</li>
<li><code>-x</code>：显示系统关机，重新开机，以及执行等级的改变等信息</li>
</ul>
</li>
<li>用户|终端：显示指定的用户或终端</li>
</ul>
<h3 id="11-4-lastlog-命令"><a href="#11-4-lastlog-命令" class="headerlink" title="11.4 lastlog 命令"></a>11.4 lastlog 命令</h3><p>lastlog 命令是查看系统中所有用户最好一次的登录时间的命令，这个命令查看的是 “/var/log/lastlog” 痕迹日志文件</p>
<p>命令格式：<code>lastlog [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-b 天数</code>：显示指定天数前的登录信息</li>
<li><code>-t 天数</code>：显示指定天数以来的登录信息</li>
<li><code>-u 用户名</code>：显示指定用户的最近登录信息</li>
</ul>
</li>
</ul>
<h3 id="11-5-lostb-命令"><a href="#11-5-lostb-命令" class="headerlink" title="11.5 lostb 命令"></a>11.5 lostb 命令</h3><p>lastb 命令是查看错误登录的信息的，查看的是 “/var/log/btmp” 痕迹日志</p>
<p>命令格式：<code>lostb [选项] [用户|终端]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：把从何处登入系统的主机名称或ip地址显示在最后一行</li>
<li><code>-d</code>：将IP地址转换成主机名称</li>
<li><code>-f 记录文件</code>：指定记录文件</li>
<li><code>-n 显示列数</code>或<code>-显示列数</code>：设置列出名单的显示列数</li>
<li><code>-R</code>：不显示登入系统的主机名称或IP地址</li>
<li><code>-x</code>：显示系统关机，重新开机，以及执行等级的改变等信息</li>
</ul>
</li>
<li>用户|终端：显示指定的用户或终端</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分区与挂载</title>
    <url>/20200207/linux1/9694dab2a110.html</url>
    <content><![CDATA[<h2 id="1-Linux版本"><a href="#1-Linux版本" class="headerlink" title="1.Linux版本"></a>1.Linux版本</h2><p>Linux分为<strong>内核版</strong>和<strong>发行版</strong>，Linux内核其实就是一个操作系统最底层的核心及其提供的核心工具，仅有内核而没有应用软件的操作系统是无法使用的，为了让使用者能够接触到Linux，于是很多的商业公司或非营利团体，就将 Linux Kernel(含 tools)与可运行的软件整合起来，加上自己具有创意的工具程序，这个工具程序可以让用户以光盘/DVD 或者透过网络直接安装/管理 Linux 系统，这个『Kernel + Softwares + Tools + 可完全安装程序』的咚咚，我们称之为Linux发行版。</p>
<a id="more"></a>

<p>Linux发行版本根据软件包管理方式大致可以分为两类，<strong>RPM方式管理软件的系统</strong>(RedHat系列：RedHat、CentOS、OpenSuSe等)，<strong>DPKG方式管理软件的系统</strong>(Debian系列：Debian、Ubuntu等)</p>
<h2 id="2-Linux分区与挂载"><a href="#2-Linux分区与挂载" class="headerlink" title="2.Linux分区与挂载"></a>2.Linux分区与挂载</h2><p>用于学习或者实验的话，一般采用虚拟机安装Linux操作系统即可，比较常用的虚拟机软件有VMware、VirtualBox，如果你的电脑是win10系统的话可以直接使用系统自带虚拟机软件Hyper-v，具体使用和安装过程这里不再详述可以自行参照网上教程，这里主要说一下Linux的分区与挂载。</p>
<h3 id="2-1-分区方式"><a href="#2-1-分区方式" class="headerlink" title="2.1 分区方式"></a>2.1 分区方式</h3><p>常见的两种分区表现形式，<br><strong>MBR分区表</strong>：最大支持2.1T硬盘，最多支持4个分区，支持32位和64位系统；<br><strong>GPT分区表</strong>(全局唯一标示分区表)：支持9.4ZB(1ZB=1024PB, 1PB=1024EB, 1EB=1024TB)，理论上支持的分区数没有限制(但windows限制128个主分区)，只支持64位系统。<br>虽然GPT是一个较新的分区机制，解决了MBR很多缺点，但是目前使用最多的还是MBR分区方式。MBR最多有4个分区，分区类型有三种：</p>
<ul>
<li><strong>主分区</strong></li>
<li><strong>扩展分区</strong><ul>
<li>最多有一个</li>
<li>扩展分区+主分区数最多不超过4个</li>
<li>不能写入数据，不能格式化，只能用来包含逻辑分区</li>
</ul>
</li>
<li><strong>逻辑分区</strong><ul>
<li>包含在扩展分区内，可以有多个</li>
<li>扩展分区至少要包含一个逻辑分区</li>
</ul>
</li>
</ul>
<h3 id="2-2-设备挂载"><a href="#2-2-设备挂载" class="headerlink" title="2.2 设备挂载"></a>2.2 设备挂载</h3><p>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，windows是通过设备管理器来管理硬件的，linux的设备文件保存在<code>/dev/</code>目录中，比如硬盘文件是<code>/dev/sd[a-p]</code>，光盘文件是<code>/dev/hdc</code>等，硬件设备需要挂载到相应的目录文件才能使用。</p>
<p>所谓的<strong>挂载</strong>就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区的意思，这个动作我们称为<strong>挂载</strong>，那个进入点的目录我们称为<strong>挂载点</strong>。 由于整个 Linux 系统最重要的是根目录(<code>/</code>)，因此根目录一定需要挂载到某个分区， 至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。</p>
<p>常见的硬件设备文件名如下：</p>
<table>
<thead>
<tr>
<th>硬件</th>
<th>设备名称</th>
</tr>
</thead>
<tbody><tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom或/dev/sr0</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[01-1]</td>
</tr>
<tr>
<td>打印机(25针)</td>
<td>/dev/lp[0-2]</td>
</tr>
<tr>
<td>打印机(USB)</td>
<td>/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
</tbody></table>
<p>图示说明：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux001.png?x-oss-process=style/watermarking" alt="linux设备挂载示意图"></p>
<p>上图所示，硬盘被分为三个可用分区，其中sda1、sda2为主分区分别挂载在/boot和 / 目录下，sda3为扩展分区内部包含一个逻辑分区sda5，sda5挂载在/home目录下。/boot目录下的所有数据存储在sda1分区里，/home目录下的所有数据存储在sda5分区里，根目录 / (除了/boot、/home)下的数据都存储在sda2分区里。</p>
<blockquote>
<p>1.sda1表示第一块硬盘第一个分区，sda2表示第一块硬盘第二个分区，sdb1表示第二块硬盘一个分区，以此类推…<br>2.逻辑分区一定是从sda5开始，因为sda1、sda2、sda3和sda4文件名被主分区或扩展分区占用</p>
</blockquote>
<p>Linux系统安装时，一般分区如下：</p>
<ul>
<li>必须分区<ul>
<li>/ （根分区）</li>
<li>swap （交换分区）<ul>
<li>如果真实内存小于4GB, swap为内存的两倍</li>
<li>如果真实内存大于4GB, swap和内存一致</li>
<li>实验环境，不大于2GB即可</li>
</ul>
</li>
</ul>
</li>
<li>推荐分区<ul>
<li>/boot (启动分区，一般1GB，仅存放系统启动所需的数据)</li>
</ul>
</li>
<li>常用分区<ul>
<li>/home (用于文件服务器)</li>
<li>/www (用于web服务器)<blockquote>
<p>swap分区的文件系统类型式为swap，其余分区文件系统类型一般为ext4。一般系统安装存在 /、swap、/boot三个分区即可</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-挂载命令"><a href="#2-3-挂载命令" class="headerlink" title="2.3 挂载命令"></a>2.3 挂载命令</h3><ol>
<li><strong>mount</strong> 或 <strong>mount -l</strong><ul>
<li>查询系统中已挂载的设备，-l会显示卷标名称</li>
</ul>
</li>
<li><strong>mount -a</strong><ul>
<li>依据配置文件/etc/fstab的内容，自动挂载</li>
</ul>
</li>
<li><strong>mount [-t 文件系统类型] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</strong><ul>
<li>手动挂载</li>
<li>选项<ul>
<li>-t 文件系统：加入文件系统类型来指定挂载的类型，可以是ext3、ext4、iso9660等文件系统 </li>
<li>-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</li>
<li>-o 特殊选项: 可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。具体的特殊选项见下表</li>
</ul>
</li>
</ul>
</li>
<li><strong>umount 设备文件名</strong> 或 <strong>umount 挂载点</strong><ul>
<li>卸载已挂载设备</li>
<li>因为设备文件名和挂载点已经连接到一起，所以卸载哪一个都可以</li>
</ul>
</li>
</ol>
<blockquote>
<p>补充（挂载特殊选项参数说明）：<br>| 特殊选项 | 说明 |<br>| — | — |<br>|atime/noatime | 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新|<br>|async/sync | 异步/同步，默认为异步|<br>|auto/noauto | 自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动|<br>|defaults|定义默认值，相当于 rw,suid,dev,exec,auto,nouser,async这七个选项|<br>|exec/noexec | 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec允许|<br>|remount | 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限。示例：<code>mount -o remount,noexec /boot</code> 重新挂载/boot分区并使用noexec权限|<br>|rw/ro|读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw|<br>|suid/nosuid | 具有/不具有 SUID权限，设定文件系统是否具有 SUID和 SGID的权限，默认是具有|<br>|user/nouser | 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认不允许，只有root可以挂载分区|<br>|usrquota | 写入代表文件系统支持用户磁盘配额，默认不支持|<br>|grpquota | 写入代表文件系统支持组磁盘配额，默认不支持 |</p>
</blockquote>
<h3 id="2-4-LVM逻辑卷管理"><a href="#2-4-LVM逻辑卷管理" class="headerlink" title="2.4 LVM逻辑卷管理"></a>2.4 LVM逻辑卷管理</h3><h4 id="2-4-1-LVM简介"><a href="#2-4-1-LVM简介" class="headerlink" title="2.4.1 LVM简介"></a>2.4.1 LVM简介</h4><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。传统分区使用固定大小分区，重新调整大小十分麻烦。LVM将一个或多个硬盘的分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘的分区加入其中，这样可以实现磁盘空间的动态管理，相对于传统的磁盘分区有很大的灵活性。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux002.png?x-oss-process=style/watermarking" alt="LVM示意图"></p>
<ul>
<li>**物理卷(PV, Physical Volume)**：就是真正的物理硬盘或分区</li>
<li>**卷组(VG, Volume Group)**：将多个物理卷合起来就组成卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘的不同分区，可以把物理卷想象为一个逻辑硬盘。</li>
<li>**逻辑卷(LV, Logival Volume)**：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区我们称作逻辑卷，逻辑卷可以格式化和写入数据。</li>
</ul>
<h4 id="2-4-2-建立LVM步骤"><a href="#2-4-2-建立LVM步骤" class="headerlink" title="2.4.2 建立LVM步骤"></a>2.4.2 建立LVM步骤</h4><ol>
<li>使用<code>fdisk</code>交互命令把物理硬盘分成分区，当然也可以是整块硬盘。</li>
<li>把物理分区建立成为物理卷(PV)，也可以把整块硬盘都建立为物理卷。<ul>
<li>建立物理卷：<code>pvcreate [设备文件名]</code><ul>
<li>把整块硬盘都建立成物理卷，命令为<code>pvcreate /dev/sdb</code>，即第二块硬盘整个都建立成物理卷；把分区建立成物理卷，命令为<code>pvcreate /dev/sdb5</code>，即第二块硬盘第五个分区建立成物理卷</li>
</ul>
</li>
<li>查看物理卷：<code>pvscan</code> 或 <code>pvdisplay</code>(查看更加详细的物理卷状态)</li>
<li>删除物理卷：<code>pvremove [物理卷名(建立物理卷时的设备文件名)]</code></li>
</ul>
</li>
<li>把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。<ul>
<li>建立卷组：<code>vgcreate [选项] 卷组名 物理卷名(多个空格隔开)</code><ul>
<li>选项 ‘<code>-s PE大小</code>‘:指定PE(保存数据的最小单元)的大小，单位可以是MB、GB、TB等，如果不写默认PE大小是4MB。</li>
<li>示例：<code>vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</code>， 把物理卷/dev/sdb5、/dev/sdb6加入卷组scvg</li>
</ul>
</li>
<li>查看卷组：<code>vgscan</code> 或 <code>vgdisplay</code></li>
<li>扩充卷组容量：<code>vgextend 卷组名 物理卷名</code></li>
<li>减小卷组容量：<code>vgreduce 卷组名 物理卷名</code></li>
<li>删除卷组：<code>vgremove 卷组名</code><ul>
<li>卷组如果已经添加了逻辑卷，要先删除逻辑卷才能删除卷组，卷组删除后才能删除物理卷</li>
</ul>
</li>
</ul>
</li>
<li>把卷组再划分为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成分区，所以也需要格式化和挂载。</li>
</ol>
<ul>
<li>建立逻辑卷：<code>lvcreate [选项] [-n 逻辑卷名] 卷组名</code></li>
<li>选项<ul>
<li><code>-L 容量</code>：指定逻辑卷大小，单位MB、GB、TB</li>
<li><code>-l 个数</code>：按照PE个数指定逻辑卷大小，这个参数需要换算容量</li>
<li><code>-n 逻辑卷名</code>：指定逻辑卷名</li>
</ul>
</li>
<li>示例：<code>lvcreate -L 2GB -n userlv scvg</code>，在卷组scvg中建立一个容量2GB名称为userlv的逻辑卷</li>
<li>建立完逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。格式化和挂载命令和操作普通分区时一样，不过需要注意的是逻辑卷的设备文件名是“**/dev/卷组名/逻辑卷名**”，比如示例这里建立的逻辑卷设备文件名是<code>/dev/scvg/userlv</code><ul>
<li>格式化逻辑卷：<code>mkfs -t ext4 /dev/scvg/userlv</code></li>
<li>创建挂载目录：<code>mkdir /disklvm</code></li>
<li>挂载逻辑卷：<code>mount /dev/scvg/userlv /disklvm/</code></li>
</ul>
</li>
</ul>
<h2 id="3-目录结及说明"><a href="#3-目录结及说明" class="headerlink" title="3.目录结及说明"></a>3.目录结及说明</h2><p>Linux目录结构及说明如下</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>bin是Binary的缩写, 这个目录存放着最经常使用的命令</td>
</tr>
<tr>
<td>/sbin/</td>
<td>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>系统用户使用的应用程序</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>超级用户使用的比较高级的管理程序和系统守护程序</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存于系统启动相关的文件，如内核文件和启动引导程序（grup）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td>
</tr>
<tr>
<td>/lib/</td>
<td>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</td>
</tr>
<tr>
<td>/lib64/</td>
<td>64位函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期Linux只有这一个挂载目录，并没有细分，现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘等。虽然有三个默认的挂载目录/media/、/misc/、/mnt/，但是到底使用哪个目录挂载什么设备都可以由管理员自己决定。一般习惯挂载目录只用一个/mnt/, 在/mnt/目录下建立不同的目录挂载不同的设备，如/mnt/cdrom挂载光盘、/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。一般习惯把软件放到/usr/local/目录中，也就是说/usr/local/目录也可以用来安装软件</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。改目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net 是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/root/</td>
<td>root用户的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在 / 下</td>
</tr>
<tr>
<td>/run/</td>
<td>系统运行时产生的数据，如ssid, pid等相关数据。</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放历史文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录不要保存重要数据，最好每次开机把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是”UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。手工下载的源码包和内核源码包都可以保存到这里。一般习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中</td>
</tr>
<tr>
<td>/usr/src/kernels/</td>
<td>内核源码保存位置</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。只要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
<tr>
<td>/var/www/html/</td>
<td>RPM包安装Apache的网页主目录</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用和改变的数据保存位置。如mysql的数据库保存在/var/lib/mysql/目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>系统日志保存位置</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的PID(进程ID)保存位置。是/run/目录的软链接</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列</td>
</tr>
<tr>
<td>/var/spool/mail/</td>
<td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>系统的定时任务队列保存位置。系统的计划任务会保存在这里</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分区</tag>
        <tag>挂载</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL报only_full_group_by错误</title>
    <url>/20190824/informal001/5ed6d48e6e64.html</url>
    <content><![CDATA[<p>之前执行正常的一条分组sql语句，今天在本地执行时突然报错了，报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column list which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by</span><br></pre></td></tr></table></figure>

<p>网上搜索了一番很快就找到了答案，就顺便做一下记录。原来是和 mysql 的版本有关，</p>
<p>在把MySQL升级到5.7或者更高的版本，一些以前看上去不会出错的group by 操作在这个版本以后就会出现语法报错的情况：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[Err] <span class="number">1055</span> - Expression #<span class="number">1</span> of ORDER BY clause <span class="keyword">is</span> not <span class="keyword">in</span> GROUP BY clause and contains nonaggregated column list which <span class="keyword">is</span> not functionally dependent <span class="keyword">on</span> columns <span class="keyword">in</span> GROUP BY clause; <span class="keyword">this</span> <span class="keyword">is</span> incompatible <span class="keyword">with</span> sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure>

<p>在这个模式下，我们使用分组查询时，出现在select字段后面的只能是group by后面的分组字段，或使用聚合函数包裹着的字段。</p>
<p>网上一般的解决方式就是关掉这个模式，即：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="meta">@GLOBAL</span>.sql_mode=’’;</span><br><span class="line"><span class="keyword">set</span> sql_mode =‘STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’;</span><br></pre></td></tr></table></figure>

<p>或者改my.ini 配置（如果Mysql 没有这个文件，就把my-default.ini 改成my.ini）<br> 在 [mysqld]和[mysql]下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql_mode &#x3D;‘STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’;</span><br></pre></td></tr></table></figure>

<p>看上去这种模式的出现完全是画蛇添足。事实上MySQL更新这种模式不是没有意义的：对于语义限制都比较严谨的多家数据库，如SQLServer、Oracled等数据库都不支持select target list中出现语义不明确的列，这样的语句在这些数据库中是会被报错的，所以从MySQL 5.7版本开始修正了这个语义，就是所说的ONLY_FULL_GROUP_BY语义。<br> 在我遇到这种报错的情况中，最多的就是分组求最值，例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,ename,max(sal) <span class="keyword">from</span> e <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

<p>求各部门最高的工资，其中：id:部门,ename:名字,sal:工资。<br> 或者是这种投机的表示方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,ename,sal <span class="keyword">from</span></span><br><span class="line">   ( <span class="keyword">select</span> * <span class="keyword">from</span> e order <span class="keyword">by</span> sal desc ) t <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

<p>而之后的版本不再支持了，原因个人认为是消除了子查询的排序作用。而且官方也支持这个判断：（<a href="https://links.jianshu.com/go?to=https://bugs.mysql.com/bug.php?id=80131">https://bugs.mysql.com/bug.php?id=80131</a>）<br> 如果在不关闭only_full_group_by模式的条件下，是否有速度类似同时又符合规则的办法呢？<br> 答案是存在的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id ,ename,sal <span class="keyword">from</span></span><br><span class="line">           e, (<span class="keyword">select</span> id ,max(sal) <span class="keyword">as</span> maxsal <span class="keyword">from</span> e <span class="keyword">group</span> <span class="keyword">by</span> id ) <span class="keyword">as</span> t  </span><br><span class="line">           <span class="keyword">where</span> e.id = t.id <span class="keyword">and</span> e.sal = t.maxsal;</span><br></pre></td></tr></table></figure>

<p>不需要用到构造两表联查，性能也很好。</p>
<p>作者：Vivus<br>链接：<a href="https://www.jianshu.com/p/7f532985ff39">https://www.jianshu.com/p/7f532985ff39</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件之ActiveMQ入门</title>
    <url>/20190816/post/191434a07b67.html</url>
    <content><![CDATA[<h1 id="1-JMS与消息中间件"><a href="#1-JMS与消息中间件" class="headerlink" title="1. JMS与消息中间件"></a>1. JMS与消息中间件</h1><h2 id="1-1-jms介绍"><a href="#1-1-jms介绍" class="headerlink" title="1.1 jms介绍"></a>1.1 jms介绍</h2><p>jms是java消息服务接口规范，主要包含四大元素：<strong>生产者</strong>、<strong>消费者</strong>、<strong>消息</strong>、<strong>消息服务</strong>。  </p>
<ul>
<li><p>生产者：创建消息，并把消息发动到消息服务；  </p>
</li>
<li><p>消费者：从消息服务接收消息；</p>
</li>
<li><p>消息服务：即MQ消息服务（broker），而生产者与消费者相对其均为客服端；</p>
</li>
<li><p>消息：整个消息服务的传输对象，消息包含消息头、消息属性、消息体；</p>
<a id="more"></a>

</li>
</ul>
<blockquote>
<p><strong>常用消息头属性</strong>：JMSDestination(消息目的地，如果生产者指定了目的地，在发送时会改为生产者绑定的目的地)、JMSDeliveryMode(是持久还是非持久)、JMSExpiration(过期时间，默认永久)、JMSPriority(优先级，0-9，数值越大优先级越高，默认为4)、JMSMessageId(唯一的消息ID)；<br><strong>消息属性</strong>：可视为消息头属性的扩展，通过setXxxProperty(k,v)设置；<br><strong>消息体</strong>：封装消息的具体数据，发送与接收的消息体类型必须一致，消息体类型总共有5种，TextMessage、Mapmessage、BytesMessage、StreamMessage、ObjectMessage；</p>
</blockquote>
<h2 id="1-2-jms消息传递模式"><a href="#1-2-jms消息传递模式" class="headerlink" title="1.2 jms消息传递模式"></a>1.2 jms消息传递模式</h2><p>jms消息传递模式有如下两种，<br><strong>点对点消息传递模式（P2P）</strong>：消息发送到一个特殊队列(queue), 消费者从队列获取消息，一条消息只能被只能被一个消费者消费；<br>**发布/订阅消息传递模式(publish-subscribe)**：消息被发送到一个主题上(topic)，所有订阅了该主题的消费者，都能接收到消息。</p>
<h2 id="1-3-jms编码总体架构"><a href="#1-3-jms编码总体架构" class="headerlink" title="1.3 jms编码总体架构"></a>1.3 jms编码总体架构</h2><p>JMS应用程序由如下基本模块组成，</p>
<ol>
<li>连接工厂对象，创建消息客户端(生产者、消费者)与消息服务端的连接(connection)；</li>
<li>连接对象，创建回话对象(session);</li>
<li>会话对象，创建生产者对象(producer)、消费者对象(consumer)以及消息对象(message)；</li>
<li>目的地(queue/topic)，点对点模式下目的地是队列(queue)，发布/订阅模式下目的地是主题(topic)，生产者把消息发送到目的地，消费者从目的地接收消息</li>
</ol>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq1.png?x-oss-process=style/watermarking"></p>
<h2 id="1-4-消息中间件"><a href="#1-4-消息中间件" class="headerlink" title="1.4 消息中间件"></a>1.4 消息中间件</h2><p>  消息中间件是实现了jms规范的落地产品，目前市场上主流的消息中间件有 ActiveMQ、Kafka、RocketMQ、RabbitMQ等。企业开发中使用消息中间件的主要目的是<strong>解决耦合调用</strong>、**抵御洪峰流量(削峰)**等。 以下主要讲解ActiveMQ的使用。</p>
<h1 id="2-ActiveMQ安装并启动"><a href="#2-ActiveMQ安装并启动" class="headerlink" title="2. ActiveMQ安装并启动"></a>2. ActiveMQ安装并启动</h1><p>具体安装步骤这里不再详述，可参考官网[<a href="http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行">http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行</a> <code>./activemq start</code>命令，即可启动MQ服务，如果启动服务需要指定配置文件，命令为 <code>./activemq start xbean:file:../conf/myConfig.xml</code>，不指定默认为conf目录下的activemq.xml。停止MQ服务的命令为 <code>./activemq stop</code>。</p>
<p>在conf目录下找到<code>activemq.xml</code>配置文件打开，里面包含如下内容,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里配置的是MQ服务的各种传输协议连接和默认端口。再往下会发现这行内容<code>&lt;import resource=&quot;jetty.xml&quot;/&gt;</code>，activemq.xml文件中导入了一个名为<code>jetty.xml</code>的配置文件，在conf目录下找到jetty.xml文件打开，里面配置了访问MQ服务web控制台的一些信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jettyPort&quot; class&#x3D;&quot;org.apache.activemq.web.WebConsolePort&quot; init-method&#x3D;&quot;start&quot;&gt;</span><br><span class="line">    &lt;!-- the default port number for the web console --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;0.0.0.0&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;8161&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>其中8161为web控制台端口，MQ服务启动后，浏览器中访问[<a href="http://localhost:8161/admin][3]%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%83%BD%E4%B8%BAadmin%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C">http://localhost:8161/admin][3]，输入用户名和密码，默认都为admin，即可看到如下页面，</a></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq2.png?x-oss-process=style/watermarking"></p>
<h1 id="3-编码实战"><a href="#3-编码实战" class="headerlink" title="3. 编码实战"></a>3. 编码实战</h1><p>ActiveMQ服务启动成功后，可以编写生产者客户端往MQ服务发送消息，消费者客户端从MQ服务获取消息。项目建好之后需要先引入ActiveMQ相关依赖，以gradle为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &#39;org.apache.activemq&#39;, name: &#39;activemq-all&#39;, version: &#39;5.15.9&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-点对点消息"><a href="#3-1-点对点消息" class="headerlink" title="3.1 点对点消息"></a>3.1 点对点消息</h2><h3 id="3-1-1-生产者"><a href="#3-1-1-生产者" class="headerlink" title="3.1.1 生产者"></a>3.1.1 生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂。这里传入ActiveMQ消息服务连接地址，并使用默认用户名和密码。</span></span><br><span class="line">        <span class="comment">// 也可使用ActiveMQConnectionFactory()构造器或者ActiveMQConnectionFactory(String userName, String password, String brokerURL)构造器，连接接信息全部使用默认值或者全部指定</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        <span class="comment">//2、通过工厂对象创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">//3、通过连接对象创建会话。第一个参数是否开启事务，第二参数指定签收类型</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4、通过会话对象创建目的地（队列或者主题）。这里创建了一个名为 &quot;queue001&quot; 的队列</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        <span class="comment">//5、通过会话对象创建生产者，并指定目的地</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line">        <span class="comment">//6、连续创建3条消息，并有生产者发送到消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">            System.out.println(textMessage.getJMSDestination());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息&quot;</span> + textMessage.getText() + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main()方法后，进入web控制台可以看到待消费消息有3条，入队消息有3条，说明消息已经成功发送至MQ服务器。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq3.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-2-消费者"><a href="#3-1-2-消费者" class="headerlink" title="3.1.2 消费者"></a>3.1.2 消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line">        connection.start();</span><br><span class="line">        Message message = consumer.receive();</span><br><span class="line">        <span class="keyword">while</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String text = ((TextMessage) message).getText();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            message = consumer.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者客户端编码过程与生产者基本一致，只不过一个是生产者发送调用<code>send()</code>方法，一个是消费者接收调用<code>receive()</code>方法。其中需要注意的是<code>receive()</code>方法是一个阻塞方法，接收不到消息会一直阻塞等待，并且调用<code>receive()</code>之前必须调用<code>connection.start()</code>启动连接，否者接收不到消息。<br>执行main()方法后，进入web控制台可以看到待消费消息变为0条，出队消息变为3条，并且有一个消费者，说明消息被消费成功。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq4.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-3-消息监听器实现异步非阻塞消费消息"><a href="#3-1-3-消息监听器实现异步非阻塞消费消息" class="headerlink" title="3.1.3 消息监听器实现异步非阻塞消费消息"></a>3.1.3 消息监听器实现异步非阻塞消费消息</h3><p>上面我们了解到<code>MessageConsumer#receive()</code>方法是个阻塞方法，实际开发中不可能一直去阻塞等待，可以为消费者对象设置消息监听器来实现异步非阻塞消费消息，修改消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line"><span class="comment">//        connection.start();</span></span><br><span class="line"><span class="comment">//        Message message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        while (message != null) &#123;</span></span><br><span class="line"><span class="comment">//            String text = ((TextMessage) message).getText();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;接收queue消息：&quot; + text);</span></span><br><span class="line"><span class="comment">//            message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line">        consumer.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String text = ((TextMessage) message).getText();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep为了使程序不退出</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMessageListener()</code>方法需要传入一个<code>MessageListener</code>实例对象，并实现<code>onMessage()</code>，这里使用的是lambda表达式。</p>
<h2 id="3-2-发布-订阅消息"><a href="#3-2-发布-订阅消息" class="headerlink" title="3.2 发布/订阅消息"></a>3.2 发布/订阅消息</h2><p>发布订阅消息与上面点对点消息的生产者与消费者编码一致，唯一要改变的是把消息目的地由queue改为topic。</p>
<ul>
<li>生产者<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME); </span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure></li>
<li>消费者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic &#x3D; session.createTopic(TOPIC_NAME);</span><br><span class="line">MessageConsumer consumer &#x3D; session.createConsumer(topic);</span><br><span class="line">...省略... </span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>1.在点对点消息示例中，当同时启动多个消费者时(即同时执行多次main()方法)，生产者发布的每条消息只能被其中一个消费者消费一次；<br>2.在发布/订阅消息示例中，消费者不能消费订阅主题之前的消息，当同时启动多个消费者时，生产者发布的每条消息可以同时被多个消费者消费；</p>
</blockquote>
<h1 id="4-传输协议"><a href="#4-传输协议" class="headerlink" title="4. 传输协议"></a>4. 传输协议</h1><h2 id="4-1-ActiveMQ默认支持的传输协议"><a href="#4-1-ActiveMQ默认支持的传输协议" class="headerlink" title="4.1 ActiveMQ默认支持的传输协议"></a>4.1 ActiveMQ默认支持的传输协议</h2><p>ActiveMQ出厂默认支持的传输协议有<code>tcp</code>、<code>amqp</code>、<code>stomp</code>、<code>mqtt</code>、<code>ws</code>，在<code>activemq.xml</code>配置文件可以找到这几种协议的配置，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于java开发后四种协议不经常使用，这里主要说一次tcp协议。tcp协议的client监听端口默认是61616，在网络上传输数据，必须序列化数据，消息是通过一个write protocol来序列化为字节流。默认情况 ActiveMQ会把wire protocol叫做Open Wire，它的目的是促使网络上的效率和数据快速交互。<br>tcp传输的优点：</p>
<ol>
<li>传输可靠性高、稳定性强</li>
<li>高效性：字节流方式传递，效率高</li>
<li>有效性、可用性：应用广泛，支持任何平台<br>tcp连接的URL形式如：<strong>tcp://hostname:port?key=value</strong>。更多协议的可配置参数请参考 <a href="http://activemq.apache.org/tcp-transport-reference">http://activemq.apache.org/tcp-transport-reference</a></li>
</ol>
<h2 id="4-2-使用NIO传输协议提供更好的性能"><a href="#4-2-使用NIO传输协议提供更好的性能" class="headerlink" title="4.2 使用NIO传输协议提供更好的性能"></a>4.2 使用NIO传输协议提供更好的性能</h2><p>使用tcp协议，每一个连接都会创建一个线程，当client连接较多时需要大量的系统开销，nio支持多个连接使用同一个线程，相比tcp需要更少的线程数。  </p>
<p>nio协议基于tcp协议之上进行了扩展和优化。要使ActiveMQ支持nio协议，只需要做少量的修改即可。打开<code>activemq.xml</code>配置文件，在<code>&lt;transportConnectors&gt;</code> 节点内添加，<code>&lt;transportConnector name=&quot;nio&quot; uri=&quot;nio://0.0.0.0:61617&quot;/&gt;</code>，同时客户端代码url连接形式要改为 <code>nio://hostname:port?key=value</code>，后面的可选参数与tcp协议一致。  </p>
<blockquote>
<p>tcp协议也好nio协议也好，都绑定了特定的端口，如何实现一个端口可以支持多种协议呢？ActiveMQ提供了一个auto协议，类似于一个适配器协议，在不改变端口的情况下可以切换协议。详细配置参考官方文档 <a href="http://activemq.apache.org/auto">http://activemq.apache.org/auto</a>  </p>
</blockquote>
<p>其他协议配置参见官网文档 <a href="http://activemq.apache.org/configuring-transports.html">http://activemq.apache.org/configuring-transports.html</a></p>
<h1 id="5-ActiveMQ消息高可用"><a href="#5-ActiveMQ消息高可用" class="headerlink" title="5 ActiveMQ消息高可用"></a>5 ActiveMQ消息高可用</h1><h2 id="5-1-消息持久化"><a href="#5-1-消息持久化" class="headerlink" title="5.1 消息持久化"></a>5.1 消息持久化</h2><h3 id="5-1-1-持久化编码"><a href="#5-1-1-持久化编码" class="headerlink" title="5.1.1 持久化编码"></a>5.1.1 持久化编码</h3><p>如果生产者把消息发送到了MQ消息服务，消费者还没有来得及消费，此时MQ服务停止或意外宕机，那么这些未被消费的消息改怎么处理呢？分为消息非持久化和消息持久化两种情况，<strong>消息非持久化</strong>这些未被处理的消息直接丢失，<strong>消息持久化</strong>会把这些未被消费的消息暂时存储起来，当MQ消息服务重新启动时恢复这些消息，消费者可以继续消费。</p>
<ul>
<li><strong>队列消息持久化</strong><br>基于上面的示例代码，只需要为生产者客户端代码添加一行通过MessageProducer对象设置就可以了。（队列消息默认开启持久化这一行实际上可以省略）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li>
<li><strong>主题消息持久化</strong><br>主题消息默认不持久化，支持主题消息持久化，只需要修改消费者客户端代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> ...</span><br><span class="line">connection.setClientID(<span class="string">&quot;client_0001&quot;</span>);</span><br><span class="line"> ...</span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">TopicSubscriber subscriber =  session.createDurableSubscriber(topic, <span class="string">&quot;remark...&quot;</span>);</span><br><span class="line">connection.start();</span><br><span class="line">subscriber.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先必须要通过<code>connection.setClientID(&quot;client_0001&quot;)</code>指定订阅者ID，因为如果不指定唯一ID,订阅者（非持久化订阅者）每次连接时都会随机创建一个ID，在消息持久化状态下，订阅者需要保证从离线到重新在线ClientID唯一不变，这样MQ消息服务才能确定主题消息是否被所有持久化订阅者消费了（如果MQ服务停止或宕机时，主题消息未被所有持久化订阅者消费的会被存储起来，已经被所有持久化订阅者消费的主题消息会直接丢弃）。  </p>
<p>然后通过<code>session.createDurableSubscriber(topic, &quot;remark...&quot;)</code>创建一个TopicSubscriber对象，告诉MQ服务其订阅的此主题消息要做持久化处理。</p>
<h3 id="5-1-2-持久化存储机制"><a href="#5-1-2-持久化存储机制" class="headerlink" title="5.1.2 持久化存储机制"></a>5.1.2 持久化存储机制</h3><p>ActiveMQ的消息持久化机制有JDBC、AMQ、KahaDB和LevelDB，无论使用哪种持久化方式，消息的存储逻辑都是一致的，就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等再试图将消息发送给接受者，成功则将消息从存储中删除，失败则继续尝试发送。MQ消息服务启动以后首先要检查指定的存储位置，如果有未发送成功的消息则需要把消息继续发送出去。下面分别介绍一下KahaDB与JDBC持久化机制。</p>
<ul>
<li><strong>KahaDB存储</strong><br>KahaDB是一个基于文件的持久性数据库，消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。KahaDB是目前默认的存储方式，可用于任何场景，提高了性能和恢复能力。在<code>activemq.xml</code>配置文件可查看其配置信息，更多的配置信息可参见官网 <a href="http://activemq.apache.org/kahadb">http://activemq.apache.org/kahadb</a></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>directory</code>这里指明了kahadb数据存储路径，默认为ActiveMQ安装目录下<code>/data/kahadb</code>，其中主要包含4类文件和一个lock：</p>
<ol>
<li><strong>db-<number>.log</strong>：kahaDB存储消息到预定大小（默认32M）的数据记录文件中，文件命名为db-<number>.log，当数据文件已满时，一个新的文件会随之创建，number数值也会随之递增，当不再有引用到数据文件中的消息时，文件会被删除或者归档；</li>
<li><strong>db.data</strong>：改文件包含了持久化的BTree索引，它是消息的索引文件，使用BTree作为索引指向db-<nubmer>.log里面存储的消息；</li>
<li><strong>db.free</strong>：记录当前db.data文件里哪些页面是空闲的，文件具体内容是所有空闲页的ID;</li>
<li><strong>db.redo</strong>：用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引；</li>
<li><strong>lock</strong>：文件锁，表示当前获得kahaDB读写权限的broker；  </li>
</ol>
<ul>
<li><strong>JDBC存储</strong><br>如果采用JDBC机制存储，需要准备一个第三方数据库，这里以MySql数据库为例，更多信息参考<a href="http://activemq.apache.org/jdbc-support">http://activemq.apache.org/jdbc-support</a></li>
</ul>
<p>1.首先将mysql数据库的驱动包<code>mysql-connector-java-5.1.41.jar</code>添加到<code>ActiveMQ安装目录/lib</code>目录下，用于连接mysql数据库；</p>
<p>2.打开<code>activemq.xml</code>配置文件，找到<code>&lt;beans&gt;</code>节点添加数据库连接池配置信息<code>dataSource</code> bean，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysql-ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>3.<code>activemq.xml</code>配置文件中找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span> <span class="attr">createTablesOnStartup</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>mysql-ds</code>为上一步配置的beanId，<code>createTablesOnStartup</code>是否在启动的时候自动创建数据表，默认值是true，一般是第一次启动的时候设置为true之后再改为false。</p>
<p>上诉三步都配置完后，启动ActiveMQ服务会自动创建三张表，分别为<code>activemq_msgs</code>消息表，用于保存queue和topic消息， <code>activemq_acks</code>用于存储订阅关系，如果是持久化topic，订阅者和服务器的订阅关系在这个表保存，<code>activemq_lock</code>在集群环境中才有用，保证只有一个borker可以获取消息，用于记录哪个breker是当前的master broker。</p>
<p>JDBC每次消息过来都需要去写库和读库，ActiveMQ Journal使用高速缓存写入技术大大提高了性能，克服了JDBC Store的不足。当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息，比如生产者生产了1000条消息，这1000条消息会先保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的消息，那么这个时候只需要同步剩余的10%的消息到DB。</p>
<p>使用高效的Journal，需要修改持久化配置，打开<code>activemq.xml</code>配置文件，找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">journalPersistenceAdapterFactory</span> <span class="attr">journalLogFiles</span>=<span class="string">&quot;5&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;activemq-data&quot;</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceFactory</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h2 id="5-2-事务"><a href="#5-2-事务" class="headerlink" title="5.2 事务"></a>5.2 事务</h2><p>在上面的示例代码中，创建session时传了两个参数，<code>createSession(false, Session.AUTO_ACKNOWLEDGE)</code>，第一个参数表示<strong>是否开启事务</strong>，第二个参数表示<strong>签收方式</strong>。</p>
<p>当开启事务，即第一个参数为<code>true</code>时，对于生产者而言执行<code>send()</code>方法后，消息不会直接进入消息队列中（没有真正发送到MQ服务），只有执行<code>session.commit()</code>消息才会真正发送成功进入消息队列中；对于消费者而言，消费完消息后，只有执行了<code>session.commit()</code>消息才会从消息队列中出队，如果不执行<code>session.commit()</code>会导致消息被重复消费。</p>
<p>事务开启的意义在于，对于多条必须同批次传输的消息，如果有一条传输失败，可以将事务回滚，再次传输，保证数据的完整性。</p>
<h2 id="5-3-签收（ack）"><a href="#5-3-签收（ack）" class="headerlink" title="5.3 签收（ack）"></a>5.3 签收（ack）</h2><p>签收和事务起到的作用是一样的，事务的优先级高于签收，即如果开启了事务，签收方式不管是哪种都是不起作用的，一般事务倾向于生产者使用，签收倾向于消费者使用。</p>
<p>签收方式总共有4种，<code>AUTO_ACKNOWLEDGE</code>自动签收，<code>CLIENT_ACKNOWLEDGE</code>手动签收，<code>DUPS_OK_ACKNOWLEDGE</code>可重复的签收（不常用），<code>SESSION_TRANSACTED</code>一般表示开启了事务设置任何签收方式是无效的。</p>
<p>如果签收方式为<code>CLIENT_ACKNOWLEDGE</code>手动签收，必须执行<code>message.acknowledge()</code>，消息才能被真正的消费或者发送。</p>
<h1 id="6-高级特性"><a href="#6-高级特性" class="headerlink" title="6 高级特性"></a>6 高级特性</h1><h2 id="6-1-异步投递"><a href="#6-1-异步投递" class="headerlink" title="6.1 异步投递"></a>6.1 异步投递</h2><p>ActiveMQ支持以同步或异步模式向borker发送消息，所使用的模式对发送调用的延迟有很大的影响。由于延迟通常是生产者可以实现的吞吐量中的一个重要因素，因此使用异步发送可以显著提高系统的性能。</p>
<p>ActiveMQ默认以异步模式发送消息，以同步模式发送的情况是除非明确指定使用同步发送或者<strong>事务外部发送持久消息</strong>（即未使用事务的前提下发送持久化消息）。如果不使用事务，而是发送持久消息，那么每次发送都会同步并阻塞，直到broker向生产者发送确认消息已安全持久存储到磁盘为止，此确认机制提供了消息不会丢失的保证，但由于客户端被阻塞需要付出巨大的延迟代价。</p>
<p>异步投递可以最大化producer端的发送效率。通常在发送消息量比较密集的情况下使用异步发送，它可以很大的提升producer的吞吐量，不过这也带来了额外的问题，就是需要消耗很多的client端内存的同时也会导致broker端性能消耗增加，此外<strong>不能有效的确保消失的发送成功</strong>。在使用异步投递的情况下客户端需要容忍消息丢失的可能。</p>
<ul>
<li><p><strong>开启异步投递的三种方式</strong></p>
<ol>
<li><p>通过Connection URI后面添加参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://locahost:61616?jms.useAsyncSend=true&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ConnectionFactory对象属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Connection对象属性，在此级别配置将覆盖ConnectionFactory级别的设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>如何保证一部投递情况下消息不丢失</strong></p>
<p>异步发送消息丢失的情况场景是，UseAsyncSend为true，使用<code>producer.send(message)</code>持续发送消息，消息不会阻塞，生产者会认为所有的消息均会被发送到了MQ服务，如果MQ服务突然宕机，此时生产者端尚未同步到MQ服务的消息均会丢失。所以，正确的异步发送方法需要接收回调的。</p>
<p>同步发送和异步发送的区别就在于，同步发送<code>send()</code>不阻塞就代表消息发送成功，异步发送需要接收回调并由客户端再判断一次是否发送。异步投递编码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//producer.send(textMessage);</span></span><br><span class="line">            <span class="comment">//异步投递并确认消息发送结果</span></span><br><span class="line">            textMessage.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line">            String msgId = textMessage.getJMSMessageID();</span><br><span class="line">            ((ActiveMQMessageProducer) producer).send(textMessage, <span class="keyword">new</span> AsyncCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span> </span>&#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">                    <span class="comment">// 对于失败消息后续可以进行重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="6-2-定时与延时投递"><a href="#6-2-定时与延时投递" class="headerlink" title="6.2 定时与延时投递"></a>6.2 定时与延时投递</h2><p>有时候我们需要消息在某个时间点发送或者延迟一段时间发送。</p>
<p>ActiveMQ开启定时与延迟投递，首先编辑<code>activemq.xml</code>配置文件，<code>&lt;broker&gt;</code>标签内添加属性<code>schedulerSupport</code>并且设置为<code>true</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> <span class="attr">brokerName</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;$&#123;activemq.data&#125;&quot;</span> <span class="attr">schedulerSupport</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码中生产者端消息对象<code>message</code>，需要设置时间调度相关属性，主要属性如下：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AMQ_SCHEDULED_DELAY</td>
<td>long</td>
<td>延迟投递时间</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_PERIOD</td>
<td>long</td>
<td>重复投递时间间隔</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_REPEAT</td>
<td>int</td>
<td>重复投递次数</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_CRON</td>
<td>String</td>
<td>cron表达式</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//消息延迟3秒，每隔4秒重复发送，重复5次</span></span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, <span class="number">3000L</span>);</span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, <span class="number">4000L</span>);</span><br><span class="line">            textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, <span class="number">5</span>); <span class="comment">//（加上第一次实际上总共6次）</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>更多介绍参考官网 <a href="http://activemq.apache.org/delay-and-schedule-message-delivery">http://activemq.apache.org/delay-and-schedule-message-delivery</a></p>
<h2 id="6-3-消费者消息重试策略"><a href="#6-3-消费者消息重试策略" class="headerlink" title="6.3 消费者消息重试策略"></a>6.3 消费者消息重试策略</h2><p>当下列任何一种情况发生时，borker会将消息重新传送至消费端:</p>
<ul>
<li>使用事务会话并调用<code>rollback()</code>；</li>
<li>使用事务会话调用<code>commit()</code>之前关闭已处理的会话；</li>
<li>在手动签收<code>CLIENT_ACKNOWLEDGE</code>传递模式下调用<code>session.recover()</code>；</li>
<li>客户机连接超时(可能正在执行的代码比配置的超时时间更长)。</li>
</ul>
<p>默认重发时间间隔为1秒总共重发6次，超过6次即最大重发次数后，消费端会给broker返送一个<code>poison ack</code>表示这个消息有毒，告诉broker不要再发了，这个时候broker会把这个消息放到DLQ（死信队列），以便稍后对其进行分析并人工干预处理。</p>
<p>定义重发策略，编码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        ActiveMQConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        RedeliveryPolicy policy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        policy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        policy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        policy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        policy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        connectionFactory.setRedeliveryPolicy(policy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从ActiveMQ v5.7.0开始，可以在每个目的地的基础上配置RedeliveryPolicy,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">true</span>, Session.CLIENT_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        </span><br><span class="line">        RedeliveryPolicy queuePolicy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        queuePolicy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        queuePolicy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        queuePolicy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        queuePolicy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        RedeliveryPolicyMap redeliveryPolicyMap =((ActiveMQConnection)connection).getRedeliveryPolicyMap();</span><br><span class="line">        redeliveryPolicyMap.put((ActiveMQQueue)queue, queuePolicy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>常用重发策略配置如下：<br>|属性名称   |默认值   |描述   |<br>| ———— | ———— | ———— |<br>|collisionAvoidanceFactor|    0.15|设置防止冲突范围的正负百分比，只有启用useCollisionAvoidance参数时才生效。也就是在延迟时间上再加一个时间波动范围|<br>|initialRedeliveryDelay|    1000L|    初始重发延迟时间|<br>|maximumRedeliveries|    6|最大重发次数，达到最大重发次数后消息进入死信队列。为-1时不限制次数，为0时表示不进行重发|<br>|maximumRedeliveryDelay|    -1|    最大重发延迟时间，只有useExponentialBackOff为true时有效（v5.5）。假设首次重发间隔为10ms，倍数为2，那么第二次重发时间间隔为20ms，第三次时间间隔为40ms，当重发时间间隔的达到最大传送延迟时间，以后每次重发时间间隔都为最大传送延迟时间。为-1时不限制最大时间间隔|<br>|redeliveryDelay|    1000L | 重发延迟时间，当initialRedeliveryDelay=0生效|<br>|useCollisionAvoidance|    false|启用防止冲突功能|<br>|useExponentialBackOff|    false|启用指数倍数递增的方式增加延迟时间|<br>|backOffMultiplier|    5|重发时间间隔递增倍数，只有值大于1和启用useExponentialBackOff参数时才生效|<br>更多重发介绍参考官网 <a href="http://activemq.apache.org/redelivery-policy">http://activemq.apache.org/redelivery-policy</a></p>
<p>ActiveMQ中的默认死信队列名称为<code>ActiveMQ.DLQ</code>，所有无法交付的消息都将被发送到这个队列，这可能很难管理，因此，你也可以在<code>activemq.xml</code>配置文件为每个目的地配置单独的死信队列，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单独为每个queue目的地设置一个死信队列，前缀为DLQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Set the following policy on all queues using the &#x27;&gt;&#x27; wildcard --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Use the prefix &#x27;DLQ.&#x27; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">&quot;DLQ.&quot;</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>死信队列详细介绍参考官网 <a href="http://activemq.apache.org/message-redelivery-and-dlq-handling">http://activemq.apache.org/message-redelivery-and-dlq-handling</a></p>
<h1 id="7-内嵌broker"><a href="#7-内嵌broker" class="headerlink" title="7 内嵌broker"></a>7 内嵌broker</h1><p>使用spring boot开发web应用的时候，spring boot提供了内嵌的tomcat或者jetty服务器，使用内嵌服务器运行项目时就不用再单独启动一个servlet服务器了，类似的ActiveMQ也提供了一个内嵌broker，使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.broker.BrokerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbedBroker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">        brokerService.setUseJmx(<span class="keyword">true</span>);</span><br><span class="line">        brokerService.addConnector(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        brokerService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细介绍参考官网 <a href="https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html">https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html</a></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（二）——方法引用</title>
    <url>/20190202/lambda2/076a298db052.html</url>
    <content><![CDATA[<p>当我们在使用lambda去表示某个函数式接口的实例时，需要在lambda表达式的主体里去编写函数式接口抽象方法的实现，如果在现有的类中已经存在与抽象方法类似的方法了，我们希望直接引用现有的方法，而不用再去重新写实现了。方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。</p>
<p>方法引用和lambda表达式拥有相同的特性，它们都需要代表一个<strong>目标类型</strong>，并需要被转化为函数式接口的实例，不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法方。<strong>法引用要使用到操作符 “::”，左边是类名或者对象名，右边是方法名或者关键字<code>new</code></strong></p>
<p>首先被引用方法的返回值类型要和函数式接口抽象方法的返回值类型一致，至于参数列表要根据每种引用方式而定。</p>
<a id="more"></a>

<h1 id="1-静态方法引用"><a href="#1-静态方法引用" class="headerlink" title="1. 静态方法引用"></a>1. 静态方法引用</h1><p>语法：<code>ClassName::staticMethodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = x -&gt; Long.valueOf(x);</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = Long::valueOf;</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>静态方法引用时，静态方法要与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="2-对象方法引用"><a href="#2-对象方法引用" class="headerlink" title="2. 对象方法引用"></a>2. 对象方法引用</h1><p>语法：<code>ClassName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = (s) -&gt; s.length();</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = String::equals;</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = String::length;</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>对象方法引用时，函数式接口抽象方法的第一个参数是被引用方法的调用者，第二个参数(或者无参)是被引用方法的参数</strong></p>
<h1 id="3-外部对象方法引用"><a href="#3-外部对象方法引用" class="headerlink" title="3. 外部对象方法引用"></a>3. 外部对象方法引用</h1><p>语法：<code>objectName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">Predicate&lt;String&gt; p = (s) -&gt; list.contains(s);</span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; p = list::contains; </span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>外部对象方法引用时，被引用方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4. 构造器引用"></a>4. 构造器引用</h1><p>语法：<code>ClassName::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = (millisecond) -&gt; <span class="keyword">new</span> Date(millisecond);</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = Date::<span class="keyword">new</span>;</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>
<p><strong>构造器引用时，被引用的构造方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5. 数组引用"></a>5. 数组引用</h1><p>语法：<code>Type[]::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = n -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>数组引用时，函数式接口抽象方法参数(数值型)即为数组初始化大小值</strong></p>
]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（一）——函数式接口</title>
    <url>/20190201/lambda1/c673d3a38bb1.html</url>
    <content><![CDATA[<h2 id="1-什么是lambda"><a href="#1-什么是lambda" class="headerlink" title="1.什么是lambda?"></a>1.什么是lambda?</h2><p>如果我们想要起一个线程来打印一串字符串，我们之前的写法通常是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式后，可以改写为这个样：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>我们可以看到使用lambda表达式后，代码变得更加简洁，这里的 “<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>“ 其实就相当于Runnable接口的匿名实现，你会发现Runnable的抽象方法<code>run()</code>的签名与<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>的签名是一致的（lambda表达式的签名下面会讲到）。简而言之，可以把Lambda表达式理解为<strong>简洁地表示可传递的匿名函数的一种方式，它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</strong></p>
<p>lambda表达式由三部分构成：<strong>参数列表</strong>、**-&gt;(分割符)<strong>、</strong>主体**，基本语法如下：<br><code>(parameters) -&gt; expression</code> 或者 <code>(parameters) -&gt; &#123; statements; &#125;</code></p>
<ul>
<li>参数列表：多个参数用逗号隔开，类型可以省略不写，要保证与函数式接口抽象方法的参数列表一致，如果只有一个参数”()”可以省略；</li>
<li>箭头（-&gt;）: 用于分割参数列表和主体；</li>
<li>主体：可以直接是表达式，有多条语句要用花括号括起来，如果lambda需要返回一个值，那么返回值即使expression本身所表示的值，如有使用的“{}”，需要用return关键字返回具体值。  </li>
</ul>
<p>Lambda的类型是从使用Lambda的上下文推断出来的，上下文中Lambda表达式所需要代表的类型称为<strong>目标类型</strong>，如上示例中 “<code>() -&gt; System.out.println(&quot;hello world!&quot;)</code>” 代表的是Runnable类型的实例，所以相同的lambda表达式在不同的上下文中可能代表不同类型的函数式接口</p>
<h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h2><p>假设上面的示例中，如果Runnable接口有两个抽象方法run()和run2()，那么lambda表达式该怎么表示呢，相当于重写了哪个方法呢？这种情况是不能使用lambda表达式的，只有在使用了函数式接口的地方才能使用lambda表达式，所以这里要说一下函数是接口的定义。所谓函数式接口，即：<strong>只有一个抽象方法的接口</strong>。 Java8已经为我们提供了一些常用的函数式接口，如下表：</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>函数描述符</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate&lt;T&gt;</td>
<td>T-&gt;boolean</td>
<td>IntPredicate,<br/>LongPredicate,<br/>DoublePredicate</td>
</tr>
<tr>
<td>Consumer</td>
<td>T-&gt;void</td>
<td>IntConsumer,<br/>LongConsumer,<br/>DoubleConsumer</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T-&gt;R</td>
<td>IntFunction,<br/>IntToDoubleFunction,<br/>IntToLongFunction,<br/>LongFunction,<br/>LongToDoubleFunction,<br/>LongToIntFunction,<br/>DoubleFunction,<br/>ToIntFunction,<br/>ToDoubleFunction,<br/>ToLongFunction</td>
</tr>
<tr>
<td>Supplier</td>
<td>()-&gt;T</td>
<td>BooleanSupplier,<br/>IntSupplier,<br/>LongSupplier,<br/>DoubleSupplier</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>T-&gt;T</td>
<td>IntUnaryOperator,<br/>LongUnaryOperator,<br/>DoubleUnaryOperator</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>(T,T)-&gt;T</td>
<td>IntBinaryOperator,<br/>LongBinaryOperator,<br/>DoubleBinaryOperator</td>
</tr>
<tr>
<td>BiPredicate&lt;L,R&gt;</td>
<td>(L,R)-&gt;boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>(T,U)-&gt;void</td>
<td>ObjIntConsumer,<br/>ObjLongConsumer,<br/>ObjDoubleConsumer</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>(T,U)-&gt;R</td>
<td>ToIntBiFunction&lt;T,U&gt;,<br/>ToLongBiFunction&lt;T,U&gt;,<br/>ToDoubleBiFunction&lt;T,U&gt;</td>
</tr>
</tbody></table>
<p> 函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，我们将这种抽象方法叫作<strong>函数描述符</strong>，比如 “<code>T-&gt;boolean</code>“ 表示传入一个T类型的参数并返回boolean类型的值。</p>
<p> <strong>原始类型特化</strong>是在某个函数是接口上，把输入或输出参数特化为原始类型，这样就避免了拆装箱操作，以提高性能。例如 <code>IntPredicate</code> 把输入参数特化为<code>int</code>类型，ToLongFunction把返回值特化为<code>long</code>类型。</p>
<blockquote>
<p>查看上表函数式接口的源码，会发现它们都有一个 <code>@FunctionalInterface</code> 注解，这是Java8提供的用来表示接口是否为函数式接口，但它不是必须的，只要接口只包含一个抽象方法就是函数式接口，只是如果接口上加上了<code>@FunctionalInterface</code>注解，那么往接口中添加其他抽象方法时编译就会报错，起到一个限定作用；  </p>
</blockquote>
<blockquote>
<p>特殊的void兼容规则<br>   如果一个Lambda的主体是一个语句表达式(expression)，它就和一个返回void的函数描述符兼容（当然需要参数列表一致）。例如，以下两行都是合法的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -&gt; void）所要求的void：<br>   // Predicate返回了一个boolean<br>   Predicate<String> p = s -&gt; list.add(s);<br>   // Consumer返回了一个void<br>   Consumer<String> b = s -&gt; list.add(s);  </p>
</blockquote>
<h2 id="3-lambda使用局部变量的限制"><a href="#3-lambda使用局部变量的限制" class="headerlink" title="3.lambda使用局部变量的限制"></a>3.lambda使用局部变量的限制</h2><p>lambda可以没有限制的在主体中引用实例变量和静态变量，但是引用的局部变量必须声明为<code>final</code>或者事实上是<code>final</code>。因为成员变量存储在堆中，而局部变量保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在另一个线程中使用的，则使用Lambda的线程时，可能会在分配该局部变量的线程将这个变量收回之后去访问该变量。因此，Java在访问局部变量时，实际上是在访问它的副本，而不是访问原始变量，如果局部变量仅仅赋值一次,那么副本和原始变量就没有什么区别了——因此就有了这个限制，要保证副本和原始值保持一致。<br>例如下面的代码，如果把 “//name = “jack”;” 注释去掉，就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">String name = <span class="string">&quot;tome&quot;</span>;</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello &quot;</span> + name));</span><br><span class="line"><span class="comment">//name = &quot;jack&quot;;</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射基础运用</title>
    <url>/20190101/reflect/b01167aa3bca.html</url>
    <content><![CDATA[<h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h2><p>反射是指在程序运行时期可以动态的加载类并访问、检测和修改对象的一种能力。 那为什么要使用反射呢？编程时一般会遇到这种情况，编译时期无法确定对象类型，只有在运行时期才能确定，比如Spring的配置中就大量使用了反射机制。通过反射能够获取到类的一切信息，访问到对象的一切属性和方法，包括private修饰的属性和方法。  </p>
<a id="more"></a>

<p>Class类与java.lang.reflect类库一起对反射进行了支持。 java.lang.reflect类库包含了Field、Method、Constructor等类，Field类：关联一个字段，Field对象可以对该字段进行操作，比如用Field的set()和get()方法可以获取和修改关联字段的值；Method类：关联一个方法，用Metond的invoke()方法可以调用Method对象关联的方法；Constructor类： 关联构造器方法，调用Constructor类的newInstance()用来创建对象。而这三个类都可以通过Class对象获得。</p>
<h2 id="2-Class类介绍"><a href="#2-Class类介绍" class="headerlink" title="2.Class类介绍"></a>2.Class类介绍</h2><p>在学习使用反射之前，我们先来了解一下Class类。什么是Class类呢？我们不妨先把Java中的对象分为两种，一种是我们通常自己定义的类型对象，即“常规”对象，另一种是class对象，而每一个类在编译是都会产生一个class对象（被保存在一个同名的.class文件中），在Java程序运行时，可以通过Class对象获得对应类型的一切信息，比如该类有哪些方法、哪些构造方法、是不是接口等信息，是一个类型的描述对象。实际上Class类也是一个普通类，但是它的对象记录着对应类的一切信息，甚至该类的所有对象也都是有他的class对象完成创建的。</p>
<h2 id="2-1-如何获取class对象"><a href="#2-1-如何获取class对象" class="headerlink" title="2.1 如何获取class对象"></a>2.1 如何获取class对象</h2><p>每一个类都会存在一个唯一的Class对象，那么该如何获取Class对象呢？ 有三种方式：    </p>
<ul>
<li><strong>Class.forName(“类全名字符串”)</strong>  </li>
<li><strong>实例对象.getClass()</strong>  </li>
<li><strong>类名.class (此方式来创建Class对象时，不会自动的初始化该Class对象)</strong>  </li>
</ul>
<p>对于基本类型也存在Class对象，基本类型的包装器类型都有一个标准字段TYPE，此TYPE字段就是对应基本类型的class对象的引用。  </p>
<h3 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h3><p>首先创建一个Student类（后续示例都延用此类）：</p>
<figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">      <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在学习：&quot;</span> + course);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在睡觉zzz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123; name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age + <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*第一种方式：Class.forName(&quot;类全名&quot;)*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            studentClass1 = Class.forName(<span class="string">&quot;com.taicw.code.Student&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类型不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第二中种方式：类名.class*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第三种方式：实例对象.getClass()*/</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Class&lt;?&gt; studentClass3 = student.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;三种方式获取的Class对象是否为同一个? &quot;</span> +</span><br><span class="line">                (studentClass1 == studentClass2 &amp;&amp; studentClass2 == studentClass3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.class ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer.TYPE == Integer.class ? &quot;</span> + (Integer.TYPE == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.TYPE ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.TYPE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">三种方式获取的Class对象是否为同一个? true</span></span><br><span class="line"><span class="comment">int.class == Integer.class ? false</span></span><br><span class="line"><span class="comment">Integer.TYPE == Integer.class ? false</span></span><br><span class="line"><span class="comment">int.class == Integer.TYPE ? true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h3 id="2-3-类型判断"><a href="#2-3-类型判断" class="headerlink" title="2.3 类型判断"></a>2.3 类型判断</h3><p>在程序运行时期，我们拿到Class对象后，可能还会需要判断一个对象的类型，根据不同的类型做不同的逻辑处理，判断类型的方式有三种，下面比较一下三种方式的不同点和使用：</p>
<table>
<thead>
<tr>
<th></th>
<th>instanceof</th>
<th>isInstance</th>
<th>isAssignableFrom</th>
</tr>
</thead>
<tbody><tr>
<td>表现形式</td>
<td>关键字</td>
<td>方法</td>
<td>方法</td>
</tr>
<tr>
<td>使用方法</td>
<td>obj instanceof Type</td>
<td>class.isInstance(obj)</td>
<td>class1.isAssignableFrom(class2)</td>
</tr>
<tr>
<td>作用</td>
<td>Java的关键字，用于判断一个对象（obj）是否为一个类（Type）或者该类的子类的实例</td>
<td>Class类对象的一个方法，判断一个对象是否是该Class对象所表示的类或其子类的实例。</td>
<td>Class类对象的一个方法，其参数也是Class类的对象，用于判断class1是否与class2对象为同一类型或class2的超类或接口。</td>
</tr>
</tbody></table>
<h2 id="3-反射的基本使用"><a href="#3-反射的基本使用" class="headerlink" title="3.反射的基本使用"></a>3.反射的基本使用</h2><h3 id="3-1-获取构造器信息并创建实例"><a href="#3-1-获取构造器信息并创建实例" class="headerlink" title="3.1 获取构造器信息并创建实例"></a>3.1 获取构造器信息并创建实例</h3><p>上面已经说了任何类型的对象实际上就是其对应的Calss对象创建，那么我们拿到了class对象后该如何去创建一个对象呢？  </p>
<p><strong>第一种方式：通过Class对象的newInstance()方法来创建对应类型的实例对象。</strong> class对象的newInstance()方法使用的是对应类型的默认构造方法（无参构造方法），所以该方式必须要保证Class对应类型必须要有一个无参构造方法。那么如果我们需要使用有参构造方法怎么办呢？还有另一种方式。<br><strong>第二种：先通过Class对象获取相关的Constructor对象（每一个构造方法对应一个Constructor对象），再调用Constructor对象的newInstance()方法来创建实例。</strong> 通过Class对象获取构造器对象主要有一下几个方法：  </p>
<ul>
<li><p>public Constructor&lt;?&gt;[] <code>getConstructors()</code>：获取Class对象关联类型的所有public修饰的构造器对  </p>
</li>
<li><p>public Constructor&lt;?&gt;[] <code>getDeclaredConstructors()</code>：获取Class对象关联类型的所有构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的public修饰的构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的构造器对象（包括任意限定符修饰的构造方法） </p>
</li>
<li><p>public T <code>newInstance(Object ... initargs)</code>：获取构造器对象后，调用该方法并按顺序传入参数对象来创建实例  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Class对象的newInstance()方法创建实例*/</span></span><br><span class="line">        Student zhangsan =  studentClass.newInstance();</span><br><span class="line">        System.out.println(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Constructor对象的newInstance()方法创建实例*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的public构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allPublicConstructors = studentClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allPublicConstructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allConstructors = studentClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPublicConstructor = studentClass.getConstructor(String.class);</span><br><span class="line">        Student lisi = studentPublicConstructor.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定public构造器对象来创建关联类型实例：&quot;</span> + lisi);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPrivateConstructor = studentClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        studentPrivateConstructor.setAccessible(<span class="keyword">true</span>); <span class="comment">/*调用是由构造器之前需要设置访问标志为true*/</span></span><br><span class="line">        Student wangwu = studentPrivateConstructor.newInstance(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定private构造器对象来创建关联类型实例：&quot;</span> + wangwu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">&#123; name:张三, age:18 &#125;</span></span><br><span class="line"><span class="comment">获取所有的public构造器对象：</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">获取所有的构造器对象：</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(java.lang.String,int)</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(int)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">根据参数类型获取指定public构造器对象来创建关联类型实例：&#123; name:李四, age:0 &#125;</span></span><br><span class="line"><span class="comment">根据参数类型获取指定private构造器对象来创建关联类型实例：&#123; name:王五, age:20 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-获取Method信息并调用其关联方法"><a href="#3-2-获取Method信息并调用其关联方法" class="headerlink" title="3.2 获取Method信息并调用其关联方法"></a>3.2 获取Method信息并调用其关联方法</h3><p>通过Class对象获取Method对象主要有以下几个方法：  </p>
<ul>
<li><p>public Method[] <code>getMethods()</code>：获取关联类型的所有公有（public）方法对象，包括其父类的所有公有方法对象  </p>
</li>
<li><p>public Method[] <code>getDeclaredMethods()</code>：获取关联类型的所有方法（包括public、protected、default、private修饰的方法）对象，但不包括其父类的方法对象  </p>
</li>
<li><p>public Method <code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的公有方法对象  </p>
</li>
<li><p>public Method <code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的所有(不包含父类)方法对象  </p>
</li>
<li><p>public Object <code>invoke(Object obj, Object... args)</code>：通过Method对象来执行指定对象的方法，第一个参数为要执行该方法的对象，后面为方法参数，按顺序传入  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        Method[] allPublicMethods = studentClass.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allPublicMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] allMethods = studentClass.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method publicMethod = studentClass.getMethod(<span class="string">&quot;study&quot;</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的公有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(publicMethod);</span><br><span class="line"></span><br><span class="line">        Method privateMethod = studentClass.getDeclaredMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的私有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(privateMethod);</span><br><span class="line"></span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line">        publicMethod.invoke(obj,<span class="string">&quot;English&quot;</span>);</span><br><span class="line"></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>); <span class="comment">/*访问私有方法前，需要设置访问标志为true*/</span></span><br><span class="line">        privateMethod.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的公有method对象：</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的私有method对象：</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">我正在学习：English</span></span><br><span class="line"><span class="comment">我正在睡觉zzz</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取Field信息并操作其关联属性"><a href="#3-3-获取Field信息并操作其关联属性" class="headerlink" title="3.3 获取Field信息并操作其关联属性"></a>3.3 获取Field信息并操作其关联属性</h3><p>通过Class对象获取Field对象主要有以下几个方法：  </p>
<ul>
<li><p>public Field[] <code>getFields()</code>：获取关联类型的所有公有（public）属相对象，包括其父类的所有公有属性  </p>
</li>
<li><p>public Field[] <code>getDeclaredFields()</code>：获取关联类型的所有属性（包括public、protected、default、private修饰的属性）对象，但不包括其父类的属性  </p>
</li>
<li><p>public Field <code>getField(String name)</code>：根据属性名称获取指定的公有属性对象  </p>
</li>
<li><p>public Field <code>getDeclaredField(String name)</code>：根据属性名称获取任意的属性对象，但不包括父类的属性  </p>
</li>
</ul>
<ul>
<li><p>public void <code>set(Object obj, Object value)</code>：获取Field对象后，为指定对象属性赋值  </p>
</li>
<li><p>public Object <code>get(Object obj)</code>：通过Field对象，获取指定对象的属性值  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line"></span><br><span class="line">        Field[] allPublicFields =  studentClass.getFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allPublicFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] allFields = studentClass.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取公有(public)属性，包括获取其父类的公有属性*/</span></span><br><span class="line">        Field namePublicField = studentClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        namePublicField.set(obj, <span class="string">&quot;李哈哈&quot;</span>);</span><br><span class="line">        String name = (String)namePublicField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取公有属性name：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取任意属性，不能获取父类的属性*/</span></span><br><span class="line">        Field agePrivateField = studentClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        agePrivateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        agePrivateField.set(obj, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">int</span> age = (<span class="keyword">int</span>)agePrivateField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取私有属性age：&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射设置并获取属性信息：&quot;</span> + obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">private int com.taicw.code.Student.age</span></span><br><span class="line"><span class="comment">反射获取公有属性name：李哈哈</span></span><br><span class="line"><span class="comment">反射获取私有属性age：18</span></span><br><span class="line"><span class="comment">通过反射设置并获取属性信息：&#123; name:李哈哈, age:18 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
