<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM参数类型</title>
    <url>/20200501/jvmParamType/218e2c7235be.html</url>
    <content><![CDATA[<h1 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. 参数分类</h1><p>jvm 参数可分为三类：</p>
<ul>
<li>标准参数：以 “<code>-</code>“ 开头的参数</li>
<li>非标准参数：以 “<code>-X</code>“ 开头的参数</li>
<li>不稳定参数：以”<code>-XX</code>“ 开头的参数</li>
</ul>
<a id="more"></a>

<h1 id="2-标准参数（-）"><a href="#2-标准参数（-）" class="headerlink" title="2. 标准参数（-）"></a>2. 标准参数（-）</h1><p><strong>标准参数</strong>是指在各个JVM版本中基本保持不变，相对比较稳定。</p>
<p>标准参数统一都是以 “<code>-</code>“ 开头，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dprofile&#x3D;dev HelloWorld tom jack</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：其中<code>HelloWorld</code>  是被运行的 HelloWorld.class。<code>HelloWorld</code> 之前就是设置的JVM标准参数（-classpath、-D），<code>HelloWorld</code> 之后的参数(tom、jack)是用来传给 <code>main(String[] args)</code> 方法的args数组变量的，两者位置不要放错</p>
</blockquote>
<p><strong>查看所有标准参数</strong>：</p>
<p>打开一个命令终端，执行 “<code>java -help</code>“，就可以展示所有的JVM标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -help</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;&#x3D;&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括&#x2F;排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp&#x3D;help 和 -agentlib:hprof&#x3D;help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;java&#x2F;javase&#x2F;documentation&#x2F;index.html。</span><br></pre></td></tr></table></figure>



<h1 id="2-非标准参数（-X）"><a href="#2-非标准参数（-X）" class="headerlink" title="2. 非标准参数（-X）"></a>2. 非标准参数（-X）</h1><p><strong>非标准参数</strong>表示不保证所有VM实现都支持这些参数，在将来的JVM版本中可能会发生改变</p>
<p>非标准参数统一以 “<code>-X</code>“ 开头，如 <code>-Xmx20M</code> 设置最大java堆大小，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有非标准参数</strong>：</p>
<p>打开一个命令终端，执行 “`java -X”，就可以展示所有的JVM非标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -X</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath&#x2F;a:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath&#x2F;p:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java&#x2F;VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>



<h1 id="3-不稳定参数-（-XX）"><a href="#3-不稳定参数-（-XX）" class="headerlink" title="3. 不稳定参数 （-XX）"></a>3. 不稳定参数 （-XX）</h1><p><strong>不稳定参数</strong>这是我们日常开发中接触到最多的参数类型，也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于JVM调优和debug</p>
<p><strong>不稳定参数</strong>统一以 “<code>-XX</code>“ 开头，书写格式分为两种：</p>
<ul>
<li>bool 类型：<ul>
<li><code>-XX:+&lt;option&gt;</code>：代表启用 true</li>
<li><code>-XX:-&lt;option&gt;</code>：代表禁用 false</li>
</ul>
</li>
<li>数值或字符串类型：<ul>
<li><code>-XX:&lt;option&gt;=&lt;number&gt;</code>。数字如果有单位一般是 兆字节的“ m”或“ M”，千字节的“ k”或“ K”以及千兆字节的“ g”或“ G”（例如32k与32768相同）</li>
<li><code>-XX:&lt;option&gt;=&lt;string&gt;</code>。字符串通常用于指定文件，路径或命令列表</li>
</ul>
</li>
</ul>
<p>如 打印GC日志 <code>-XX:+PrintGCDetails</code>、设置对象最大晋升老年代的年龄 <code>-XX:MaxTenuringThreshold=15</code>，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M -XX:+PrintGCDetails -XX:MaxTenuringThreshold&#x3D;15  HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有不稳定参数（-XX:+PrintFlagsFinal）</strong></p>
<p>执行命令终端，执行 “<code>-XX:+PrintFlagsFinal</code>“，展示所有不稳定参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          &#x3D; 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    &#x3D; 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        &#x3D; 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx AliasLevel                                &#x3D; 3                                   &#123;C2 product&#125;</span><br><span class="line">     bool AlignVector                               &#x3D; false                               &#123;C2 product&#125;</span><br><span class="line">     intx AllocateInstancePrefetchLines             &#x3D; 1                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchDistance                  &#x3D; 192                                 &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchInstr                     &#x3D; 3                                   &#123;product&#125;</span><br><span class="line">     ...省略...</span><br><span class="line">    ccstr TraceJVMTI                                &#x3D;                                     &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                            :&#x3D; true                                &#123;product&#125;</span><br><span class="line">     ......</span><br><span class="line">    uintx YoungGenerationSizeIncrement              &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             &#x3D; 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        &#x3D; 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             &#x3D; 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  &#x3D; 5                                   &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_161&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：参数类型</li>
<li>第二列：参数名称</li>
<li>第三列：”<code>=</code>“ 表示第四列是初始值，”<code>:=</code>“表示参数被用户或者JVM赋值了</li>
<li>第四列：参数值</li>
<li>第五列：参数类别</li>
</ul>
<p>**查看所有参数初始值(-XX:+PrintFlagsInitial)**：<br>相对于<code>-XX:+PrintFlagsFinal</code> 参数，<code>-XX:+PrintFlagsInitial</code>参数打印出的结果中第四列都是初始值</p>
<p><strong>打印已经被用户或者当前虚拟机设置过的参数(-XX:+PrintCommandLineFlags)</strong><br>相当于列举出 <code>-XX:+PrintFlagsFinal</code>的结果中所有第三列是”<code>:=</code>“的参数。一般运行程序时，最好都加上该参数，可以知道该程序运行都设置过哪些JVM参数</p>
<hr>
<p>更多参数使用说明参考官网：<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分区与挂载</title>
    <url>/20200207/post/9694dab2a110.html</url>
    <content><![CDATA[<h2 id="1-Linux版本"><a href="#1-Linux版本" class="headerlink" title="1.Linux版本"></a>1.Linux版本</h2><p>Linux分为<strong>内核版</strong>和<strong>发行版</strong>，Linux内核其实就是一个操作系统最底层的核心及其提供的核心工具，仅有内核而没有应用软件的操作系统是无法使用的，为了让使用者能够接触到Linux，于是很多的商业公司或非营利团体，就将 Linux Kernel(含 tools)与可运行的软件整合起来，加上自己具有创意的工具程序，这个工具程序可以让用户以光盘/DVD 或者透过网络直接安装/管理 Linux 系统，这个『Kernel + Softwares + Tools + 可完全安装程序』的咚咚，我们称之为Linux发行版。</p>
<a id="more"></a>

<p>Linux发行版本根据软件包管理方式大致可以分为两类，<strong>RPM方式管理软件的系统</strong>(RedHat系列：RedHat、CentOS、OpenSuSe等)，<strong>DPKG方式管理软件的系统</strong>(Debian系列：Debian、Ubuntu等)</p>
<h2 id="2-Linux分区与挂载"><a href="#2-Linux分区与挂载" class="headerlink" title="2.Linux分区与挂载"></a>2.Linux分区与挂载</h2><p>用于学习或者实验的话，一般采用虚拟机安装Linux操作系统即可，比较常用的虚拟机软件有VMware、VirtualBox，如果你的电脑是win10系统的话可以直接使用系统自带虚拟机软件Hyper-v，具体使用和安装过程这里不再详述可以自行参照网上教程，这里主要说一下Linux的分区与挂载。</p>
<h3 id="2-1-分区方式"><a href="#2-1-分区方式" class="headerlink" title="2.1 分区方式"></a>2.1 分区方式</h3><p>常见的两种分区表现形式，<br><strong>MBR分区表</strong>：最大支持2.1T硬盘，最多支持4个分区，支持32位和64位系统；<br><strong>GPT分区表</strong>(全局唯一标示分区表)：支持9.4ZB(1ZB=1024PB, 1PB=1024EB, 1EB=1024TB)，理论上支持的分区数没有限制(但windows限制128个主分区)，只支持64位系统。<br>虽然GPT是一个较新的分区机制，解决了MBR很多缺点，但是目前使用最多的还是MBR分区方式。MBR最多有4个分区，分区类型有三种：</p>
<ul>
<li><strong>主分区</strong></li>
<li><strong>扩展分区</strong><ul>
<li>最多有一个</li>
<li>扩展分区+主分区数最多不超过4个</li>
<li>不能写入数据，不能格式化，只能用来包含逻辑分区</li>
</ul>
</li>
<li><strong>逻辑分区</strong><ul>
<li>包含在扩展分区内，可以有多个</li>
<li>扩展分区至少要包含一个逻辑分区<h3 id="2-2-设备挂载"><a href="#2-2-设备挂载" class="headerlink" title="2.2 设备挂载"></a>2.2 设备挂载</h3>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，windows是通过设备管理器来管理硬件的，linux的设备文件保存在<code>/dev/</code>目录中，比如硬盘文件是<code>/dev/sd[a-p]</code>，光盘文件是<code>/dev/hdc</code>等，硬件设备需要挂载到相应的目录文件才能使用。</li>
</ul>
</li>
</ul>
<p>所谓的<strong>挂载</strong>就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区的意思，这个动作我们称为<strong>挂载</strong>，那个进入点的目录我们称为<strong>挂载点</strong>。 由于整个 Linux 系统最重要的是根目录(<code>/</code>)，因此根目录一定需要挂载到某个分区， 至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。</p>
<p>常见的硬件设备文件名如下：</p>
<table>
<thead>
<tr>
<th>硬件</th>
<th>设备名称</th>
</tr>
</thead>
<tbody><tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom或/dev/sr0</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[01-1]</td>
</tr>
<tr>
<td>打印机(25针)</td>
<td>/dev/lp[0-2]</td>
</tr>
<tr>
<td>打印机(USB)</td>
<td>/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
</tbody></table>
<p>图示说明：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux001.png?x-oss-process=style/watermarking" alt="linux设备挂载示意图"></p>
<p>上图所示，硬盘被分为三个可用分区，其中sda1、sda2为主分区分别挂载在/boot和 / 目录下，sda3为扩展分区内部包含一个逻辑分区sda5，sda5挂载在/home目录下。/boot目录下的所有数据存储在sda1分区里，/home目录下的所有数据存储在sda5分区里，根目录 / (除了/boot、/home)下的数据都存储在sda2分区里。</p>
<blockquote>
<p>1.sda1表示第一块硬盘第一个分区，sda2表示第一块硬盘第二个分区，sdb1表示第二块硬盘一个分区，以此类推…<br>2.逻辑分区一定是从sda5开始，因为sda1、sda2、sda3和sda4文件名被主分区或扩展分区占用</p>
</blockquote>
<p>Linux系统安装时，一般分区如下：</p>
<ul>
<li>必须分区<ul>
<li>/ （根分区）</li>
<li>swap （交换分区）<ul>
<li>如果真实内存小于4GB, swap为内存的两倍</li>
<li>如果真实内存大于4GB, swap和内存一致</li>
<li>实验环境，不大于2GB即可</li>
</ul>
</li>
</ul>
</li>
<li>推荐分区<ul>
<li>/boot (启动分区，一般1GB，仅存放系统启动所需的数据)</li>
</ul>
</li>
<li>常用分区<ul>
<li>/home (用于文件服务器)</li>
<li>/www (用于web服务器)<blockquote>
<p>swap分区的文件系统类型式为swap，其余分区文件系统类型一般为ext4。一般系统安装存在 /、swap、/boot三个分区即可</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-挂载命令"><a href="#2-3-挂载命令" class="headerlink" title="2.3 挂载命令"></a>2.3 挂载命令</h3><ol>
<li><strong>mount</strong> 或 <strong>mount -l</strong><ul>
<li>查询系统中已挂载的设备，-l会显示卷标名称</li>
</ul>
</li>
<li><strong>mount -a</strong><ul>
<li>依据配置文件/etc/fstab的内容，自动挂载</li>
</ul>
</li>
<li><strong>mount [-t 文件系统类型] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</strong><ul>
<li>手动挂载</li>
<li>选项<ul>
<li>-t 文件系统：加入文件系统类型来指定挂载的类型，可以是ext3、ext4、iso9660等文件系统 </li>
<li>-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</li>
<li>-o 特殊选项: 可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。具体的特殊选项见下表</li>
</ul>
</li>
</ul>
</li>
<li><strong>umount 设备文件名</strong> 或 <strong>umount 挂载点</strong><ul>
<li>卸载已挂载设备</li>
<li>因为设备文件名和挂载点已经连接到一起，所以卸载哪一个都可以</li>
</ul>
</li>
</ol>
<blockquote>
<p>补充（挂载特殊选项参数说明）：<br>| 特殊选项 | 说明 |<br>| — | — |<br>|atime/noatime | 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新|<br>|async/sync | 异步/同步，默认为异步|<br>|auto/noauto | 自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动|<br>|defaults|定义默认值，相当于 rw,suid,dev,exec,auto,nouser,async这七个选项|<br>|exec/noexec | 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec允许|<br>|remount | 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限。示例：<code>mount -o remount,noexec /boot</code> 重新挂载/boot分区并使用noexec权限|<br>|rw/ro|读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw|<br>|suid/nosuid | 具有/不具有 SUID权限，设定文件系统是否具有 SUID和 SGID的权限，默认是具有|<br>|user/nouser | 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认不允许，只有root可以挂载分区|<br>|usrquota | 写入代表文件系统支持用户磁盘配额，默认不支持|<br>|grpquota | 写入代表文件系统支持组磁盘配额，默认不支持 |</p>
</blockquote>
<h3 id="2-4-LVM逻辑卷管理"><a href="#2-4-LVM逻辑卷管理" class="headerlink" title="2.4 LVM逻辑卷管理"></a>2.4 LVM逻辑卷管理</h3><h4 id="2-4-1-LVM简介"><a href="#2-4-1-LVM简介" class="headerlink" title="2.4.1 LVM简介"></a>2.4.1 LVM简介</h4><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。传统分区使用固定大小分区，重新调整大小十分麻烦。LVM将一个或多个硬盘的分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘的分区加入其中，这样可以实现磁盘空间的动态管理，相对于传统的磁盘分区有很大的灵活性。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux002.png?x-oss-process=style/watermarking" alt="LVM示意图"></p>
<ul>
<li>**物理卷(PV, Physical Volume)**：就是真正的物理硬盘或分区</li>
<li>**卷组(VG, Volume Group)**：将多个物理卷合起来就组成卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘的不同分区，可以把物理卷想象为一个逻辑硬盘。</li>
<li>**逻辑卷(LV, Logival Volume)**：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区我们称作逻辑卷，逻辑卷可以格式化和写入数据。</li>
</ul>
<h4 id="2-4-2-建立LVM步骤"><a href="#2-4-2-建立LVM步骤" class="headerlink" title="2.4.2 建立LVM步骤"></a>2.4.2 建立LVM步骤</h4><ol>
<li>使用<code>fdisk</code>交互命令把物理硬盘分成分区，当然也可以是整块硬盘。</li>
<li>把物理分区建立成为物理卷(PV)，也可以把整块硬盘都建立为物理卷。<ul>
<li>建立物理卷：<code>pvcreate [设备文件名]</code><ul>
<li>把整块硬盘都建立成物理卷，命令为<code>pvcreate /dev/sdb</code>，即第二块硬盘整个都建立成物理卷；把分区建立成物理卷，命令为<code>pvcreate /dev/sdb5</code>，即第二块硬盘第五个分区建立成物理卷</li>
</ul>
</li>
<li>查看物理卷：<code>pvscan</code> 或 <code>pvdisplay</code>(查看更加详细的物理卷状态)</li>
<li>删除物理卷：<code>pvremove [物理卷名(建立物理卷时的设备文件名)]</code></li>
</ul>
</li>
<li>把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。<ul>
<li>建立卷组：<code>vgcreate [选项] 卷组名 物理卷名(多个空格隔开)</code><ul>
<li>选项 ‘<code>-s PE大小</code>‘:指定PE(保存数据的最小单元)的大小，单位可以是MB、GB、TB等，如果不写默认PE大小是4MB。</li>
<li>示例：<code>vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</code>， 把物理卷/dev/sdb5、/dev/sdb6加入卷组scvg</li>
</ul>
</li>
<li>查看卷组：<code>vgscan</code> 或 <code>vgdisplay</code></li>
<li>扩充卷组容量：<code>vgextend 卷组名 物理卷名</code></li>
<li>减小卷组容量：<code>vgreduce 卷组名 物理卷名</code></li>
<li>删除卷组：<code>vgremove 卷组名</code><ul>
<li>卷组如果已经添加了逻辑卷，要先删除逻辑卷才能删除卷组，卷组删除后才能删除物理卷</li>
</ul>
</li>
</ul>
</li>
<li>把卷组再划分为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成分区，所以也需要格式化和挂载。</li>
</ol>
<ul>
<li>建立逻辑卷：<code>lvcreate [选项] [-n 逻辑卷名] 卷组名</code></li>
<li>选项<ul>
<li><code>-L 容量</code>：指定逻辑卷大小，单位MB、GB、TB</li>
<li><code>-l 个数</code>：按照PE个数指定逻辑卷大小，这个参数需要换算容量</li>
<li><code>-n 逻辑卷名</code>：指定逻辑卷名</li>
</ul>
</li>
<li>示例：<code>lvcreate -L 2GB -n userlv scvg</code>，在卷组scvg中建立一个容量2GB名称为userlv的逻辑卷</li>
<li>建立完逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。格式化和挂载命令和操作普通分区时一样，不过需要注意的是逻辑卷的设备文件名是“**/dev/卷组名/逻辑卷名**”，比如示例这里建立的逻辑卷设备文件名是<code>/dev/scvg/userlv</code><ul>
<li>格式化逻辑卷：<code>mkfs -t ext4 /dev/scvg/userlv</code></li>
<li>创建挂载目录：<code>mkdir /disklvm</code></li>
<li>挂载逻辑卷：<code>mount /dev/scvg/userlv /disklvm/</code></li>
</ul>
</li>
</ul>
<h2 id="3-目录结及说明"><a href="#3-目录结及说明" class="headerlink" title="3.目录结及说明"></a>3.目录结及说明</h2><p>Linux目录结构及说明如下</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>bin是Binary的缩写, 这个目录存放着最经常使用的命令</td>
</tr>
<tr>
<td>/sbin/</td>
<td>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>系统用户使用的应用程序</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>超级用户使用的比较高级的管理程序和系统守护程序</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存于系统启动相关的文件，如内核文件和启动引导程序（grup）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td>
</tr>
<tr>
<td>/lib/</td>
<td>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</td>
</tr>
<tr>
<td>/lib64/</td>
<td>64位函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期Linux只有这一个挂载目录，并没有细分，现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘等。虽然有三个默认的挂载目录/media/、/misc/、/mnt/，但是到底使用哪个目录挂载什么设备都可以由管理员自己决定。一般习惯挂载目录只用一个/mnt/, 在/mnt/目录下建立不同的目录挂载不同的设备，如/mnt/cdrom挂载光盘、/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。一般习惯把软件放到/usr/local/目录中，也就是说/usr/local/目录也可以用来安装软件</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。改目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net 是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/root/</td>
<td>root用户的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在 / 下</td>
</tr>
<tr>
<td>/run/</td>
<td>系统运行时产生的数据，如ssid, pid等相关数据。</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放历史文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录不要保存重要数据，最好每次开机把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是”UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。手工下载的源码包和内核源码包都可以保存到这里。一般习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中</td>
</tr>
<tr>
<td>/usr/src/kernels/</td>
<td>内核源码保存位置</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。只要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
<tr>
<td>/var/www/html/</td>
<td>RPM包安装Apache的网页主目录</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用和改变的数据保存位置。如mysql的数据库保存在/var/lib/mysql/目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>系统日志保存位置</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的PID(进程ID)保存位置。是/run/目录的软链接</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列</td>
</tr>
<tr>
<td>/var/spool/mail/</td>
<td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>系统的定时任务队列保存位置。系统的计划任务会保存在这里</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分区</tag>
        <tag>挂载</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件之ActiveMQ入门</title>
    <url>/20190816/post/191434a07b67.html</url>
    <content><![CDATA[<h1 id="1-JMS与消息中间件"><a href="#1-JMS与消息中间件" class="headerlink" title="1. JMS与消息中间件"></a>1. JMS与消息中间件</h1><h2 id="1-1-jms介绍"><a href="#1-1-jms介绍" class="headerlink" title="1.1 jms介绍"></a>1.1 jms介绍</h2><p>jms是java消息服务接口规范，主要包含四大元素：<strong>生产者</strong>、<strong>消费者</strong>、<strong>消息</strong>、<strong>消息服务</strong>。  </p>
<ul>
<li><p>生产者：创建消息，并把消息发动到消息服务；  </p>
</li>
<li><p>消费者：从消息服务接收消息；</p>
</li>
<li><p>消息服务：即MQ消息服务（broker），而生产者与消费者相对其均为客服端；</p>
</li>
<li><p>消息：整个消息服务的传输对象，消息包含消息头、消息属性、消息体；</p>
<a id="more"></a>

</li>
</ul>
<blockquote>
<p><strong>常用消息头属性</strong>：JMSDestination(消息目的地，如果生产者指定了目的地，在发送时会改为生产者绑定的目的地)、JMSDeliveryMode(是持久还是非持久)、JMSExpiration(过期时间，默认永久)、JMSPriority(优先级，0-9，数值越大优先级越高，默认为4)、JMSMessageId(唯一的消息ID)；<br><strong>消息属性</strong>：可视为消息头属性的扩展，通过setXxxProperty(k,v)设置；<br><strong>消息体</strong>：封装消息的具体数据，发送与接收的消息体类型必须一致，消息体类型总共有5种，TextMessage、Mapmessage、BytesMessage、StreamMessage、ObjectMessage；</p>
</blockquote>
<h2 id="1-2-jms消息传递模式"><a href="#1-2-jms消息传递模式" class="headerlink" title="1.2 jms消息传递模式"></a>1.2 jms消息传递模式</h2><p>jms消息传递模式有如下两种，<br><strong>点对点消息传递模式（P2P）</strong>：消息发送到一个特殊队列(queue), 消费者从队列获取消息，一条消息只能被只能被一个消费者消费；<br>**发布/订阅消息传递模式(publish-subscribe)**：消息被发送到一个主题上(topic)，所有订阅了该主题的消费者，都能接收到消息。</p>
<h2 id="1-3-jms编码总体架构"><a href="#1-3-jms编码总体架构" class="headerlink" title="1.3 jms编码总体架构"></a>1.3 jms编码总体架构</h2><p>JMS应用程序由如下基本模块组成，</p>
<ol>
<li>连接工厂对象，创建消息客户端(生产者、消费者)与消息服务端的连接(connection)；</li>
<li>连接对象，创建回话对象(session);</li>
<li>会话对象，创建生产者对象(producer)、消费者对象(consumer)以及消息对象(message)；</li>
<li>目的地(queue/topic)，点对点模式下目的地是队列(queue)，发布/订阅模式下目的地是主题(topic)，生产者把消息发送到目的地，消费者从目的地接收消息</li>
</ol>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq1.png?x-oss-process=style/watermarking"></p>
<h2 id="1-4-消息中间件"><a href="#1-4-消息中间件" class="headerlink" title="1.4 消息中间件"></a>1.4 消息中间件</h2><p>  消息中间件是实现了jms规范的落地产品，目前市场上主流的消息中间件有 ActiveMQ、Kafka、RocketMQ、RabbitMQ等。企业开发中使用消息中间件的主要目的是<strong>解决耦合调用</strong>、**抵御洪峰流量(削峰)**等。 以下主要讲解ActiveMQ的使用。</p>
<h1 id="2-ActiveMQ安装并启动"><a href="#2-ActiveMQ安装并启动" class="headerlink" title="2. ActiveMQ安装并启动"></a>2. ActiveMQ安装并启动</h1><p>具体安装步骤这里不再详述，可参考官网[<a href="http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行">http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行</a> <code>./activemq start</code>命令，即可启动MQ服务，如果启动服务需要指定配置文件，命令为 <code>./activemq start xbean:file:../conf/myConfig.xml</code>，不指定默认为conf目录下的activemq.xml。停止MQ服务的命令为 <code>./activemq stop</code>。</p>
<p>在conf目录下找到<code>activemq.xml</code>配置文件打开，里面包含如下内容,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里配置的是MQ服务的各种传输协议连接和默认端口。再往下会发现这行内容<code>&lt;import resource=&quot;jetty.xml&quot;/&gt;</code>，activemq.xml文件中导入了一个名为<code>jetty.xml</code>的配置文件，在conf目录下找到jetty.xml文件打开，里面配置了访问MQ服务web控制台的一些信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jettyPort&quot; class&#x3D;&quot;org.apache.activemq.web.WebConsolePort&quot; init-method&#x3D;&quot;start&quot;&gt;</span><br><span class="line">    &lt;!-- the default port number for the web console --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;0.0.0.0&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;8161&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>其中8161为web控制台端口，MQ服务启动后，浏览器中访问[<a href="http://localhost:8161/admin][3]%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%83%BD%E4%B8%BAadmin%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C">http://localhost:8161/admin][3]，输入用户名和密码，默认都为admin，即可看到如下页面，</a></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq2.png?x-oss-process=style/watermarking"></p>
<h1 id="3-编码实战"><a href="#3-编码实战" class="headerlink" title="3. 编码实战"></a>3. 编码实战</h1><p>ActiveMQ服务启动成功后，可以编写生产者客户端往MQ服务发送消息，消费者客户端从MQ服务获取消息。项目建好之后需要先引入ActiveMQ相关依赖，以gradle为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &#39;org.apache.activemq&#39;, name: &#39;activemq-all&#39;, version: &#39;5.15.9&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-点对点消息"><a href="#3-1-点对点消息" class="headerlink" title="3.1 点对点消息"></a>3.1 点对点消息</h2><h3 id="3-1-1-生产者"><a href="#3-1-1-生产者" class="headerlink" title="3.1.1 生产者"></a>3.1.1 生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂。这里传入ActiveMQ消息服务连接地址，并使用默认用户名和密码。</span></span><br><span class="line">        <span class="comment">// 也可使用ActiveMQConnectionFactory()构造器或者ActiveMQConnectionFactory(String userName, String password, String brokerURL)构造器，连接接信息全部使用默认值或者全部指定</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        <span class="comment">//2、通过工厂对象创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">//3、通过连接对象创建会话。第一个参数是否开启事务，第二参数指定签收类型</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4、通过会话对象创建目的地（队列或者主题）。这里创建了一个名为 &quot;queue001&quot; 的队列</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        <span class="comment">//5、通过会话对象创建生产者，并指定目的地</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line">        <span class="comment">//6、连续创建3条消息，并有生产者发送到消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">            System.out.println(textMessage.getJMSDestination());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息&quot;</span> + textMessage.getText() + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main()方法后，进入web控制台可以看到待消费消息有3条，入队消息有3条，说明消息已经成功发送至MQ服务器。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq3.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-2-消费者"><a href="#3-1-2-消费者" class="headerlink" title="3.1.2 消费者"></a>3.1.2 消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line">        connection.start();</span><br><span class="line">        Message message = consumer.receive();</span><br><span class="line">        <span class="keyword">while</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String text = ((TextMessage) message).getText();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            message = consumer.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者客户端编码过程与生产者基本一致，只不过一个是生产者发送调用<code>send()</code>方法，一个是消费者接收调用<code>receive()</code>方法。其中需要注意的是<code>receive()</code>方法是一个阻塞方法，接收不到消息会一直阻塞等待，并且调用<code>receive()</code>之前必须调用<code>connection.start()</code>启动连接，否者接收不到消息。<br>执行main()方法后，进入web控制台可以看到待消费消息变为0条，出队消息变为3条，并且有一个消费者，说明消息被消费成功。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq4.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-3-消息监听器实现异步非阻塞消费消息"><a href="#3-1-3-消息监听器实现异步非阻塞消费消息" class="headerlink" title="3.1.3 消息监听器实现异步非阻塞消费消息"></a>3.1.3 消息监听器实现异步非阻塞消费消息</h3><p>上面我们了解到<code>MessageConsumer#receive()</code>方法是个阻塞方法，实际开发中不可能一直去阻塞等待，可以为消费者对象设置消息监听器来实现异步非阻塞消费消息，修改消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line"><span class="comment">//        connection.start();</span></span><br><span class="line"><span class="comment">//        Message message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        while (message != null) &#123;</span></span><br><span class="line"><span class="comment">//            String text = ((TextMessage) message).getText();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;接收queue消息：&quot; + text);</span></span><br><span class="line"><span class="comment">//            message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line">        consumer.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String text = ((TextMessage) message).getText();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep为了使程序不退出</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMessageListener()</code>方法需要传入一个<code>MessageListener</code>实例对象，并实现<code>onMessage()</code>，这里使用的是lambda表达式。</p>
<h2 id="3-2-发布-订阅消息"><a href="#3-2-发布-订阅消息" class="headerlink" title="3.2 发布/订阅消息"></a>3.2 发布/订阅消息</h2><p>发布订阅消息与上面点对点消息的生产者与消费者编码一致，唯一要改变的是把消息目的地由queue改为topic。</p>
<ul>
<li>生产者<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME); </span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure></li>
<li>消费者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic &#x3D; session.createTopic(TOPIC_NAME);</span><br><span class="line">MessageConsumer consumer &#x3D; session.createConsumer(topic);</span><br><span class="line">...省略... </span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>1.在点对点消息示例中，当同时启动多个消费者时(即同时执行多次main()方法)，生产者发布的每条消息只能被其中一个消费者消费一次；<br>2.在发布/订阅消息示例中，消费者不能消费订阅主题之前的消息，当同时启动多个消费者时，生产者发布的每条消息可以同时被多个消费者消费；</p>
</blockquote>
<h1 id="4-传输协议"><a href="#4-传输协议" class="headerlink" title="4. 传输协议"></a>4. 传输协议</h1><h2 id="4-1-ActiveMQ默认支持的传输协议"><a href="#4-1-ActiveMQ默认支持的传输协议" class="headerlink" title="4.1 ActiveMQ默认支持的传输协议"></a>4.1 ActiveMQ默认支持的传输协议</h2><p>ActiveMQ出厂默认支持的传输协议有<code>tcp</code>、<code>amqp</code>、<code>stomp</code>、<code>mqtt</code>、<code>ws</code>，在<code>activemq.xml</code>配置文件可以找到这几种协议的配置，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于java开发后四种协议不经常使用，这里主要说一次tcp协议。tcp协议的client监听端口默认是61616，在网络上传输数据，必须序列化数据，消息是通过一个write protocol来序列化为字节流。默认情况 ActiveMQ会把wire protocol叫做Open Wire，它的目的是促使网络上的效率和数据快速交互。<br>tcp传输的优点：</p>
<ol>
<li>传输可靠性高、稳定性强</li>
<li>高效性：字节流方式传递，效率高</li>
<li>有效性、可用性：应用广泛，支持任何平台<br>tcp连接的URL形式如：<strong>tcp://hostname:port?key=value</strong>。更多协议的可配置参数请参考 <a href="http://activemq.apache.org/tcp-transport-reference">http://activemq.apache.org/tcp-transport-reference</a></li>
</ol>
<h2 id="4-2-使用NIO传输协议提供更好的性能"><a href="#4-2-使用NIO传输协议提供更好的性能" class="headerlink" title="4.2 使用NIO传输协议提供更好的性能"></a>4.2 使用NIO传输协议提供更好的性能</h2><p>使用tcp协议，每一个连接都会创建一个线程，当client连接较多时需要大量的系统开销，nio支持多个连接使用同一个线程，相比tcp需要更少的线程数。  </p>
<p>nio协议基于tcp协议之上进行了扩展和优化。要使ActiveMQ支持nio协议，只需要做少量的修改即可。打开<code>activemq.xml</code>配置文件，在<code>&lt;transportConnectors&gt;</code> 节点内添加，<code>&lt;transportConnector name=&quot;nio&quot; uri=&quot;nio://0.0.0.0:61617&quot;/&gt;</code>，同时客户端代码url连接形式要改为 <code>nio://hostname:port?key=value</code>，后面的可选参数与tcp协议一致。  </p>
<blockquote>
<p>tcp协议也好nio协议也好，都绑定了特定的端口，如何实现一个端口可以支持多种协议呢？ActiveMQ提供了一个auto协议，类似于一个适配器协议，在不改变端口的情况下可以切换协议。详细配置参考官方文档 <a href="http://activemq.apache.org/auto">http://activemq.apache.org/auto</a>  </p>
</blockquote>
<p>其他协议配置参见官网文档 <a href="http://activemq.apache.org/configuring-transports.html">http://activemq.apache.org/configuring-transports.html</a></p>
<h1 id="5-ActiveMQ消息高可用"><a href="#5-ActiveMQ消息高可用" class="headerlink" title="5 ActiveMQ消息高可用"></a>5 ActiveMQ消息高可用</h1><h2 id="5-1-消息持久化"><a href="#5-1-消息持久化" class="headerlink" title="5.1 消息持久化"></a>5.1 消息持久化</h2><h3 id="5-1-1-持久化编码"><a href="#5-1-1-持久化编码" class="headerlink" title="5.1.1 持久化编码"></a>5.1.1 持久化编码</h3><p>如果生产者把消息发送到了MQ消息服务，消费者还没有来得及消费，此时MQ服务停止或意外宕机，那么这些未被消费的消息改怎么处理呢？分为消息非持久化和消息持久化两种情况，<strong>消息非持久化</strong>这些未被处理的消息直接丢失，<strong>消息持久化</strong>会把这些未被消费的消息暂时存储起来，当MQ消息服务重新启动时恢复这些消息，消费者可以继续消费。</p>
<ul>
<li><strong>队列消息持久化</strong><br>基于上面的示例代码，只需要为生产者客户端代码添加一行通过MessageProducer对象设置就可以了。（队列消息默认开启持久化这一行实际上可以省略）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li>
<li><strong>主题消息持久化</strong><br>主题消息默认不持久化，支持主题消息持久化，只需要修改消费者客户端代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> ...</span><br><span class="line">connection.setClientID(<span class="string">&quot;client_0001&quot;</span>);</span><br><span class="line"> ...</span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">TopicSubscriber subscriber =  session.createDurableSubscriber(topic, <span class="string">&quot;remark...&quot;</span>);</span><br><span class="line">connection.start();</span><br><span class="line">subscriber.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先必须要通过<code>connection.setClientID(&quot;client_0001&quot;)</code>指定订阅者ID，因为如果不指定唯一ID,订阅者（非持久化订阅者）每次连接时都会随机创建一个ID，在消息持久化状态下，订阅者需要保证从离线到重新在线ClientID唯一不变，这样MQ消息服务才能确定主题消息是否被所有持久化订阅者消费了（如果MQ服务停止或宕机时，主题消息未被所有持久化订阅者消费的会被存储起来，已经被所有持久化订阅者消费的主题消息会直接丢弃）。  </p>
<p>然后通过<code>session.createDurableSubscriber(topic, &quot;remark...&quot;)</code>创建一个TopicSubscriber对象，告诉MQ服务其订阅的此主题消息要做持久化处理。</p>
<h3 id="5-1-2-持久化存储机制"><a href="#5-1-2-持久化存储机制" class="headerlink" title="5.1.2 持久化存储机制"></a>5.1.2 持久化存储机制</h3><p>ActiveMQ的消息持久化机制有JDBC、AMQ、KahaDB和LevelDB，无论使用哪种持久化方式，消息的存储逻辑都是一致的，就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等再试图将消息发送给接受者，成功则将消息从存储中删除，失败则继续尝试发送。MQ消息服务启动以后首先要检查指定的存储位置，如果有未发送成功的消息则需要把消息继续发送出去。下面分别介绍一下KahaDB与JDBC持久化机制。</p>
<ul>
<li><strong>KahaDB存储</strong><br>KahaDB是一个基于文件的持久性数据库，消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。KahaDB是目前默认的存储方式，可用于任何场景，提高了性能和恢复能力。在<code>activemq.xml</code>配置文件可查看其配置信息，更多的配置信息可参见官网 <a href="http://activemq.apache.org/kahadb">http://activemq.apache.org/kahadb</a></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>directory</code>这里指明了kahadb数据存储路径，默认为ActiveMQ安装目录下<code>/data/kahadb</code>，其中主要包含4类文件和一个lock：</p>
<ol>
<li><strong>db-<number>.log</strong>：kahaDB存储消息到预定大小（默认32M）的数据记录文件中，文件命名为db-<number>.log，当数据文件已满时，一个新的文件会随之创建，number数值也会随之递增，当不再有引用到数据文件中的消息时，文件会被删除或者归档；</li>
<li><strong>db.data</strong>：改文件包含了持久化的BTree索引，它是消息的索引文件，使用BTree作为索引指向db-<nubmer>.log里面存储的消息；</li>
<li><strong>db.free</strong>：记录当前db.data文件里哪些页面是空闲的，文件具体内容是所有空闲页的ID;</li>
<li><strong>db.redo</strong>：用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引；</li>
<li><strong>lock</strong>：文件锁，表示当前获得kahaDB读写权限的broker；  </li>
</ol>
<ul>
<li><strong>JDBC存储</strong><br>如果采用JDBC机制存储，需要准备一个第三方数据库，这里以MySql数据库为例，更多信息参考<a href="http://activemq.apache.org/jdbc-support">http://activemq.apache.org/jdbc-support</a></li>
</ul>
<p>1.首先将mysql数据库的驱动包<code>mysql-connector-java-5.1.41.jar</code>添加到<code>ActiveMQ安装目录/lib</code>目录下，用于连接mysql数据库；</p>
<p>2.打开<code>activemq.xml</code>配置文件，找到<code>&lt;beans&gt;</code>节点添加数据库连接池配置信息<code>dataSource</code> bean，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysql-ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>3.<code>activemq.xml</code>配置文件中找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt; </span><br><span class="line">    &lt;jdbcPersistenceAdapter dataSource&#x3D;&quot;#mysql-ds&quot; createTablesOnStartup&#x3D;&quot;true&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;persistenceAdapter&gt;</span><br></pre></td></tr></table></figure>
<p><code>mysql-ds</code>为上一步配置的beanId，<code>createTablesOnStartup</code>是否在启动的时候自动创建数据表，默认值是true，一般是第一次启动的时候设置为true之后再改为false。</p>
<p>上诉三步都配置完后，启动ActiveMQ服务会自动创建三张表，分别为<code>activemq_msgs</code>消息表，用于保存queue和topic消息， <code>activemq_acks</code>用于存储订阅关系，如果是持久化topic，订阅者和服务器的订阅关系在这个表保存，<code>activemq_lock</code>在集群环境中才有用，保证只有一个borker可以获取消息，用于记录哪个breker是当前的master broker。</p>
<p>JDBC每次消息过来都需要去写库和读库，ActiveMQ Journal使用高速缓存写入技术大大提高了性能，克服了JDBC Store的不足。当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息，比如生产者生产了1000条消息，这1000条消息会先保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的消息，那么这个时候只需要同步剩余的10%的消息到DB。</p>
<p>使用高效的Journal，需要修改持久化配置，打开<code>activemq.xml</code>配置文件，找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;persistenceFactory&gt;</span><br><span class="line">    &lt;journalPersistenceAdapterFactory journalLogFiles&#x3D;&quot;5&quot; dataDirectory&#x3D;&quot;activemq-data&quot; dataSource&#x3D;&quot;#mysql-ds&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;persistenceFactory&gt; </span><br></pre></td></tr></table></figure>

<h2 id="5-2-事务"><a href="#5-2-事务" class="headerlink" title="5.2 事务"></a>5.2 事务</h2><p>在上面的示例代码中，创建session时传了两个参数，<code>createSession(false, Session.AUTO_ACKNOWLEDGE)</code>，第一个参数表示<strong>是否开启事务</strong>，第二个参数表示<strong>签收方式</strong>。</p>
<p>当开启事务，即第一个参数为<code>true</code>时，对于生产者而言执行<code>send()</code>方法后，消息不会直接进入消息队列中（没有真正发送到MQ服务），只有执行<code>session.commit()</code>消息才会真正发送成功进入消息队列中；对于消费者而言，消费完消息后，只有执行了<code>session.commit()</code>消息才会从消息队列中出队，如果不执行<code>session.commit()</code>会导致消息被重复消费。</p>
<p>事务开启的意义在于，对于多条必须同批次传输的消息，如果有一条传输失败，可以将事务回滚，再次传输，保证数据的完整性。</p>
<h2 id="5-3-签收（ack）"><a href="#5-3-签收（ack）" class="headerlink" title="5.3 签收（ack）"></a>5.3 签收（ack）</h2><p>签收和事务起到的作用是一样的，事务的优先级高于签收，即如果开启了事务，签收方式不管是哪种都是不起作用的，一般事务倾向于生产者使用，签收倾向于消费者使用。</p>
<p>签收方式总共有4种，<code>AUTO_ACKNOWLEDGE</code>自动签收，<code>CLIENT_ACKNOWLEDGE</code>手动签收，<code>DUPS_OK_ACKNOWLEDGE</code>可重复的签收（不常用），<code>SESSION_TRANSACTED</code>一般表示开启了事务设置任何签收方式是无效的。</p>
<p>如果签收方式为<code>CLIENT_ACKNOWLEDGE</code>手动签收，必须执行<code>message.acknowledge()</code>，消息才能被真正的消费或者发送。</p>
<h1 id="6-高级特性"><a href="#6-高级特性" class="headerlink" title="6 高级特性"></a>6 高级特性</h1><h1 id="6-1-异步投递"><a href="#6-1-异步投递" class="headerlink" title="6.1 异步投递"></a>6.1 异步投递</h1><p>ActiveMQ支持以同步或异步模式向borker发送消息，所使用的模式对发送调用的延迟有很大的影响。由于延迟通常是生产者可以实现的吞吐量中的一个重要因素，因此使用异步发送可以显著提高系统的性能。</p>
<p>ActiveMQ默认以异步模式发送消息，以同步模式发送的情况是除非明确指定使用同步发送或者<strong>事务外部发送持久消息</strong>（即未使用事务的前提下发送持久化消息）。如果不使用事务，而是发送持久消息，那么每次发送都会同步并阻塞，直到broker向生产者发送确认消息已安全持久存储到磁盘为止，此确认机制提供了消息不会丢失的保证，但由于客户端被阻塞需要付出巨大的延迟代价。</p>
<p>异步投递可以最大化producer端的发送效率。通常在发送消息量比较密集的情况下使用异步发送，它可以很大的提升producer的吞吐量，不过这也带来了额外的问题，就是需要消耗很多的client端内存的同时也会导致broker端性能消耗增加，此外<strong>不能有效的确保消失的发送成功</strong>。在使用异步投递的情况下客户端需要容忍消息丢失的可能。</p>
<ul>
<li><p><strong>开启异步投递的三种方式</strong></p>
<ol>
<li><p>通过Connection URI后面添加参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://locahost:61616?jms.useAsyncSend=true&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ConnectionFactory对象属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Connection对象属性，在此级别配置将覆盖ConnectionFactory级别的设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>如何保证一部投递情况下消息不丢失</strong></p>
<p>异步发送消息丢失的情况场景是，UseAsyncSend为true，使用<code>producer.send(message)</code>持续发送消息，消息不会阻塞，生产者会认为所有的消息均会被发送到了MQ服务，如果MQ服务突然宕机，此时生产者端尚未同步到MQ服务的消息均会丢失。所以，正确的异步发送方法需要接收回调的。</p>
<p>同步发送和异步发送的区别就在于，同步发送<code>send()</code>不阻塞就代表消息发送成功，异步发送需要接收回调并由客户端再判断一次是否发送。异步投递编码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//producer.send(textMessage);</span></span><br><span class="line">            <span class="comment">//异步投递并确认消息发送结果</span></span><br><span class="line">            textMessage.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line">            String msgId = textMessage.getJMSMessageID();</span><br><span class="line">            ((ActiveMQMessageProducer) producer).send(textMessage, <span class="keyword">new</span> AsyncCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span> </span>&#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">                    <span class="comment">// 对于失败消息后续可以进行重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="6-2-定时与延时投递"><a href="#6-2-定时与延时投递" class="headerlink" title="6.2 定时与延时投递"></a>6.2 定时与延时投递</h2><p>有时候我们需要消息在某个时间点发送或者延迟一段时间发送。</p>
<p>ActiveMQ开启定时与延迟投递，首先编辑<code>activemq.xml</code>配置文件，<code>&lt;broker&gt;</code>标签内添加属性<code>schedulerSupport</code>并且设置为<code>true</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> <span class="attr">brokerName</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;$&#123;activemq.data&#125;&quot;</span> <span class="attr">schedulerSupport</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码中生产者端消息对象<code>message</code>，需要设置时间调度相关属性，主要属性如下：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AMQ_SCHEDULED_DELAY</td>
<td>long</td>
<td>延迟投递时间</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_PERIOD</td>
<td>long</td>
<td>重复投递时间间隔</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_REPEAT</td>
<td>int</td>
<td>重复投递次数</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_CRON</td>
<td>String</td>
<td>cron表达式</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//消息延迟3秒，每隔4秒重复发送，重复5次</span></span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, <span class="number">3000L</span>);</span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, <span class="number">4000L</span>);</span><br><span class="line">            textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, <span class="number">5</span>); <span class="comment">//（加上第一次实际上总共6次）</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>更多介绍参考官网 <a href="http://activemq.apache.org/delay-and-schedule-message-delivery">http://activemq.apache.org/delay-and-schedule-message-delivery</a></p>
<h2 id="6-3-消费者消息重试策略"><a href="#6-3-消费者消息重试策略" class="headerlink" title="6.3 消费者消息重试策略"></a>6.3 消费者消息重试策略</h2><p>当下列任何一种情况发生时，borker会将消息重新传送至消费端:</p>
<ul>
<li>使用事务会话并调用<code>rollback()</code>；</li>
<li>使用事务会话调用<code>commit()</code>之前关闭已处理的会话；</li>
<li>在手动签收<code>CLIENT_ACKNOWLEDGE</code>传递模式下调用<code>session.recover()</code>；</li>
<li>客户机连接超时(可能正在执行的代码比配置的超时时间更长)。</li>
</ul>
<p>默认重发时间间隔为1秒总共重发6次，超过6次即最大重发次数后，消费端会给broker返送一个<code>poison ack</code>表示这个消息有毒，告诉broker不要再发了，这个时候broker会把这个消息放到DLQ（死信队列），以便稍后对其进行分析并人工干预处理。</p>
<p>定义重发策略，编码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        ActiveMQConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        RedeliveryPolicy policy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        policy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        policy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        policy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        policy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        connectionFactory.setRedeliveryPolicy(policy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从ActiveMQ v5.7.0开始，可以在每个目的地的基础上配置RedeliveryPolicy,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">true</span>, Session.CLIENT_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        </span><br><span class="line">        RedeliveryPolicy queuePolicy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        queuePolicy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        queuePolicy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        queuePolicy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        queuePolicy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        RedeliveryPolicyMap redeliveryPolicyMap =((ActiveMQConnection)connection).getRedeliveryPolicyMap();</span><br><span class="line">        redeliveryPolicyMap.put((ActiveMQQueue)queue, queuePolicy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>常用重发策略配置如下：<br>|属性名称   |默认值   |描述   |<br>| ———— | ———— | ———— |<br>|collisionAvoidanceFactor|    0.15|设置防止冲突范围的正负百分比，只有启用useCollisionAvoidance参数时才生效。也就是在延迟时间上再加一个时间波动范围|<br>|initialRedeliveryDelay|    1000L|    初始重发延迟时间|<br>|maximumRedeliveries|    6|最大重发次数，达到最大重发次数后消息进入死信队列。为-1时不限制次数，为0时表示不进行重发|<br>|maximumRedeliveryDelay|    -1|    最大重发延迟时间，只有useExponentialBackOff为true时有效（v5.5）。假设首次重发间隔为10ms，倍数为2，那么第二次重发时间间隔为20ms，第三次时间间隔为40ms，当重发时间间隔的达到最大传送延迟时间，以后每次重发时间间隔都为最大传送延迟时间。为-1时不限制最大时间间隔<br>|redeliveryDelay|    1000L | 重发延迟时间，当initialRedeliveryDelay=0生效|<br>|useCollisionAvoidance|    false|启用防止冲突功能|<br>|useExponentialBackOff|    false|启用指数倍数递增的方式增加延迟时间|<br>|backOffMultiplier|    5|重发时间间隔递增倍数，只有值大于1和启用useExponentialBackOff参数时才生效|<br>更多重发介绍参考官网 <a href="http://activemq.apache.org/redelivery-policy">http://activemq.apache.org/redelivery-policy</a></p>
<p>ActiveMQ中的默认死信队列名称为<code>ActiveMQ.DLQ</code>，所有无法交付的消息都将被发送到这个队列，这可能很难管理，因此，你也可以在<code>activemq.xml</code>配置文件为每个目的地配置单独的死信队列，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单独为每个queue目的地设置一个死信队列，前缀为DLQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Set the following policy on all queues using the &#x27;&gt;&#x27; wildcard --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Use the prefix &#x27;DLQ.&#x27; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">&quot;DLQ.&quot;</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>死信队列详细介绍参考官网 <a href="http://activemq.apache.org/message-redelivery-and-dlq-handling">http://activemq.apache.org/message-redelivery-and-dlq-handling</a></p>
<h1 id="7-内嵌broker"><a href="#7-内嵌broker" class="headerlink" title="7 内嵌broker"></a>7 内嵌broker</h1><p>使用spring boot开发web应用的时候，spring boot提供了内嵌的tomcat或者jetty服务器，使用内嵌服务器运行项目时就不用再单独启动一个servlet服务器了，类似的ActiveMQ也提供了一个内嵌broker，使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.broker.BrokerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbedBroker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">        brokerService.setUseJmx(<span class="keyword">true</span>);</span><br><span class="line">        brokerService.addConnector(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        brokerService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细介绍参考官网 <a href="https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html">https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html</a></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（二）——方法引用</title>
    <url>/20190202/lambda2/076a298db052.html</url>
    <content><![CDATA[<p>当我们在使用lambda去表示某个函数式接口的实例时，需要在lambda表达式的主体里去编写函数式接口抽象方法的实现，如果在现有的类中已经存在与抽象方法类似的方法了，我们希望直接引用现有的方法，而不用再去重新写实现了。方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。</p>
<p>方法引用和lambda表达式拥有相同的特性，它们都需要代表一个<strong>目标类型</strong>，并需要被转化为函数式接口的实例，不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法方。<strong>法引用要使用到操作符 “::”，左边是类名或者对象名，右边是方法名或者关键字<code>new</code></strong></p>
<p>首先被引用方法的返回值类型要和函数式接口抽象方法的返回值类型一致，至于参数列表要根据每种引用方式而定。</p>
<a id="more"></a>

<h1 id="1-静态方法引用"><a href="#1-静态方法引用" class="headerlink" title="1. 静态方法引用"></a>1. 静态方法引用</h1><p>语法：<code>ClassName::staticMethodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = x -&gt; Long.valueOf(x);</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = Long::valueOf;</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>静态方法引用时，静态方法要与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="2-对象方法引用"><a href="#2-对象方法引用" class="headerlink" title="2. 对象方法引用"></a>2. 对象方法引用</h1><p>语法：<code>ClassName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = (s) -&gt; s.length();</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = String::equals;</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = String::length;</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>对象方法引用时，函数式接口抽象方法的第一个参数是被引用方法的调用者，第二个参数(或者无参)是被引用方法的参数</strong></p>
<h1 id="3-外部对象方法引用"><a href="#3-外部对象方法引用" class="headerlink" title="3. 外部对象方法引用"></a>3. 外部对象方法引用</h1><p>语法：<code>objectName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">Predicate&lt;String&gt; p = (s) -&gt; list.contains(s);</span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; p = list::contains; </span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>外部对象方法引用时，被引用方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4. 构造器引用"></a>4. 构造器引用</h1><p>语法：<code>ClassName::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = (millisecond) -&gt; <span class="keyword">new</span> Date(millisecond);</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = Date::<span class="keyword">new</span>;</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>
<p><strong>构造器引用时，被引用的构造方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5. 数组引用"></a>5. 数组引用</h1><p>语法：<code>Type[]::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = n -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>数组引用时，函数式接口抽象方法参数(数值型)即为数组初始化大小值</strong></p>
]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（一）——函数式接口</title>
    <url>/20190201/lambda1/c673d3a38bb1.html</url>
    <content><![CDATA[<h2 id="1-什么是lambda"><a href="#1-什么是lambda" class="headerlink" title="1.什么是lambda?"></a>1.什么是lambda?</h2><p>如果我们想要起一个线程来打印一串字符串，我们之前的写法通常是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式后，可以改写为这个样：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>我们可以看到使用lambda表达式后，代码变得更加简洁，这里的 “<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>“ 其实就相当于Runnable接口的匿名实现，你会发现Runnable的抽象方法<code>run()</code>的签名与<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>的签名是一致的（lambda表达式的签名下面会讲到）。简而言之，可以把Lambda表达式理解为<strong>简洁地表示可传递的匿名函数的一种方式，它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</strong></p>
<p>lambda表达式由三部分构成：<strong>参数列表</strong>、**-&gt;(分割符)<strong>、</strong>主体**，基本语法如下：<br><code>(parameters) -&gt; expression</code> 或者 <code>(parameters) -&gt; &#123; statements; &#125;</code></p>
<ul>
<li>参数列表：多个参数用逗号隔开，类型可以省略不写，要保证与函数式接口抽象方法的参数列表一致，如果只有一个参数”()”可以省略；</li>
<li>箭头（-&gt;）: 用于分割参数列表和主体；</li>
<li>主体：可以直接是表达式，有多条语句要用花括号括起来，如果lambda需要返回一个值，那么返回值即使expression本身所表示的值，如有使用的“{}”，需要用return关键字返回具体值。  </li>
</ul>
<p>Lambda的类型是从使用Lambda的上下文推断出来的，上下文中Lambda表达式所需要代表的类型称为<strong>目标类型</strong>，如上示例中 “<code>() -&gt; System.out.println(&quot;hello world!&quot;)</code>” 代表的是Runnable类型的实例，所以相同的lambda表达式在不同的上下文中可能代表不同类型的函数式接口</p>
<h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h2><p>假设上面的示例中，如果Runnable接口有两个抽象方法run()和run2()，那么lambda表达式该怎么表示呢，相当于重写了哪个方法呢？这种情况是不能使用lambda表达式的，只有在使用了函数式接口的地方才能使用lambda表达式，所以这里要说一下函数是接口的定义。所谓函数式接口，即：<strong>只有一个抽象方法的接口</strong>。 Java8已经为我们提供了一些常用的函数式接口，如下表：</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>函数描述符</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate&lt;T&gt;</td>
<td>T-&gt;boolean</td>
<td>IntPredicate,<br/>LongPredicate,<br/>DoublePredicate</td>
</tr>
<tr>
<td>Consumer</td>
<td>T-&gt;void</td>
<td>IntConsumer,<br/>LongConsumer,<br/>DoubleConsumer</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T-&gt;R</td>
<td>IntFunction,<br/>IntToDoubleFunction,<br/>IntToLongFunction,<br/>LongFunction,<br/>LongToDoubleFunction,<br/>LongToIntFunction,<br/>DoubleFunction,<br/>ToIntFunction,<br/>ToDoubleFunction,<br/>ToLongFunction</td>
</tr>
<tr>
<td>Supplier</td>
<td>()-&gt;T</td>
<td>BooleanSupplier,<br/>IntSupplier,<br/>LongSupplier,<br/>DoubleSupplier</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>T-&gt;T</td>
<td>IntUnaryOperator,<br/>LongUnaryOperator,<br/>DoubleUnaryOperator</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>(T,T)-&gt;T</td>
<td>IntBinaryOperator,<br/>LongBinaryOperator,<br/>DoubleBinaryOperator</td>
</tr>
<tr>
<td>BiPredicate&lt;L,R&gt;</td>
<td>(L,R)-&gt;boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>(T,U)-&gt;void</td>
<td>ObjIntConsumer,<br/>ObjLongConsumer,<br/>ObjDoubleConsumer</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>(T,U)-&gt;R</td>
<td>ToIntBiFunction&lt;T,U&gt;,<br/>ToLongBiFunction&lt;T,U&gt;,<br/>ToDoubleBiFunction&lt;T,U&gt;</td>
</tr>
</tbody></table>
<p> 函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，我们将这种抽象方法叫作<strong>函数描述符</strong>，比如 “<code>T-&gt;boolean</code>“ 表示传入一个T类型的参数并返回boolean类型的值。</p>
<p> <strong>原始类型特化</strong>是在某个函数是接口上，把输入或输出参数特化为原始类型，这样就避免了拆装箱操作，以提高性能。例如 <code>IntPredicate</code> 把输入参数特化为<code>int</code>类型，ToLongFunction把返回值特化为<code>long</code>类型。</p>
<blockquote>
<p>查看上表函数式接口的源码，会发现它们都有一个 <code>@FunctionalInterface</code> 注解，这是Java8提供的用来表示接口是否为函数式接口，但它不是必须的，只要接口只包含一个抽象方法就是函数式接口，只是如果接口上加上了<code>@FunctionalInterface</code>注解，那么往接口中添加其他抽象方法时编译就会报错，起到一个限定作用；  </p>
</blockquote>
<blockquote>
<p>特殊的void兼容规则<br>   如果一个Lambda的主体是一个语句表达式(expression)，它就和一个返回void的函数描述符兼容（当然需要参数列表一致）。例如，以下两行都是合法的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -&gt; void）所要求的void：<br>   // Predicate返回了一个boolean<br>   Predicate<String> p = s -&gt; list.add(s);<br>   // Consumer返回了一个void<br>   Consumer<String> b = s -&gt; list.add(s);  </p>
</blockquote>
<h2 id="3-lambda使用局部变量的限制"><a href="#3-lambda使用局部变量的限制" class="headerlink" title="3.lambda使用局部变量的限制"></a>3.lambda使用局部变量的限制</h2><p>lambda可以没有限制的在主体中引用实例变量和静态变量，但是引用的局部变量必须声明为<code>final</code>或者事实上是<code>final</code>。因为成员变量存储在堆中，而局部变量保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在另一个线程中使用的，则使用Lambda的线程时，可能会在分配该局部变量的线程将这个变量收回之后去访问该变量。因此，Java在访问局部变量时，实际上是在访问它的副本，而不是访问原始变量，如果局部变量仅仅赋值一次,那么副本和原始变量就没有什么区别了——因此就有了这个限制，要保证副本和原始值保持一致。<br>例如下面的代码，如果把 “//name = “jack”;” 注释去掉，就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">String name = <span class="string">&quot;tome&quot;</span>;</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello &quot;</span> + name));</span><br><span class="line"><span class="comment">//name = &quot;jack&quot;;</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射基础运用</title>
    <url>/20190101/reflect/b01167aa3bca.html</url>
    <content><![CDATA[<h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h2><p>反射是指在程序运行时期可以动态的加载类并访问、检测和修改对象的一种能力。 那为什么要使用反射呢？编程时一般会遇到这种情况，编译时期无法确定对象类型，只有在运行时期才能确定，比如Spring的配置中就大量使用了反射机制。通过反射能够获取到类的一切信息，访问到对象的一切属性和方法，包括private修饰的属性和方法。  </p>
<a id="more"></a>

<p>Class类与java.lang.reflect类库一起对反射进行了支持。 java.lang.reflect类库包含了Field、Method、Constructor等类，Field类：关联一个字段，Field对象可以对该字段进行操作，比如用Field的set()和get()方法可以获取和修改关联字段的值；Method类：关联一个方法，用Metond的invoke()方法可以调用Method对象关联的方法；Constructor类： 关联构造器方法，调用Constructor类的newInstance()用来创建对象。而这三个类都可以通过Class对象获得。</p>
<h2 id="2-Class类介绍"><a href="#2-Class类介绍" class="headerlink" title="2.Class类介绍"></a>2.Class类介绍</h2><p>在学习使用反射之前，我们先来了解一下Class类。什么是Class类呢？我们不妨先把Java中的对象分为两种，一种是我们通常自己定义的类型对象，即“常规”对象，另一种是class对象，而每一个类在编译是都会产生一个class对象（被保存在一个同名的.class文件中），在Java程序运行时，可以通过Class对象获得对应类型的一切信息，比如该类有哪些方法、哪些构造方法、是不是接口等信息，是一个类型的描述对象。实际上Class类也是一个普通类，但是它的对象记录着对应类的一切信息，甚至该类的所有对象也都是有他的class对象完成创建的。</p>
<h2 id="2-1-如何获取class对象"><a href="#2-1-如何获取class对象" class="headerlink" title="2.1 如何获取class对象"></a>2.1 如何获取class对象</h2><p>每一个类都会存在一个唯一的Class对象，那么该如何获取Class对象呢？ 有三种方式：    </p>
<ul>
<li><strong>Class.forName(“类全名字符串”)</strong>  </li>
<li><strong>实例对象.getClass()</strong>  </li>
<li><strong>类名.class (此方式来创建Class对象时，不会自动的初始化该Class对象)</strong>  </li>
</ul>
<p>对于基本类型也存在Class对象，基本类型的包装器类型都有一个标准字段TYPE，此TYPE字段就是对应基本类型的class对象的引用。  </p>
<h3 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h3><p>首先创建一个Student类（后续示例都延用此类）：</p>
<figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">      <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在学习：&quot;</span> + course);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在睡觉zzz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123; name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age + <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*第一种方式：Class.forName(&quot;类全名&quot;)*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            studentClass1 = Class.forName(<span class="string">&quot;com.taicw.code.Student&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类型不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第二中种方式：类名.class*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第三种方式：实例对象.getClass()*/</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Class&lt;?&gt; studentClass3 = student.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;三种方式获取的Class对象是否为同一个? &quot;</span> +</span><br><span class="line">                (studentClass1 == studentClass2 &amp;&amp; studentClass2 == studentClass3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.class ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer.TYPE == Integer.class ? &quot;</span> + (Integer.TYPE == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.TYPE ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.TYPE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">三种方式获取的Class对象是否为同一个? true</span></span><br><span class="line"><span class="comment">int.class == Integer.class ? false</span></span><br><span class="line"><span class="comment">Integer.TYPE == Integer.class ? false</span></span><br><span class="line"><span class="comment">int.class == Integer.TYPE ? true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h3 id="2-3-类型判断"><a href="#2-3-类型判断" class="headerlink" title="2.3 类型判断"></a>2.3 类型判断</h3><p>在程序运行时期，我们拿到Class对象后，可能还会需要判断一个对象的类型，根据不同的类型做不同的逻辑处理，判断类型的方式有三种，下面比较一下三种方式的不同点和使用：</p>
<table>
<thead>
<tr>
<th></th>
<th>instanceof</th>
<th>isInstance</th>
<th>isAssignableFrom</th>
</tr>
</thead>
<tbody><tr>
<td>表现形式</td>
<td>关键字</td>
<td>方法</td>
<td>方法</td>
</tr>
<tr>
<td>使用方法</td>
<td>obj instanceof Type</td>
<td>class.isInstance(obj)</td>
<td>class1.isAssignableFrom(class2)</td>
</tr>
<tr>
<td>作用</td>
<td>Java的关键字，用于判断一个对象（obj）是否为一个类（Type）或者该类的子类的实例</td>
<td>Class类对象的一个方法，判断一个对象是否是该Class对象所表示的类或其子类的实例。</td>
<td>Class类对象的一个方法，其参数也是Class类的对象，用于判断class1是否与class2对象为同一类型或class2的超类或接口。</td>
</tr>
</tbody></table>
<h2 id="3-反射的基本使用"><a href="#3-反射的基本使用" class="headerlink" title="3.反射的基本使用"></a>3.反射的基本使用</h2><h3 id="3-1-获取构造器信息并创建实例"><a href="#3-1-获取构造器信息并创建实例" class="headerlink" title="3.1 获取构造器信息并创建实例"></a>3.1 获取构造器信息并创建实例</h3><p>上面已经说了任何类型的对象实际上就是其对应的Calss对象创建，那么我们拿到了class对象后该如何去创建一个对象呢？  </p>
<p><strong>第一种方式：通过Class对象的newInstance()方法来创建对应类型的实例对象。</strong> class对象的newInstance()方法使用的是对应类型的默认构造方法（无参构造方法），所以该方式必须要保证Class对应类型必须要有一个无参构造方法。那么如果我们需要使用有参构造方法怎么办呢？还有另一种方式。<br><strong>第二种：先通过Class对象获取相关的Constructor对象（每一个构造方法对应一个Constructor对象），再调用Constructor对象的newInstance()方法来创建实例。</strong> 通过Class对象获取构造器对象主要有一下几个方法：  </p>
<ul>
<li><p>public Constructor&lt;?&gt;[] <code>getConstructors()</code>：获取Class对象关联类型的所有public修饰的构造器对  </p>
</li>
<li><p>public Constructor&lt;?&gt;[] <code>getDeclaredConstructors()</code>：获取Class对象关联类型的所有构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的public修饰的构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的构造器对象（包括任意限定符修饰的构造方法） </p>
</li>
<li><p>public T <code>newInstance(Object ... initargs)</code>：获取构造器对象后，调用该方法并按顺序传入参数对象来创建实例  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Class对象的newInstance()方法创建实例*/</span></span><br><span class="line">        Student zhangsan =  studentClass.newInstance();</span><br><span class="line">        System.out.println(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Constructor对象的newInstance()方法创建实例*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的public构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allPublicConstructors = studentClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allPublicConstructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allConstructors = studentClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPublicConstructor = studentClass.getConstructor(String.class);</span><br><span class="line">        Student lisi = studentPublicConstructor.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定public构造器对象来创建关联类型实例：&quot;</span> + lisi);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPrivateConstructor = studentClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        studentPrivateConstructor.setAccessible(<span class="keyword">true</span>); <span class="comment">/*调用是由构造器之前需要设置访问标志为true*/</span></span><br><span class="line">        Student wangwu = studentPrivateConstructor.newInstance(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定private构造器对象来创建关联类型实例：&quot;</span> + wangwu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">&#123; name:张三, age:18 &#125;</span></span><br><span class="line"><span class="comment">获取所有的public构造器对象：</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">获取所有的构造器对象：</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(java.lang.String,int)</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(int)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">根据参数类型获取指定public构造器对象来创建关联类型实例：&#123; name:李四, age:0 &#125;</span></span><br><span class="line"><span class="comment">根据参数类型获取指定private构造器对象来创建关联类型实例：&#123; name:王五, age:20 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-获取Method信息并调用其关联方法"><a href="#3-2-获取Method信息并调用其关联方法" class="headerlink" title="3.2 获取Method信息并调用其关联方法"></a>3.2 获取Method信息并调用其关联方法</h3><p>通过Class对象获取Method对象主要有以下几个方法：  </p>
<ul>
<li><p>public Method[] <code>getMethods()</code>：获取关联类型的所有公有（public）方法对象，包括其父类的所有公有方法对象  </p>
</li>
<li><p>public Method[] <code>getDeclaredMethods()</code>：获取关联类型的所有方法（包括public、protected、default、private修饰的方法）对象，但不包括其父类的方法对象  </p>
</li>
<li><p>public Method <code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的公有方法对象  </p>
</li>
<li><p>public Method <code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的所有(不包含父类)方法对象  </p>
</li>
<li><p>public Object <code>invoke(Object obj, Object... args)</code>：通过Method对象来执行指定对象的方法，第一个参数为要执行该方法的对象，后面为方法参数，按顺序传入  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        Method[] allPublicMethods = studentClass.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allPublicMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] allMethods = studentClass.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method publicMethod = studentClass.getMethod(<span class="string">&quot;study&quot;</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的公有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(publicMethod);</span><br><span class="line"></span><br><span class="line">        Method privateMethod = studentClass.getDeclaredMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的私有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(privateMethod);</span><br><span class="line"></span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line">        publicMethod.invoke(obj,<span class="string">&quot;English&quot;</span>);</span><br><span class="line"></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>); <span class="comment">/*访问私有方法前，需要设置访问标志为true*/</span></span><br><span class="line">        privateMethod.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的公有method对象：</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的私有method对象：</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">我正在学习：English</span></span><br><span class="line"><span class="comment">我正在睡觉zzz</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取Field信息并操作其关联属性"><a href="#3-3-获取Field信息并操作其关联属性" class="headerlink" title="3.3 获取Field信息并操作其关联属性"></a>3.3 获取Field信息并操作其关联属性</h3><p>通过Class对象获取Field对象主要有以下几个方法：  </p>
<ul>
<li><p>public Field[] <code>getFields()</code>：获取关联类型的所有公有（public）属相对象，包括其父类的所有公有属性  </p>
</li>
<li><p>public Field[] <code>getDeclaredFields()</code>：获取关联类型的所有属性（包括public、protected、default、private修饰的属性）对象，但不包括其父类的属性  </p>
</li>
<li><p>public Field <code>getField(String name)</code>：根据属性名称获取指定的公有属性对象  </p>
</li>
<li><p>public Field <code>getDeclaredField(String name)</code>：根据属性名称获取任意的属性对象，但不包括父类的属性  </p>
</li>
</ul>
<ul>
<li><p>public void <code>set(Object obj, Object value)</code>：获取Field对象后，为指定对象属性赋值  </p>
</li>
<li><p>public Object <code>get(Object obj)</code>：通过Field对象，获取指定对象的属性值  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line"></span><br><span class="line">        Field[] allPublicFields =  studentClass.getFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allPublicFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] allFields = studentClass.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取公有(public)属性，包括获取其父类的公有属性*/</span></span><br><span class="line">        Field namePublicField = studentClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        namePublicField.set(obj, <span class="string">&quot;李哈哈&quot;</span>);</span><br><span class="line">        String name = (String)namePublicField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取公有属性name：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取任意属性，不能获取父类的属性*/</span></span><br><span class="line">        Field agePrivateField = studentClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        agePrivateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        agePrivateField.set(obj, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">int</span> age = (<span class="keyword">int</span>)agePrivateField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取私有属性age：&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射设置并获取属性信息：&quot;</span> + obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">private int com.taicw.code.Student.age</span></span><br><span class="line"><span class="comment">反射获取公有属性name：李哈哈</span></span><br><span class="line"><span class="comment">反射获取私有属性age：18</span></span><br><span class="line"><span class="comment">通过反射设置并获取属性信息：&#123; name:李哈哈, age:18 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
