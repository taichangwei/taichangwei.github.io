<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM系列之字节码与类加载（三）</title>
    <url>/20200516/jvm3/930a6a3ca61e.html</url>
    <content><![CDATA[<p>类加载与字节码技术 :</p>
<ol>
<li>类文件结构</li>
<li>节码指令</li>
<li>编译期处理</li>
<li>加载阶段</li>
<li>类加载器</li>
<li>运行期优化  </li>
</ol>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/00.png?x-oss-process=style/watermarking"></p>
<h1 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h1><p>Class文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中。</p>
<a id="more"></a>

<p>一个简单的java源码文件，Helloworld.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 “<code>javac HelloWorld.java</code>“ 编译后，生成 Helloworld.class 文件，字节码内存如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cafe babe 0000 0034 001d 0a00 0600 0f09</span><br><span class="line">0010 0011 0800 120a 0013 0014 0700 1507</span><br><span class="line">0016 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 046d 6169</span><br><span class="line">6e01 0016 285b 4c6a 6176 612f 6c61 6e67</span><br><span class="line">2f53 7472 696e 673b 2956 0100 0a53 6f75</span><br><span class="line">7263 6546 696c 6501 000f 4865 6c6c 6f57</span><br><span class="line">6f72 6c64 2e6a 6176 610c 0007 0008 0700</span><br><span class="line">170c 0018 0019 0100 0c48 656c 6c6f 2077</span><br><span class="line">6f72 6c64 2107 001a 0c00 1b00 1c01 000a</span><br><span class="line">4865 6c6c 6f57 6f72 6c64 0100 106a 6176</span><br><span class="line">612f 6c61 6e67 2f4f 626a 6563 7401 0010</span><br><span class="line">6a61 7661 2f6c 616e 672f 5379 7374 656d</span><br><span class="line">0100 036f 7574 0100 154c 6a61 7661 2f69</span><br><span class="line">6f2f 5072 696e 7453 7472 6561 6d3b 0100</span><br><span class="line">136a 6176 612f 696f 2f50 7269 6e74 5374</span><br><span class="line">7265 616d 0100 0770 7269 6e74 6c6e 0100</span><br><span class="line">1528 4c6a 6176 612f 6c61 6e67 2f53 7472</span><br><span class="line">696e 673b 2956 0021 0005 0006 0000 0000</span><br><span class="line">0002 0001 0007 0008 0001 0009 0000 001d</span><br><span class="line">0001 0001 0000 0005 2ab7 0001 b100 0000</span><br><span class="line">0100 0a00 0000 0600 0100 0000 0100 0900</span><br><span class="line">0b00 0c00 0100 0900 0000 2500 0200 0100</span><br><span class="line">0000 09b2 0002 1203 b600 04b1 0000 0001</span><br><span class="line">000a 0000 000a 0002 0000 0003 0008 0004</span><br><span class="line">0001 000d 0000 0002 000e </span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个字符代表一个十六进制数，每两位占一个字节</p>
</blockquote>
<p>根据 JVM 规范，<strong>类文件结构</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列为数据类型，数据类型分为两类<strong>无符号数</strong>和<strong>表</strong><ul>
<li>无符号数：属于基本的数据类型，以u1、u2、u4、u8 分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值</li>
<li>表：是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表都习惯以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表 </li>
</ul>
</li>
<li>第二列为Class文件结构各个组成项的名称</li>
</ul>
<h2 id="1-1-魔数-magic"><a href="#1-1-魔数-magic" class="headerlink" title="1.1 魔数(magic)"></a>1.1 魔数(magic)</h2><p><strong>u4   magic</strong>，表示它是否是【class】类型的文件，第0~3个字节来表示 </p>
<p><strong>cafe babe</strong> 0000 0034 001d 0a00 0600 0f09</p>
<h2 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h2><p><strong>u2   minor_version</strong>，次版本，第 4~5个字节表示</p>
<p><strong>u2   major_version</strong>， 主版本，第 5~7个字节表示</p>
<p>cafe babe <strong>0000 0034</strong> 001d 0a00 0600 0f09，这里的版本号为0x00000034(52)，代表JDK1.8</p>
<h2 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h2><p><strong>u2   constant_pool_count</strong>，常量池大小，第 8~9 个字节表示</p>
<p>cafe babe 0000 0034 <strong>001d</strong> 0a00 0600 0f09，这里的常量池大小为0x001d(29)，表示常量池表共有#1~#28项，注意 #0 项不计入也没有值  </p>
<p>**cp_info   constant_pool[constant_pool_count-1]**，是一个结构表，表示各种字符串常量、类和接口名、字段名以及在类文件结构及其子结构中引用的其他常量，constant_pool表的索引从1到constant_pool_count - 1。</p>
<blockquote>
<p>常量池不仅仅存放放在程序中定义的常量，还包含编译后的类名、方法名等等</p>
</blockquote>
<p>constant_pool表中的每一项都必须以一个1字节的标记(tag)开始，以指示cp_info条目的类型，每个标记字节后面必须跟着两个或更多的字节，以提供关于特定常量的信息。附加信息的格式随标签值的不同而不同。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(tag)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
<td>双精度浮点字面量</td>
</tr>
<tr>
<td>CONSTANT_Class</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
<td>字段或方法名称符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
<td>18</td>
<td>表示一个动态的方法调用点</td>
</tr>
</tbody></table>
<p>cafe babe 0000 0034 001d <strong>0a</strong><code>00 0600 0f</code>09，常量池大小字节(001d)后紧接着就是常量池的第一项 #1，tag=0x0a(10) 可知常量类型是 <code>CONSTANT_Methodref</code>，其结构如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag; //标志,值10</span><br><span class="line">    u2 class_index; //是constant_pool表的有效索引，且类型是CONSTANT_Class。表示该方法所属类</span><br><span class="line">    u2 name_and_type_index; //必须是constant_pool表的有效索引，且类型必须是CONSTANT_NameAndType。表示该方法名称</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class_index=0x00 06(6) 引用了常量池中的第#6项，name_and_type_index=0x000f(15) 引用了常量池中的第#15项。</p>
<p>第一项#1之后是常量池第二项#2，cafe babe 0000 0034 001d 0a00 0600 0f<strong>09</strong> <code>0010 0011</code> 0800 120a 0013 0014 0700 1507，由tag=0x09(9) 可知常量类型是 <code>CONSTANT_Fieldref</code>, 根据该类型结构可知后面4个字节分别为常量池表的有效索引，紧接着#3，#4、#5…分析过程相同。</p>
<blockquote>
<p>每种常量类型结构，参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4</a></p>
</blockquote>
<h2 id="1-4-其他类文件结构项"><a href="#1-4-其他类文件结构项" class="headerlink" title="1.4 其他类文件结构项"></a>1.4 其他类文件结构项</h2><p>参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1</a></p>
<h2 id="1-5-javap-工具"><a href="#1-5-javap-工具" class="headerlink" title="1.5 javap 工具"></a>1.5 javap 工具</h2><p>上面的分析过程过于繁琐，JDK提供了一个专门用于分析Class文件字节码的工具：<strong>javap</strong>。</p>
<p>执行<code>javap -v HelloWorld.class </code>，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">Classfile &#x2F;E:&#x2F;code&#x2F;HelloWorld.class</span><br><span class="line">  Last modified 2020-01-20; size 426 bytes</span><br><span class="line">  MD5 checksum 7a3ee81e13319873b7ac05812c3e5571</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #6.#15         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #16.#17        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #3 &#x3D; String             #18            &#x2F;&#x2F; Hello world!</span><br><span class="line">   #4 &#x3D; Methodref          #19.#20        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">   #5 &#x3D; Class              #21            &#x2F;&#x2F; HelloWorld</span><br><span class="line">   #6 &#x3D; Class              #22            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               main</span><br><span class="line">  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               HelloWorld.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #17 &#x3D; NameAndType        #24:#25        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #18 &#x3D; Utf8               Hello world!</span><br><span class="line">  #19 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #20 &#x3D; NameAndType        #27:#28        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #21 &#x3D; Utf8               HelloWorld</span><br><span class="line">  #22 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #24 &#x3D; Utf8               out</span><br><span class="line">  #25 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #26 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #27 &#x3D; Utf8               println</span><br><span class="line">  #28 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String Hello world!</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><strong>字节码指令</strong>(java虚拟机的指令) 是由一个字节长度的、代表着某种特定操作含义的数字(称为<strong>操作码</strong>或<strong>指令</strong>，Opcode) 以及跟随其后的零至多个代表操作所需参数(称为<strong>操作数</strong>，Operands)而构成。</p>
<blockquote>
<p>指令由一个字节表示，由此可知指令最多不超过256个，java虚拟机已经定义了约200条指令，每个指令介绍参见：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
</blockquote>
<p>java程序<strong>方法体中的代码</strong>经过javac编译处理后，最终变为<strong>字节码指令存储在Code属性中</strong>。Code属性是method_info结构的属性表中的可变长度属性</p>
<h2 id="2-2-图解方法执行流程"><a href="#2-2-图解方法执行流程" class="headerlink" title="2.2 图解方法执行流程"></a>2.2 图解方法执行流程</h2><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译 <code>javap -v Demo3_1.class </code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile &#x2F;E:&#x2F;codes&#x2F;java_demos&#x2F;out&#x2F;production&#x2F;jvm&#x2F;indi&#x2F;taicw&#x2F;jvm&#x2F;bytecode&#x2F;Demo3_1.class</span><br><span class="line">  Last modified 2020-01-21; size 631 bytes</span><br><span class="line">  MD5 checksum 7c4e2c4e0f4f091335b60e7501868580</span><br><span class="line">  Compiled from &quot;Demo3_1.java&quot;</span><br><span class="line">public class indi.taicw.jvm.bytecode.Demo3_1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #7.#25         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;lang&#x2F;Short</span><br><span class="line">   #3 &#x3D; Integer            32768</span><br><span class="line">   #4 &#x3D; Fieldref           #27.#28        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #5 &#x3D; Methodref          #29.#30        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">   #6 &#x3D; Class              #31            &#x2F;&#x2F; indi&#x2F;taicw&#x2F;jvm&#x2F;bytecode&#x2F;Demo3_1</span><br><span class="line">   #7 &#x3D; Class              #32            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #8 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #9 &#x3D; Utf8               ()V</span><br><span class="line">  #10 &#x3D; Utf8               Code</span><br><span class="line">  #11 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #12 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #13 &#x3D; Utf8               this</span><br><span class="line">  #14 &#x3D; Utf8               Lindi&#x2F;taicw&#x2F;jvm&#x2F;bytecode&#x2F;Demo3_1;</span><br><span class="line">  #15 &#x3D; Utf8               main</span><br><span class="line">  #16 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #17 &#x3D; Utf8               args</span><br><span class="line">  #18 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #19 &#x3D; Utf8               a</span><br><span class="line">  #20 &#x3D; Utf8               I</span><br><span class="line">  #21 &#x3D; Utf8               b</span><br><span class="line">  #22 &#x3D; Utf8               c</span><br><span class="line">  #23 &#x3D; Utf8               SourceFile</span><br><span class="line">  #24 &#x3D; Utf8               Demo3_1.java</span><br><span class="line">  #25 &#x3D; NameAndType        #8:#9          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 &#x3D; Utf8               java&#x2F;lang&#x2F;Short</span><br><span class="line">  #27 &#x3D; Class              #33            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #28 &#x3D; NameAndType        #34:#35        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #29 &#x3D; Class              #36            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #30 &#x3D; NameAndType        #37:#38        &#x2F;&#x2F; println:(I)V</span><br><span class="line">  #31 &#x3D; Utf8               indi&#x2F;taicw&#x2F;jvm&#x2F;bytecode&#x2F;Demo3_1</span><br><span class="line">  #32 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #33 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #34 &#x3D; Utf8               out</span><br><span class="line">  #35 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #36 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #37 &#x3D; Utf8               println</span><br><span class="line">  #38 &#x3D; Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public indi.taicw.jvm.bytecode.Demo3_1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lindi&#x2F;taicw&#x2F;jvm&#x2F;bytecode&#x2F;Demo3_1;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 10</span><br><span class="line">        line 9: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo3_1.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1. 常量池载入运行时常量池</strong></p>
<p>运行时常量池也属于方法区，因为比较特殊这里单独提出来</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/1.png?x-oss-process=style/watermarking"></p>
<p><strong>2. 方法字节码载入方法区</strong></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2.png?x-oss-process=style/watermarking"></p>
<p><strong>3. main 线程开始运行分配栈帧内存</strong></p>
<p>（stack=2，locals=4）对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位(slot)</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/3.png?x-oss-process=style/watermarking"></p>
<p><strong>4. 执行引擎开始执行字节码指令</strong></p>
<ol>
<li><p><strong>bipush 10</strong></p>
<ul>
<li>将一个byte压如操作数栈（其长度会补齐 4 个字节），类似的指令还有：<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里较小的数字常量(short范围之内，-32768~32767)都是和字节码指令(bipush、sipush)存在一起，<strong>超过 short 范围的数字常量存入了常量池</strong>(ldc、ldc2_w 需要从运行时常量池读取)</p>
</blockquote>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/4.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>istore_1</strong></p>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表 slot 1 中</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/5-1.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/5-2.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>ldc #3</strong></p>
<ul>
<li><p>从运行时常量池加载 #3 数据到操作数栈。</p>
<blockquote>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的  </p>
</blockquote>
</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/6.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>istore_2</strong></p>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表 slot2 中</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/7.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/7-1.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>iload_1</strong></p>
<ul>
<li>把局部变量表中的 slot1 存放的元素加载到操作数栈</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/8.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>iload_2</strong></p>
<ul>
<li>把局部变量表中的 slot 2 存放的元素加载到操作数栈</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/9.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>iadd</strong></p>
<ul>
<li>将操作数栈中的两个元素弹出栈并相加，再把结果压入操作数栈中</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/10.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/10-2.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>istore_3</strong></p>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表 slot3 中</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/11.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/11-2.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>getstatic #4</strong></p>
<ul>
<li>在运行时常量池中找到#4，发现是一个对象，在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/12.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/12-2.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>iload_3</strong></p>
<ul>
<li>把局部变量表中的 slot3 存放的元素加载到操作数栈</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/12-3.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>invokevirtual #5</strong></p>
<ul>
<li>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法，生成新的栈帧（分配 locals、stack等），传递参数，执行新栈帧中的字节码</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/13.png?x-oss-process=style/watermarking"></p>
<ul>
<li>执行完毕，弹出栈帧，清除 main 操作数栈内容</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/13-2.png?x-oss-process=style/watermarking"></p>
</li>
<li><p><strong>return</strong></p>
<ul>
<li>完成 main 方法调用，弹出 main 栈帧，程序结束</li>
</ul>
</li>
</ol>
<h3 id="2-2-1-程序分析-a-与-a"><a href="#2-2-1-程序分析-a-与-a" class="headerlink" title="2.2.1 程序分析 a++ 与 ++a"></a>2.2.1 程序分析 a++ 与 ++a</h3><p>了解字节码指令之后，下面通过字节码指令角度来分析几个程序执行结果</p>
<p><strong>— 示例1</strong></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果 a、b 分别是多少呢？</span></span><br></pre></td></tr></table></figure>

<p>字节码指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: iload_1</span><br><span class="line">        <span class="number">4</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">7</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">10</span>: iload_1</span><br><span class="line">       <span class="number">11</span>: iadd</span><br><span class="line">       <span class="number">12</span>: iload_1</span><br><span class="line">       <span class="number">13</span>: iinc          <span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">       <span class="number">16</span>: iadd</span><br><span class="line">       <span class="number">17</span>: istore_2</span><br><span class="line">       18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">21</span>: iload_1</span><br><span class="line">       22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       25: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">28</span>: iload_2</span><br><span class="line">       29: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>a++ 对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iload_1</span><br><span class="line">iinc  1, 1</span><br></pre></td></tr></table></figure>

<p>++a 对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iinc  1, 1</span><br><span class="line">iload_1</span><br></pre></td></tr></table></figure>

<p>a– 对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iload_1</span><br><span class="line">iinc  1, -1</span><br></pre></td></tr></table></figure>

<p> 注意 <code>iinc</code> 指令是<strong>直接在局部变量 slot 上进行运算的，不需要加载到操作数栈</strong>。<code>iinc 1 1</code> 则表示直接在局部变量表 slot1(这里就是变量a)上加1。 而 a++ 和 ++a 的区别是先执行 <code>iload</code> 还是先执行 <code>iinc </code>。</p>
<p>因此上诉程序执行过程中，a、b 变化情况如下：</p>
<ol>
<li><p>最开始 a 被赋值为 10。此时，操作数栈无元素， slot1(a)=10</p>
</li>
<li><p>**a++**：iload_1 先把slot1(a) 加载到操作数栈，iinc 直接在局部变量 solt1(a) 上做加1运算。此时操作数栈栈顶元素是10，slot1(a)=11</p>
</li>
<li><p><strong>++a</strong>：iinc 先直接在局部变量 solt1(a) 上做加1运算，iload_1 在把slot1(a) 加载到操作数栈。此时操作数栈元素分别是10-&gt;12，slot1(a)=12</p>
</li>
<li><p>a++ <strong>+</strong> ++a：iadd 把操作数栈中的两个元素(10、12)弹出栈并相加，再把相加结果压入栈。此时操作数栈栈顶元素是22，slot1(a)=12</p>
</li>
<li><p>**a–**：iload_1 先把slot1(a) 加载到操作数栈，iinc 直接在局部变量 solt1(a) 上做减1运算。此时操作数栈元素分别是22-&gt;12，slot(a)=11</p>
</li>
<li><p>a++ + ++a <strong>+</strong> a–：iadd 把操作数栈中的两个元素(22、12)弹出栈并相加，再把相加结果压入栈。此时操作数栈栈顶元素是34，slot1(a)=11</p>
</li>
<li><p>b <strong>=</strong> a++ + ++a + a–：istore_2 把操作数栈栈顶元素弹出，放入局部变量表 slot2(b) 中。此时操作数栈无元素，slot1(a)=11，slot2(b)=34</p>
<p>最后的输出结果是  a=11, b=34</p>
</li>
</ol>
<p><strong>— 示例2</strong></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果x是多少呢？</span></span><br></pre></td></tr></table></figure>

<p>字节码指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_0</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: if_icmpge     <span class="number">21</span></span><br><span class="line">        <span class="number">10</span>: iload_2</span><br><span class="line">        <span class="number">11</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">14</span>: istore_2</span><br><span class="line">        <span class="number">15</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">4</span></span><br><span class="line">        21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">24</span>: iload_2</span><br><span class="line">        25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 每一次循环，都是先把局部变量slot2(x)加载到操作数栈（此时栈顶元素为0），然后在局部变量slot2(X)上做加1操作（此时slot2(x)=1），最后再把操作数栈顶元素弹出存放到局部变量slot2(x)中。因此，相当于每次循环后局部变量slot(x)都会被操作数栈顶元素重新覆盖。</p>
<p>所以上述程序输出结果 x=0</p>
<h2 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h2><p><strong>— &lt;cinit&gt;()V</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(i); <span class="comment">//结果是 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下的顺序</strong>，<strong>收集所有 static 静态代码块和静态成员赋值的代码</strong>，合并为一个特殊的方法 <code>&lt;cinit&gt;()V </code>。上诉代码字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">        2: putstatic     #3                  // Field i:I</span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">30</span></span><br><span class="line">        7: putstatic     #3                  // Field i:I</span><br><span class="line">       <span class="number">10</span>: bipush        <span class="number">10</span></span><br><span class="line">       12: putstatic     #3                  // Field i:I</span><br><span class="line">       <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用   </p>
</blockquote>
<p><strong>— &lt;init&gt;()V</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo3_5</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3_5 d = <span class="keyword">new</span> Demo3_5(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(d.a);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是 &quot;s3&quot;, 30</span></span><br></pre></td></tr></table></figure>

<p>在调用构造方法时，编译器会按<strong>从上至下的顺序</strong>，<strong>收集所有 {} 代码块和成员变量赋值的代码</strong>，形成新的方法<code>&lt;init&gt;()V</code>，但<strong>原始构造方法内的代码总是在最后</strong> 。上诉代码字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> indi.taicw.jvm.bytecode.Demo3_5(java.lang.String, <span class="keyword">int</span>);</span><br><span class="line">    descriptor: (Ljava/lang/String;I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         5: ldc           #2                  // String s1</span><br><span class="line">         7: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">        13: putfield      #4                  // Field b:I</span><br><span class="line">        <span class="number">16</span>: aload_0</span><br><span class="line">        <span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line">        19: putfield      #4                  // Field b:I</span><br><span class="line">        <span class="number">22</span>: aload_0</span><br><span class="line">        23: ldc           #5                  // String s2</span><br><span class="line">        25: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">        <span class="number">28</span>: aload_0</span><br><span class="line">        <span class="number">29</span>: aload_1</span><br><span class="line">        30: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">        <span class="number">33</span>: aload_0</span><br><span class="line">        <span class="number">34</span>: iload_2</span><br><span class="line">        35: putfield      #4                  // Field b:I</span><br><span class="line">        <span class="number">38</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        ...</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">39</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lindi/taicw/jvm/bytecode/Demo3_5;</span><br><span class="line">            <span class="number">0</span>      <span class="number">39</span>     <span class="number">1</span>     a   Ljava/lang/String;</span><br><span class="line">            <span class="number">0</span>      <span class="number">39</span>     <span class="number">2</span>     b   I</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h2 id="2-4-方法调用"><a href="#2-4-方法调用" class="headerlink" title="2.4 方法调用"></a>2.4 方法调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo3_6</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3_6 d = <span class="keyword">new</span> Demo3_6();</span><br><span class="line">        d.test1();</span><br><span class="line">        d.test2();</span><br><span class="line">        d.test3();</span><br><span class="line">        d.test4();</span><br><span class="line">        Demo3_6.test4();</span><br><span class="line">        d.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应字节码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: new           #3                  // class indi/taicw/jvm/bytecode/Demo3_6</span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">7</span>: astore_1</span><br><span class="line">        <span class="number">8</span>: aload_1</span><br><span class="line">        9: invokespecial #5                  // Method test1:()V</span><br><span class="line">       <span class="number">12</span>: aload_1</span><br><span class="line">       13: invokespecial #6                  // Method test2:()V</span><br><span class="line">       <span class="number">16</span>: aload_1</span><br><span class="line">       17: invokevirtual #7                  // Method test3:()V</span><br><span class="line">       <span class="number">20</span>: aload_1</span><br><span class="line">       <span class="number">21</span>: pop</span><br><span class="line">       22: invokestatic  #8                  // Method test4:()V</span><br><span class="line">       25: invokestatic  #8                  // Method test4:()V</span><br><span class="line">       <span class="number">28</span>: aload_1</span><br><span class="line">       29: invokevirtual #9                  // Method toString:()Ljava/lang/String;</span><br><span class="line">       <span class="number">32</span>: pop</span><br><span class="line">       <span class="number">33</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">34</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">8</span>      <span class="number">26</span>     <span class="number">1</span>     d   Lindi/taicw/jvm/bytecode/Demo3_6;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的字节码指令有所区别</p>
<ul>
<li> <code>new</code> 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈；</li>
<li> <code>dup</code> 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 <code>invokespecial</code> 调用该对象的构造方法 <code>&quot;&lt;init&gt;&quot;:()V</code> （会消耗掉栈顶一个引用），另一个要配合 <code>astore_1</code> 赋值给局部变量；</li>
<li>私有(private)、构造、被final修饰的成员方法，在调用时都使用**<code>invokespecial</code>**指令，编译期间可以确定该方法的内容，属于静态绑定<ul>
<li>还有一个执行 <code>invokespecial</code> 的情况是通过 super 调用父类方法 ；</li>
</ul>
</li>
<li> 普通成员方法是由 <strong><code>invokevirtual</code></strong> 调用，属于动态绑定，因为编译期间无法确定该方法的内容，只有在运行期间才能确定，即支持多态；</li>
<li>静态方法在调用时使用**<code>invokestatic</code><strong>指令，</strong>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】**<ul>
<li>示例代码中 “d.test4()” 是通过【对象引用】调用一个静态方法，可以看到在调用 <code>invokestatic</code> 之前执行了 <code>pop</code> 指令，把【对象引用】从操作数栈弹出了。所以静态方法尽量使用类来调用，使用对象的话会多执行两条指令 (<code>aload</code> 和 <code>pop</code>)</li>
</ul>
</li>
</ul>
<h2 id="2-5-多态原理"><a href="#2-5-多态原理" class="headerlink" title="2.5 多态原理"></a>2.5 多态原理</h2><p>因为普通成员方法支持多态，需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令。</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ol>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong></li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h2 id="2-6-异常处理"><a href="#2-6-异常处理" class="headerlink" title="2.6 异常处理"></a>2.6 异常处理</h2><h3 id="2-6-1-try-catch"><a href="#2-6-1-try-catch" class="headerlink" title="2.6.1 try-catch"></a>2.6.1 try-catch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: bipush        10</span><br><span class="line">       4: istore_1</span><br><span class="line">       5: goto          12</span><br><span class="line">       8: astore_2</span><br><span class="line">       9: bipush        20</span><br><span class="line">      11: istore_1</span><br><span class="line">      12: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           2     5     8   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      ...</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          9       3     2     e   Ljava&#x2F;lang&#x2F;Exception;</span><br><span class="line">          0      13     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">          2      11     1     i   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到多出来一个 <strong>Exception table</strong> 的结构，**[from, to)** 是<strong>前闭后开</strong>的检测范围(这里也就是检测2~4行)，一旦这个范围内的字节码执行出现异常，则通过 <strong>type</strong> 匹配异常类型，如果一致，跳转 <strong>target</strong> 所指示行号继续执行</li>
<li>这里第 8 行的字节码指令 <code>astore_2</code> 是将异常对象引用存入局部变量表的slot2号位置(e)</li>
</ul>
<h3 id="2-6-2-多个-single-catch-块的情况"><a href="#2-6-2-多个-single-catch-块的情况" class="headerlink" title="2.6.2 多个 single-catch 块的情况"></a>2.6.2 多个 single-catch 块的情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            i = <span class="number">40</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">4</span>: istore_1</span><br><span class="line">         <span class="number">5</span>: goto          <span class="number">26</span></span><br><span class="line">         <span class="number">8</span>: astore_2</span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">11</span>: istore_1</span><br><span class="line">        <span class="number">12</span>: goto          <span class="number">26</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: bipush        <span class="number">40</span></span><br><span class="line">        <span class="number">18</span>: istore_1</span><br><span class="line">        <span class="number">19</span>: goto          <span class="number">26</span></span><br><span class="line">        <span class="number">22</span>: astore_2</span><br><span class="line">        <span class="number">23</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">25</span>: istore_1</span><br><span class="line">        <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/NullPointerException</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">22</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        ...</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/ArithmeticException;</span><br><span class="line">           <span class="number">16</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/NullPointerException;</span><br><span class="line">           <span class="number">23</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">27</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">25</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为异常出现时，<strong>只能进入Exception table 中一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></p>
<h3 id="2-6-3-multi-catch-的情况"><a href="#2-6-3-multi-catch-的情况" class="headerlink" title="2.6.3 multi-catch 的情况"></a>2.6.3 multi-catch 的情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method test = Demo3_9.class.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            test.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: ldc           #2                  // class indi/taicw/jvm/bytecode/Demo3_9</span><br><span class="line">        2: ldc           #3                  // String test</span><br><span class="line">        <span class="number">4</span>: iconst_0</span><br><span class="line">        5: anewarray     #4                  // class java/lang/Class</span><br><span class="line">        8: invokevirtual #5                  // Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;</span><br><span class="line">       <span class="number">11</span>: astore_1</span><br><span class="line">       <span class="number">12</span>: aload_1</span><br><span class="line">       <span class="number">13</span>: aconst_null</span><br><span class="line">       <span class="number">14</span>: iconst_0</span><br><span class="line">       15: anewarray     #6                  // class java/lang/Object</span><br><span class="line">       18: invokevirtual #7                  // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">       <span class="number">21</span>: pop</span><br><span class="line">       <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">       <span class="number">25</span>: astore_1</span><br><span class="line">       <span class="number">26</span>: aload_1</span><br><span class="line">       27: invokevirtual #11                 // Method java/lang/ReflectiveOperationException.printStackTrace:()V</span><br><span class="line">       <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/NoSuchMethodException</span><br><span class="line">            <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/IllegalAccessException</span><br><span class="line">            <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/reflect/InvocationTargetException</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">12</span>      <span class="number">10</span>     <span class="number">1</span>  test   Ljava/lang/reflect/Method;</span><br><span class="line">          <span class="number">26</span>       <span class="number">4</span>     <span class="number">1</span>     e   Ljava/lang/ReflectiveOperationException;</span><br><span class="line">           <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>可以看到 JDK7之后支持的新语法 <strong>multi-catch</strong>，编译后的字节码与使用多个 <strong>single-catch</strong> 并没有太大不同</p>
<h3 id="2-6-4-finally"><a href="#2-6-4-finally" class="headerlink" title="2.6.4 finally"></a>2.6.4 finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">4</span>: istore_1</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">7</span>: istore_1</span><br><span class="line">         <span class="number">8</span>: goto          <span class="number">27</span></span><br><span class="line">        <span class="number">11</span>: astore_2</span><br><span class="line">        <span class="number">12</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">14</span>: istore_1</span><br><span class="line">        <span class="number">15</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">17</span>: istore_1</span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">27</span></span><br><span class="line">        <span class="number">21</span>: astore_3</span><br><span class="line">        <span class="number">22</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">24</span>: istore_1</span><br><span class="line">        <span class="number">25</span>: aload_3</span><br><span class="line">        <span class="number">26</span>: athrow</span><br><span class="line">        <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">            <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        ...</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">12</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">28</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入：</p>
<ul>
<li><p> <strong>try 流程</strong>：2<del>8行，其中5</del>7为finally代码块</p>
</li>
<li><p> <strong>catch 流程</strong>：11<del>18行，其中15</del>17为finally代码块</p>
</li>
<li><p><strong>catch未捕获的异常类型流程</strong>：21<del>26行，其中22</del>24为finally代码块</p>
<ul>
<li>从<strong>Exception table</strong> 表可知，未捕获的异常类型使用 <code>any</code> 表示 ，可能发生在[2<del>5)行try代码块 或者 [11</del>15)行catch代码块中</li>
<li><code>astore_3</code> 把未捕获的类型异常对象放入局部变量表 slot3 的位置，然后再由 <code>athrow</code> 抛出异常。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意，仔细观察<strong>LocalVariableTable</strong> 中并没有 slot3 这个局部变量，那么slot3是什么作用呢？这个后面会继续讲，这里先关注 <strong>finally代码块分别被复制到了每个可能的流程</strong></p>
</blockquote>
<p>注意：<strong>LocalVariableTable</strong> 中并没有展示 slot3，这里的 slot3 是一个没有名字的变量，<strong>这种变量的作用是 当要执行 finally 代码块时都会先把 try代码块或者catch 代码块执行结束时 要返回的值或者要抛出的异常 给暂存起来，即保存在该变量中，等finally代码块内容执行完后，再把该变量值加到操作数栈，最后由 <code>irenturn</code> 或 <code>athrow</code> 指令从操作数栈弹出（即返回或抛出）</strong></p>
<h3 id="2-6-5-程序分析-finally-中的-return"><a href="#2-6-5-程序分析-finally-中的-return" class="headerlink" title="2.6.5 程序分析 finally 中的 return"></a>2.6.5 程序分析 finally 中的 return</h3><p><strong>— finally 块没有出现 return 的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果是 10</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0</span><br><span class="line">        <span class="number">8</span>: iload_1</span><br><span class="line">        <span class="number">9</span>: ireturn</span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2</span><br><span class="line">       <span class="number">15</span>: athrow</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p> finally 中的代码块被插入了所有可能的流程，其中 <code>istore_1</code>、<code>iload_1</code>、<code>astore_2</code>、<code>aload_2</code> 这些指令操作的局部变量应该分别对应slot1与slot2，但是 <strong>LocalVariableTable</strong> 中并没有展示 slot1与slot2，这里的 slot1与slot2 实际上是一个没有名字的变量，这类变量的作用是  <strong>在有finally代码块的情况先，当try代码块或者catch代码执行结束 真正返回(return)或者真正抛出异常之前，会先把要返回的值或者要抛出的异常给暂存起来，即保存在该类变量(临时变量)中，等finally代码块内容执行完后，再把该变量值加载到操作数栈，最后由 <code>irenturn</code>、<code>arenturn</code>、 <code>athrow</code> 等指令从操作数栈弹出（即返回或抛出）。</strong></p>
<p>所以上诉代码由字节码分析可知，虽然finally中 执行了 “<code>i = 20</code>“（对应字节码 “<code>5: bipush  20</code>“、”<code>7: istore_0</code>“），但是在此之前 “10” 这个值已经被保存在了一个临时变量中(对应字节码 “<code>4: istore_1</code>“)，方法执行结束真正要返回结果时，再把这个临时变量的值加载到操作数栈(对应字节码 “<code>8: iload_1</code>“)，最后由 <code>ireturn</code> 指令弹出操作数栈，方法真正结束。所以最后test()方法返回结束是10</p>
<p><strong>— finally 块出现了 return 的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是 20</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0</span><br><span class="line">        <span class="number">8</span>: iload_0</span><br><span class="line">        <span class="number">9</span>: ireturn</span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: iload_0</span><br><span class="line">       <span class="number">15</span>: ireturn</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>和上一个示例代码Demo3_11相比，Demo3_12示例代码中finally块中多了 “<code>return i</code>“，从字节码分析可知，执行 <code>ireturn</code> 之前执行的指令是 <code>iload_0</code>，即把局部变量 slot0(i) 加载到操作数栈而不是临时变量slot1，所以最终程序输出结果是20。实际上这里的”<code>ireturn</code>“指令是finally块中的，因为在try块真正执行<code>ireturn</code> 指令之前，需要先暂存返回值去执行finally块中的代码，由于finally块中也包含 “<code>return i</code>“ 语句，导致finally块代码执行完后方法直接结束了，而try块中的 “<code>return i</code>“ 语句并没有执行，所以test()方法的最终返回值来自finally块。</p>
<p>还有一个现象，<strong>未捕获的异常类型流程</strong>中没有了<code>athrow</code>了，也就是说[3~5) 行如果出现任何类型的异常(any)，都不会被抛出了。因为，<strong>如果在 finally 代码块中出现了 <code>return</code>，会吞掉异常</strong>，可以试一下下面的代码进行验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = i/<span class="number">0</span>; <span class="comment">//这里一定异常，但并没有抛出</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果依然正常输出 20，并没有异常抛出</span></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: iconst_0</span><br><span class="line">        <span class="number">5</span>: idiv</span><br><span class="line">        <span class="number">6</span>: istore_0</span><br><span class="line">        <span class="number">7</span>: iload_0</span><br><span class="line">        <span class="number">8</span>: istore_1</span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_0</span><br><span class="line">       <span class="number">12</span>: iload_0</span><br><span class="line">       <span class="number">13</span>: ireturn</span><br><span class="line">       <span class="number">14</span>: astore_2</span><br><span class="line">       <span class="number">15</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">17</span>: istore_0</span><br><span class="line">       <span class="number">18</span>: iload_0</span><br><span class="line">       <span class="number">19</span>: ireturn</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">9</span>    <span class="number">14</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">17</span>     <span class="number">0</span>     i   I</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以 finally 中尽量不要写 return 语句，这样会隐藏掉一些异常信息，并且方法最终返回值来之finally块中的 return。</p>
</blockquote>
<h3 id="2-6-7-synchronized"><a href="#2-6-7-synchronized" class="headerlink" title="2.6.7 synchronized"></a>2.6.7 synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: new           #2                  // class java/lang/Object</span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">7</span>: astore_1</span><br><span class="line">        <span class="number">8</span>: aload_1</span><br><span class="line">        <span class="number">9</span>: dup</span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: monitorenter</span><br><span class="line">       12: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       15: ldc           #4                  // String ok</span><br><span class="line">       17: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">20</span>: aload_2</span><br><span class="line">       <span class="number">21</span>: monitorexit</span><br><span class="line">       <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">       <span class="number">25</span>: astore_3</span><br><span class="line">       <span class="number">26</span>: aload_2</span><br><span class="line">       <span class="number">27</span>: monitorexit</span><br><span class="line">       <span class="number">28</span>: aload_3</span><br><span class="line">       <span class="number">29</span>: athrow</span><br><span class="line">       <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           <span class="number">12</span>    <span class="number">22</span>    <span class="number">25</span>   any</span><br><span class="line">           <span class="number">25</span>    <span class="number">28</span>    <span class="number">25</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       ...</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">8</span>      <span class="number">23</span>     <span class="number">1</span>  lock   Ljava/lang/Object;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>通过字节码分析可以看出，方法中的同步代码块加锁(11: monitorenter)之后，有两条解锁指令，一个是正常流程下同步块执行完后进行解锁(21: monitorexit)，另一个是同步块执行中出现异常要先解锁(27: monitorexit)再抛出异常</p>
<blockquote>
<p>注意：方法级别的 synchronized 不会在字节码指令中有所体现  </p>
</blockquote>
<h1 id="3-编译期语法糖处理"><a href="#3-编译期语法糖处理" class="headerlink" title="3. 编译期语法糖处理"></a>3. 编译期语法糖处理</h1><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 \</em>.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给程序员的一个额外福利</p>
<blockquote>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 插件 jclasslib，idea 的反编译功能，<a href="http://www.benf.org/other/cfr/">CRF</a> 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
</blockquote>
<h2 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成class后的代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&lt;init&gt;&quot;:()V</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h2><p>自动拆装箱，这个特性是 JDK 5 开始加入的， 代码片段1 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码片段1 在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK5 之后编译阶段就被转换为了 代码片段2，不需要手动改写了</p>
<h2 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h2><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line">    Integer x = list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/util/ArrayList</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">        11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">        14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">        <span class="number">19</span>: pop</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: iconst_0</span><br><span class="line">        22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">        27: checkcast     #7                  // class java/lang/Integer</span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        ...</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span>     x   Ljava/lang/Integer;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码中还要有拆箱操作：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span></span><br><span class="line"><span class="keyword">int</span> x = ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure>

<p>还好这些麻烦事都不用自己做，编译器替我们加上了。</p>
<p>擦除的是字节码上的泛型信息，可以看到  <strong>LocalVariableTypeTable</strong> 仍然保留了方法参数泛型的信息 。使用反射，仍然能够获得这些信息  ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;       </span><br><span class="line">        Method test = Demo4_1.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">        Type[] types = test.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">                Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始类型 - interface java.util.List</span></span><br><span class="line"><span class="comment">泛型参数[0] - class java.lang.String</span></span><br><span class="line"><span class="comment">原始类型 - interface java.util.Map</span></span><br><span class="line"><span class="comment">泛型参数[0] - class java.lang.Integer</span></span><br><span class="line"><span class="comment">泛型参数[1] - class java.lang.Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h2><p>可变参数也是 JDK 5 开始加入的新特性 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] array = args; <span class="comment">//可以直接复制给数组</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同<br>样 java 编译器会在编译期间将上述代码变换为：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo4_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果调用的是”foo()”，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
</blockquote>
<h2 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h2><p><code>foreach</code> 也是 JDK 5 开始引入的语法糖。</p>
<p>如果是<strong>数组的循环</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">		System.out.println(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = arr[i];</span><br><span class="line">		System.out.println(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是<strong>集合的循环</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际被编译器转换为对迭代器的调用 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">     Iterator var2 = list.iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">         Integer i = (Integer)var2.next();</span><br><span class="line">         System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： <strong>foreach 循环写法</strong>，能够配合<strong>数组</strong>，以及所有<strong>实现了 Iterable 接口的集合类</strong>一起使用，其中 Iterable 用来获取集合的迭代器（ Iterator ）  </p>
</blockquote>
<h2 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h2><p>从 JDK 7 开始，<code>switch</code> 可以作用于<strong>字符串</strong>和<strong>枚举类</strong>，这个功能其实也是语法糖 。</p>
<p><strong>— 作用于字符串</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hello world&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;你好世界&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C.&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;BM&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被编译器转换为 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2123</span>: <span class="comment">//&quot;C.&quot; 与 &quot;BM&quot; hashCode 相等</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;BM&quot;</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;C.&quot;</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1794106052</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello world&quot;</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var2) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;你好世界&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间，单个的<code>switch</code>被分为了两个</p>
<ul>
<li>第一个根据字符串的 <code>hashCode()</code> 和 <code>equals()</code> 将字符转换为 <code>byte</code> 类型并赋值给 var2。为什么既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突，例如 “BM” 和 “C.” 这两个字符串的hashCode值都是2123</li>
<li>第二个用来根据 var2 的值来决定要输出的语句</li>
</ul>
<p><strong>— 作用于枚举</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_3_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器转换后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_3_2</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="comment">//将对应位置枚举元素的值赋给x，用于case操作</span></span><br><span class="line">      <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h2><p>JDK 7 新增了枚举类，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译器转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">//对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    	<span class="comment">//调用构造函数，传入枚举元素的值及ordinal</span></span><br><span class="line">    	MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   <span class="comment">//调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，枚举类实际也是一个普通类，只不过继承了<code>Enum</code> 类，并且 <code>final</code> 关键字修饰，意味着不能被继承。</p>
<h2 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h2><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 “<strong>try-with-resources</strong>“，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (资源变量 = 创建资源对象) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，”<code>资源变量</code>“ 对象需要实现 <code>AutoCloseable</code> 接口，例如 <code>InputStream</code> 、 <code>OutputStream</code> 、<code>Connection</code> 、 <code>Statement </code>、 <code>ResultSet</code> 等接口都实现了 <code>AutoCloseable</code> ，使用 <strong>try-with-resources</strong> 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line">        Throwable var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">            var2 = var12;</span><br><span class="line">            <span class="keyword">throw</span> var12;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">                        var2.addSuppressed(var11);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">        var14.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h2><p>我们都知道，方法重写时对返回值分两种情况  ：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子类 m() 方法的返回值是 Integer 是父类 m() 方法返回值 Number 的子类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于子类，java编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此方法才是真正重写了父类 public Number m()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synthetic bridge Number <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 public Integer m()</span></span><br><span class="line">        <span class="keyword">return</span> m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中桥接方法比较特殊，<strong>仅对 java 虚拟机可见</strong>，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method m : B.class.getDeclaredMethods()) &#123;</span><br><span class="line">	System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">public java.lang.Integer test.candy.B.m()</span></span><br><span class="line"><span class="comment">public java.lang.Number test.candy.B.m()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-11-匿名内部内类"><a href="#3-11-匿名内部内类" class="headerlink" title="3.11 匿名内部内类"></a>3.11 匿名内部内类</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Demo4_6$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个额外的类，实现了Runnable接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo4_6$<span class="number">1</span>() &#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果匿名内部类中引用了<strong>局部变量</strong>，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_6</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">//多创建了一个变量</span></span><br><span class="line">   <span class="keyword">int</span> val$x;</span><br><span class="line">   <span class="comment">//变为了有参构造器</span></span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>注意</strong>: 这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的，因为在创建 Demo4_6$1 对象时，将 x 的值通过构造方法赋值给了 Demo4_6$1 对象的 val$x 属 性， 所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化</p>
<h1 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h1><p>类的加载阶段主要三个阶段：</p>
<ul>
<li><strong>加载</strong></li>
<li><strong>链接</strong>：此阶段又包含三个<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li><strong>初始化</strong></li>
</ul>
<h2 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h2><ul>
<li>将类的字节码载入<strong>方法区</strong>（JDK1.8后为元空间在本地内存中）中，内部采用 C++ 的 <strong>instanceKlass</strong> 描述 java 类，它的重要 ﬁeld 有 ：<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li><strong>加载</strong>和<strong>链接</strong>可能是<strong>交替运行</strong>的</li>
</ul>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-1.png?x-oss-process=style/watermarking"></p>
<blockquote>
<p><strong>instanceKlass</strong> 保存在方法区(jdk1.8后为元空间即本地内存中)，而 <strong>_java_mirror</strong> 保存在堆内存中，两者互相保存了对方的地址</p>
</blockquote>
<h2 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h2><p><strong>链接阶段</strong>，又分为三个阶段：<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong></p>
<p><strong>1. 验证</strong>：<strong>验证类是否符合JVM规范，安全性检查</strong></p>
<p><strong>2. 准备</strong>：<strong>为 static 变量分配空间，设置默认值</strong></p>
<ul>
<li>static变量在JDK 7以前是存储于instanceKlass末尾（方法区中），但在JDK 7以后就存储在_java_mirror末尾（堆内存中）</li>
<li>static变量<strong>分配空间</strong>和<strong>赋值</strong>是两个步骤，<strong>分配空间是在准备阶段完成的</strong>，<strong>赋值</strong>根据static变量的类型完成阶段不同<ul>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值会在<strong>初始化阶段完成</strong></li>
</ul>
</li>
</ul>
<p><strong>3. 解析</strong>：<strong>将常量池中的符号引用解析为直接引用</strong> </p>
<p>注意：使用 类加载器的 <strong>loadClass(String)</strong> 方法，不会导致类的解析和初始化，使用 <code>new</code>关键字创建对象会触发类的解析和初始化。如下代码进行验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.bytecode.load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ClassLoader classloader = Demo5_1.class.getClassLoader();</span><br><span class="line">        <span class="comment">// loadClass 方法不会导致类的解析和初始化</span></span><br><span class="line">        Class&lt;?&gt; c = classloader.loadClass(<span class="string">&quot;indi.taicw.jvm.bytecode.load.C&quot;</span>);</span><br><span class="line">        <span class="comment">// new 会导致类的解析和初始化</span></span><br><span class="line">        <span class="keyword">new</span> E();</span><br><span class="line">        <span class="comment">//为了使程序不结束</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    F f = <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过 <code>jps</code> 查看该程序的 pid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jps</span><br><span class="line">19232 Demo5_1</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code>， 启动 <strong>HSDB</strong> 程序</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-2.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-3.png?x-oss-process=style/watermarking"></p>
<blockquote>
<p>如果启动 HSDB 报错，如下：”java.lang.UnsatisfiedLinkError: Can’t load library:D:\mysoftware\java8u161jre\bin\sawindbg.dll”，是因为<strong>缺少一个sawindbg.dll的文件</strong>，在资源管理器收索”sawindbg.dll”，复制到缺失的文件下即可     </p>
</blockquote>
</li>
<li><p>验证类是否加载</p>
<p>输入pid进入指定程序后，点击菜单 “Tools” -&gt; “Class Browser”。搜索查看已加载类：</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-5.png?x-oss-process=style/watermarking"></p>
<p>可以看到，C类、E类、F类 都被加载了，而D类还未被加载，可见 <code>ClassLoader.loadClass(String)</code> 加载类是懒惰的，C类中引用的D类暂时未被加载</p>
</li>
<li><p>验证类是否被解析</p>
<p>分别查看C类、E类的常量池</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-6.png?x-oss-process=style/watermarking"></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-7.png?x-oss-process=style/watermarking"></p>
<p>可以看到，在C类常量池中，C和D类未被解析，常量值仅仅用一串符号代替；而E类的常量池中，E和F类都被解析了，常量值已包含实际地址</p>
</li>
</ol>
<h2 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h2><p>初始化即调用 <code>cinit()V</code> ，虚拟机会保证这个类的『构造方法』的线程安全</p>
<p><strong>概括的说类的初始化是懒惰的，初始化触发的时机：</strong></p>
<p>以下情况会触发初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 关键字会触发初始化</li>
</ul>
<p>以下情况不会触发初始化</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组</li>
<li>调用类加载器的loadClass()方法</li>
<li>Class.forName()的第二个参数为false时</li>
</ul>
<p>验证类的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.bytecode.load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实验时请先全部注释，每次只执行其中一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //-------------会触发类的初始化的情况----------------</span></span><br><span class="line">        <span class="comment">// 1. 首次访问这个类的静态变量或静态方法时，会触发</span></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line"><span class="comment">//        // 2. 子类初始化，如果父类还没初始化，会触发</span></span><br><span class="line"><span class="comment">//        System.out.println(B.c);</span></span><br><span class="line"><span class="comment">//        // 3. 子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line"><span class="comment">//        System.out.println(B.a);</span></span><br><span class="line"><span class="comment">//        // 4. 会初始化类 B，并先初始化类 A</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;indi.taicw.jvm.bytecode.load.B&quot;);</span></span><br><span class="line"><span class="comment">//        //new 关键字会触发初始化</span></span><br><span class="line"><span class="comment">//        new B();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //---------------不会触发类的初始化的情况---------------</span></span><br><span class="line"><span class="comment">//        // 1. 静态常量不会触发初始化</span></span><br><span class="line"><span class="comment">//        System.out.println(B.b);</span></span><br><span class="line"><span class="comment">//        // 2. 类对象.class 不会触发初始化</span></span><br><span class="line"><span class="comment">//        System.out.println(B.class);</span></span><br><span class="line"><span class="comment">//        // 3. 创建该类的数组不会触发初始化</span></span><br><span class="line"><span class="comment">//        System.out.println(new B[0]);</span></span><br><span class="line"><span class="comment">//        // 4. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line"><span class="comment">//        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">//        cl.loadClass(&quot;indi.taicw.jvm.bytecode.load.B&quot;);</span></span><br><span class="line"><span class="comment">//        // 5. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line"><span class="comment">//        ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;indi.taicw.jvm.bytecode.load.B&quot;, false, c2);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型应用–完成懒惰初始化单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>初始化时的线程安全是有保障的  </li>
</ul>
<h1 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h1><p>以JDK 8为例：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载哪里的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BootstrapClassLoader(启动类加载器)</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问（C++代码编写）</td>
</tr>
<tr>
<td>ExtensionClassLoader(扩展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为BootstrapClassLoader，获取上级时<strong>显示为null</strong></td>
</tr>
<tr>
<td>ApplicationClassLoader(应用程序类加载器)</td>
<td>classpath（一般用来加载我们自己写的类）</td>
<td>上级为ExtensionClassLoader</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为ApplicationClassLoader</td>
</tr>
</tbody></table>
<h2 id="5-1-启动类加载器"><a href="#5-1-启动类加载器" class="headerlink" title="5.1 启动类加载器"></a>5.1 启动类加载器</h2><p>使用 Bootstrap 类加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;F init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;indi.taicw.jvm.classloader.F&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器：&quot;</span>+ aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入项目编译输出目录，运行 “Demo6_1” 类，分别观察加与不加 <code>-Xbootclasspath/a:.</code> 参数程序的输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\codes\java_demos\out\production\jvm&gt;java indi.taicw.jvm.classloader.Demo6_1</span><br><span class="line">F init</span><br><span class="line">类加载器：sun.misc.Launcher$AppClassLoader@15db9742</span><br><span class="line"></span><br><span class="line">E:\codes\java_demos\out\production\jvm&gt;java -Xbootclasspath&#x2F;a:. indi.taicw.jvm.classloader.Demo6_1</span><br><span class="line">F init</span><br><span class="line">类加载器：null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，不加 <code>-Xbootclasspath/a:.</code> 参数默认使用的是<strong>应用程序类加载器</strong>，加 <code>-Xbootclasspath/a:.</code> 参数则使用的是<strong>启动类加载器</strong>，因为启动类加载器是C++编写，无法直接获取java对象，所以输出 null</p>
<p>其中，**-Xbootclasspath** 表示设置启动类加载器的加载路径（默认是 JAVA_HOME/jre/lib），可以使用这个办法替换核心类</p>
<ul>
<li>java -Xbootclasspath:&lt;new bootclasspath&gt;<ul>
<li>指定 bootclasspath 具体目录</li>
</ul>
</li>
<li>java -Xbootclasspath/a:&lt;追加路径&gt;<ul>
<li>目录追加至 bootclasspath 之后  </li>
</ul>
</li>
<li>java -Xbootclasspath/p:&lt;追加路径&gt;  <ul>
<li>目录追加至 bootclasspath 之前</li>
</ul>
</li>
</ul>
<h2 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h2><p>把上诉示例中的 F 类打一个jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\codes\java_demos\out\production\jvm&gt;jar -cvf my.jar indi&#x2F;taicw&#x2F;jvm&#x2F;classloader&#x2F;F.class</span><br><span class="line">已添加清单</span><br><span class="line">正在添加: indi&#x2F;taicw&#x2F;jvm&#x2F;classloader&#x2F;F.class(输入 &#x3D; 487) (输出 &#x3D; 320)(压缩了 34%)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并拷贝 “my.jar” 到 “<strong>JAVA_HOME/jre/lib/ext</strong>“ 目录下，再次运行 “Demo6_1”，观察输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\codes\java_demos\out\production\jvm&gt;java indi.taicw.jvm.classloader.Demo6_1</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">F init</span><br><span class="line">类加载器：sun.misc.Launcher$ExtClassLoader@6bc7c054</span><br></pre></td></tr></table></figure>

<p>可以看到默认的类加载器由<strong>应用程序类加载器</strong>变为了<strong>扩展类加载器</strong>。(这里涉及双亲委派原则，下面会讲到)</p>
<h2 id="5-3-应用程序类加载器"><a href="#5-3-应用程序类加载器" class="headerlink" title="5.3 应用程序类加载器"></a>5.3 应用程序类加载器</h2><p>一般情况下我们自己写的类（classpath下的类）默认都是由<strong>应用程序类加载器</strong>进行加载的，上面示例的演示已有所体现。</p>
<blockquote>
<p>通过 <code>ClassLoader.getSystemClassLoader()</code> 获取的就是 应用程序类加载器对象</p>
</blockquote>
<h2 id="5-4-双亲委派"><a href="#5-4-双亲委派" class="headerlink" title="5.4 双亲委派"></a>5.4 双亲委派</h2><p>双亲委派模式，即调用类加载器的 <code>loadClass()</code> 方法时，查找类的规则：</p>
<ul>
<li><strong>当加载器加载某个类时，先查找该类是否已加载，如果已加载过直接返回，如果该类没有被加载过，则当前类加载器先去委托父类加载器去加载该类，父类加载器再去委托它自己的父类加载器去加载，以此类推。如果父类的加载器都无法加载该类，则当前加载器就会调用自己的 <code>findClass()</code> 方法去加载该类</strong>。</li>
</ul>
<p>例如，<strong>ApplicationClassLoader</strong> 类加载器加载A类时，发现A类未被加载过，则委托 <strong>ExtensionClassLoader</strong> 去加载A类，<strong>ExtensionClassLoader</strong> 再委托 <strong>BootstrapClassLoader</strong> 去加载A类，如果 <strong>BootstrapClassLoader</strong> 加载A类失败，则<strong>ExtensionClassLoader</strong>再尝试加载A类，如果也失败，则<strong>ApplicationClassLoader</strong>再尝试加载A类，如果还是失败，最后则抛出异常。</p>
<p>类加载器的 loadClass() 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1.检查该类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果该类还未被加载，则先尝试委派上级去加载该类</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 3.如果有上级的话，委派上级的loadClass()去加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 4.如上级了为 null，则委派BootstrapClassLoader加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 5.上级如果找不到会该类，则会抛出异常。这里捕获异常，不做任何处理，后续使用当前加载器来加载该类</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">// 6. 如果上级类加载器都找不到，就调用当前类加载器的findClass()方法（每个类加载器自己扩展）来加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7. 记录耗时</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h2><p><strong>使用场景</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<p><strong>自定义加载器实现步骤</strong></p>
<ul>
<li>继承 <strong>ClassLoader</strong> 父类</li>
<li>要遵从双亲委派机制，重写 <strong>ﬁndClass()</strong> 方法<ul>
<li>不是重写**loadClass()**方法，否则不会走双亲委派机制。如果是特殊需求就是要破坏双亲委派机制，那就重写 **loadClass()**方法</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 <strong>deﬁneClass()</strong> 方法来加载类，即把读取到的类文件从字节数组转换为Class实例</li>
<li>使用者调用该类加载器的通用方法 <strong>loadClass()</strong> 方法即可</li>
</ul>
<p>下面示例演示实现一个自定义类加载器 “MyClassLoader”，用来加载 “E:/code/“ 目录下的 “*.class”。</p>
<p>首先创建一个 “Student.java” 文件，编译成 “Student.class” 并存放到 “E:/code/“ 目录下，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;类名：&quot;</span> + clazz.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.class的类加载器：&quot;</span> + clazz.getClassLoader().toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.class的类加载器的上级类加载器：&quot;</span> + clazz.getClassLoader().getParent().toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a student!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建自定义类加载器 “MyClassLoader”，并继承 “ClassLoader”，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">&quot;E:/code/&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path), out);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类文件未找到&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 “MyClassLoader” 来加载 “Student.class”，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;display&quot;</span>).invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行结果：</span></span><br><span class="line"><span class="comment">类名：Student</span></span><br><span class="line"><span class="comment">Student.class的类加载器：indi.taicw.jvm.classloader.MyClassLoader@7f31245a</span></span><br><span class="line"><span class="comment">Student.class的类加载器的上级类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">I&#x27;m a student!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>判断一个Class对象是否是同一个，除了包名和类名一致外，还要看这个Class对象的类加载器对象是否是同一个</strong>。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.taicw.jvm.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> taichangwei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        ClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class c1 = classLoader1.loadClass(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        Class c2 = classLoader1.loadClass(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        Class c3 = classLoader2.loadClass(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// c1 与 c2 是同一个类加载器对象加载的，所以输出为 true</span></span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">        <span class="comment">// c1 与 c3 是不同的类加载器对象加载的，所以输出为 false</span></span><br><span class="line">        System.out.println(c1 == c3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-SPI-机制"><a href="#5-6-SPI-机制" class="headerlink" title="5.6 SPI 机制"></a>5.6 SPI 机制</h2><p>SPI 全称为 Service Provider Interface，是<strong>JDK内置的一种服务提供发现机制</strong>。一般用于将一些服务接口提供给第三方实现或者扩展，可以增强框架的扩展或者替换一些组件，体现的是【面向接口编程+解耦】的思想，如JDBC、Servlet初始化、Spring容器、Dubbo(对SPI进行了扩展) 等都运用了此思想。</p>
<p>一个服务(Service)通常指的是已知的接口或者抽象类，服务提供方就是对这个接口或者抽象类的实现。然后按照SPI 标准在资源路径 <strong>META-INF/services</strong> 目录下创建一个<strong>以服务接口全限定名命名的文件</strong>，文件的<strong>每行内容就是一个实现类的全限定名</strong>。如下图：</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/p5-8.png?x-oss-process=style/watermarking"></p>
<blockquote>
<p>JDBC4.0之前，需要通过<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>显式实例化驱动类，否则将找不到对应的数据库驱动，但从JDBC4.0开始就不再需要了，而是通过 SPI 机制来加载驱动类</p>
</blockquote>
<p><strong>SPI机制的约定如下：</strong></p>
<ul>
<li>在”<strong>META-INF/services/</strong>“目录中创建以<strong>Service接口全限定名命名的文件</strong>，该文件内容为Service接口具体实现类的全限定名，文件编码必须为UTF-8；</li>
<li>使用<code>ServiceLoader.load(Class class)</code> 动态加载Service接口的实现类；</li>
<li>如SPI的实现类为jar，则需要将其放在当前程序的classpath下；</li>
<li>Service的具体实现类<strong>必须有一个不带参数的构造方法</strong></li>
</ul>
<p><code>ServiceLoader</code> 是SPI机制中用来加载实现类的，使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);</span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">	iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来看一下 <code>ServiceLoader.load(Class service)</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取线程上下文类加载器</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取<strong>线程上下文类加载器</strong>（是当前线程使用的类加载器，通常默认就是应用程序类加载器 ）， 然后又调用了另一个 “load()” 方法并把接口类型和类加载器传入，其内部是通过<strong>Class.forName()</strong> 调用了<strong>线程上下文类加载器</strong>完成类加载的，具体代码在 <strong>ServiceLoader</strong> 的内部类 <strong>LazyIterator.nextService()</strong> 方法中：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h1><h2 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h2><h3 id="6-1-1-分层编译与逃逸分析"><a href="#6-1-1-分层编译与逃逸分析" class="headerlink" title="6.1.1 分层编译与逃逸分析"></a>6.1.1 分层编译与逃逸分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JIT1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Object();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\n&quot;</span>,i,(end - start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0	27000</span><br><span class="line">1	101801</span><br><span class="line">2	36100</span><br><span class="line">3	37799</span><br><span class="line">4	32700</span><br><span class="line">5	33000</span><br><span class="line">6	35000</span><br><span class="line">7	36000</span><br><span class="line">8	36001</span><br><span class="line">9	34801</span><br><span class="line">10	48699</span><br><span class="line">11	34501</span><br><span class="line">12	42500</span><br><span class="line">13	43800</span><br><span class="line">14	37500</span><br><span class="line">15	36699</span><br><span class="line">16	37299</span><br><span class="line">17	59099</span><br><span class="line">18	46900</span><br><span class="line">19	30100</span><br><span class="line">20	41300</span><br><span class="line">21	41600</span><br><span class="line">22	39100</span><br><span class="line">23	35299</span><br><span class="line">24	36700</span><br><span class="line">25	35701</span><br><span class="line">26	34099</span><br><span class="line">27	36499</span><br><span class="line">28	38500</span><br><span class="line">29	37000</span><br><span class="line">30	39201</span><br><span class="line">31	36400</span><br><span class="line">32	93801</span><br><span class="line">33	87100</span><br><span class="line">34	39601</span><br><span class="line">35	37600</span><br><span class="line">36	45300</span><br><span class="line">37	36900</span><br><span class="line">38	42200</span><br><span class="line">39	118401</span><br><span class="line">40	93899</span><br><span class="line">41	58900</span><br><span class="line">42	85100</span><br><span class="line">43	39799</span><br><span class="line">44	36401</span><br><span class="line">45	31300</span><br><span class="line">46	37900</span><br><span class="line">47	35200</span><br><span class="line">48	33200</span><br><span class="line">49	35800</span><br><span class="line">50	35599</span><br><span class="line">51	36501</span><br><span class="line">52	36000</span><br><span class="line">53	35900</span><br><span class="line">54	37100</span><br><span class="line">55	40101</span><br><span class="line">56	37601</span><br><span class="line">57	40899</span><br><span class="line">58	46100</span><br><span class="line">59	48200</span><br><span class="line">60	36400</span><br><span class="line">61	37099</span><br><span class="line">62	42600</span><br><span class="line">63	37801</span><br><span class="line">64	36699</span><br><span class="line">65	39500</span><br><span class="line">66	37301</span><br><span class="line">67	47600</span><br><span class="line">68	33700</span><br><span class="line">69	42501</span><br><span class="line">70	41800</span><br><span class="line">71	35500</span><br><span class="line">72	27800</span><br><span class="line">73	14400</span><br><span class="line">74	12900</span><br><span class="line">75	13000</span><br><span class="line">76	16800</span><br><span class="line">77	12800</span><br><span class="line">78	17700</span><br><span class="line">79	16699</span><br><span class="line">80	8899</span><br><span class="line">81	13800</span><br><span class="line">82	13000</span><br><span class="line">83	13700</span><br><span class="line">84	14500</span><br><span class="line">85	14400</span><br><span class="line">86	12799</span><br><span class="line">87	9399</span><br><span class="line">88	12101</span><br><span class="line">89	13300</span><br><span class="line">90	13101</span><br><span class="line">91	12999</span><br><span class="line">92	18801</span><br><span class="line">93	15500</span><br><span class="line">94	15600</span><br><span class="line">95	13499</span><br><span class="line">96	13401</span><br><span class="line">97	13499</span><br><span class="line">98	13399</span><br><span class="line">99	12301</span><br><span class="line">100	14800</span><br><span class="line">101	13900</span><br><span class="line">102	13401</span><br><span class="line">103	11600</span><br><span class="line">104	13301</span><br><span class="line">105	15100</span><br><span class="line">106	13900</span><br><span class="line">107	11300</span><br><span class="line">108	28200</span><br><span class="line">109	13901</span><br><span class="line">110	13800</span><br><span class="line">111	11499</span><br><span class="line">112	13400</span><br><span class="line">113	12200</span><br><span class="line">114	13301</span><br><span class="line">115	12200</span><br><span class="line">116	12400</span><br><span class="line">117	15600</span><br><span class="line">118	13400</span><br><span class="line">119	13100</span><br><span class="line">120	16200</span><br><span class="line">121	13600</span><br><span class="line">122	12100</span><br><span class="line">123	11901</span><br><span class="line">124	15300</span><br><span class="line">125	15800</span><br><span class="line">126	13900</span><br><span class="line">127	13500</span><br><span class="line">128	14400</span><br><span class="line">129	15100</span><br><span class="line">130	14200</span><br><span class="line">131	13100</span><br><span class="line">132	13200</span><br><span class="line">133	15500</span><br><span class="line">134	11601</span><br><span class="line">135	12800</span><br><span class="line">136	14100</span><br><span class="line">137	12799</span><br><span class="line">138	11199</span><br><span class="line">139	13300</span><br><span class="line">140	13999</span><br><span class="line">141	16300</span><br><span class="line">142	13200</span><br><span class="line">143	15400</span><br><span class="line">144	14501</span><br><span class="line">145	13599</span><br><span class="line">146	13300</span><br><span class="line">147	13400</span><br><span class="line">148	13700</span><br><span class="line">149	16600</span><br><span class="line">150	13400</span><br><span class="line">151	9299</span><br><span class="line">152	9101</span><br><span class="line">153	9199</span><br><span class="line">154	9601</span><br><span class="line">155	9300</span><br><span class="line">156	9701</span><br><span class="line">157	13000</span><br><span class="line">158	87800</span><br><span class="line">159	12101</span><br><span class="line">160	600</span><br><span class="line">161	600</span><br><span class="line">162	700</span><br><span class="line">163	600</span><br><span class="line">164	700</span><br><span class="line">165	4699</span><br><span class="line">166	600</span><br><span class="line">167	600</span><br><span class="line">168	600</span><br><span class="line">169	600</span><br><span class="line">170	700</span><br><span class="line">171	700</span><br><span class="line">172	600</span><br><span class="line">173	600</span><br><span class="line">174	600</span><br><span class="line">175	1000</span><br><span class="line">176	599</span><br><span class="line">177	700</span><br><span class="line">178	700</span><br><span class="line">179	700</span><br><span class="line">180	700</span><br><span class="line">181	600</span><br><span class="line">182	600</span><br><span class="line">183	600</span><br><span class="line">184	599</span><br><span class="line">185	600</span><br><span class="line">186	600</span><br><span class="line">187	600</span><br><span class="line">188	600</span><br><span class="line">189	600</span><br><span class="line">190	600</span><br><span class="line">191	1000</span><br><span class="line">192	600</span><br><span class="line">193	600</span><br><span class="line">194	600</span><br><span class="line">195	600</span><br><span class="line">196	700</span><br><span class="line">197	600</span><br><span class="line">198	600</span><br><span class="line">199	600</span><br></pre></td></tr></table></figure>

<p>观察上面示例代码的输出结果，发现随着循环次数的增加每次循环用时越来越少，这是什么原因呢？</p>
<p><strong>JVM 将执行状态分成了 5 个层次</strong>：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 即时编译器编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<blockquote>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p>
</blockquote>
<p><strong>即时编译器（JIT）与解释器的区别</strong></p>
<ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为针对所有平台都通用的机器码，下次即使遇到相同的字节码，仍会执行<strong>重复的解释</strong></li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>根据平台类型编译为平台特定的机器码，并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，<strong>无需再编译</strong></li>
</ul>
</li>
</ul>
<p>对于占据的大部分不常用代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码并优化之（这也是hotspot名称的由来）。</p>
<p>之所以上面的示例，循环用时越来越短，是因为执行状态从0层依次上升到4层，每一层都进行了不同程度的优化，其中在C2编译器阶段检查到循环内 “<code>new Object()</code> “ 创建了对象并没有被真正使用到，因此后面的循环中就不再执行 “new Object()” 语句了，所以最后的单次循环耗时提升到了600纳秒左右，这种优化手段叫做<strong>逃逸分析</strong>。</p>
<blockquote>
<p>可以通过参数 <code>-XX:-DoEscapeAnalysis</code> 来关闭逃逸分析，在执行上面示例观察结果。该参数默认是开启状态</p>
</blockquote>
<p><strong>逃逸分析</strong>通俗来讲，就是分析一个对象的动态作用域：<strong>当一个方法定义的对象(局部变量)被其他方法或线程引用时，我们称这个对象发生了逃逸</strong>。发生逃逸的场景一般有：</p>
<ul>
<li>局部变量作为参数传递到其他方法中</li>
<li>局部变量做为当前方法的返回值返回</li>
<li>局部变量赋值给类变量</li>
<li>局部变量被其他线程访问到</li>
</ul>
<p>对于当逃逸分析后发现一个局部变量<strong>未发生逃逸</strong>时，即该局部变量只在当前方法中使用且未被其他线程访问，那么即时编译器就可能会为这个变量进行一些高效的优化：</p>
<ul>
<li><p><strong>栈上分配</strong>（Stack Allocation）</p>
<p>一般都会认为新创建的对象内存分配在堆上。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在<strong>栈上分配内存</strong>将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。所以，<strong>新创建的对象并不一定在堆上分配内存</strong>。</p>
</li>
<li><p><strong>同步消除</strong>（Synchronization Elimination）</p>
<p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>标量替换</strong>（Scalar Replacement）</p>
<p>Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>（Scalar）。相对的，如果一个数据可以继续分解，那它称为<strong>聚合量</strong>（Aggregate），Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.x = x;</span><br><span class="line">           <span class="keyword">this</span>.y = y;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>关于逃逸分析的论文在1999年就已经发表，但直到Sun JDK 1.6才实现了逃逸分析，而且直到现在这项优化尚未足够成熟，仍有很大的改进余地。不成熟的原因主要是逃逸分析自身也是需要进行一系列复杂的分析的，也是一个相对耗时的过程，不能保证逃逸分析的性能收益必定高于它的消耗。如果分析完后发现没有几个不逃逸的对象，那这些运行期分析耗用的时间就白白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成逃逸分析。还有一点是，基于逃逸分析的一些优化手段，如上面提到的“栈上分配”，由于HotSpot虚拟机目前的实现方式导致栈上分配实现起来比较复杂，因此在HotSpot中暂时还没有做这项优化</p>
</blockquote>
<h3 id="6-1-2-方法内联"><a href="#6-1-2-方法内联" class="headerlink" title="6.1.2 方法内联"></a>6.1.2 方法内联</h3><p><strong>方法内联</strong>指的是<strong>把方法的代码直接复制到被调用的位置，减少方法调用的开销</strong>。如果一个方法被频繁调用（热点方法），并且方法体不太大时，就会进行内联。 方法的调用就是进栈和出栈过程，需要有一定的时间开销和空间开销，当一个方法体不大，但又频繁被调用时，这个时间和空间开销会相对变得很大，变得非常不划算，对热点方法的针对性优化（内联）可以提升整体系统的性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x1 , <span class="keyword">int</span> x2 , <span class="keyword">int</span> x3 , <span class="keyword">int</span> x4)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add1(x1 , x2) + add1(x3,x4);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x1 , <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x1 + x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一段时间后，方法内联结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x1 , <span class="keyword">int</span> x2 , <span class="keyword">int</span> x3 , <span class="keyword">int</span> x4)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x1 + x2 + x3 + x4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-1-3-字段优化"><a href="#6-1-3-字段优化" class="headerlink" title="6.1.3 字段优化"></a>6.1.3 字段优化</h3><p><strong>方法内联</strong> 也会影响到<strong>成员变量的访问</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] elements = randomInts(<span class="number">1_000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomInts(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        Random random = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            values[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            doSum(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>test()</code> 方法中的循环中如果 <code>doSum()</code> 方法发生了内联，那么成员变量也会被一个临时的局部变量来缓存起来，来减少对成员变量的访问。优化后类似类似如下效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] local = <span class="keyword">this</span>.elements;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; local.length; i++) &#123;</span><br><span class="line">           sum += local[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method foo = ReflectDemo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">            foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 “<code>foo.invoke(null)</code>“ 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">          InvocationTargetException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">               checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//MethodAccessor的子类有 DelegatingMethodAccessorImpl、NativeMethodAccessorImpl</span></span><br><span class="line">       MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">       <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ma = acquireMethodAccessor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中 “<code>foo.invoke(null)</code>“ 前 0-15次循环，使用的<code>MethodAccessor</code> 实现类是 <code>DelegatingMethodAccessorImpl</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setDelegate(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.delegate.invoke(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = var1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>DelegatingMethodAccessorImpl</code> 再委托给 <code>NativeMethodAccessorImpl</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// inflationThreshold 膨胀阈值，默认 15, 每次调用 numInvocations 加1</span></span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右</span></span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当”<code>foo.invoke(null)</code>“调用到第 16 次（即超过阈值）时，<strong>会采用运行时动态生成的访问器类代替掉最初的实现，来提高效率</strong>。可以通过 debug 得到动态生成的访问器类名为 <code>sun.reflect.GeneratedMethodAccessor1 </code> ，再通过阿里的 <a href="https://arthas.aliyun.com/zh-cn/">arthas工具</a> 来查看<code>GeneratedMethodAccessor1 </code> 源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> indi.taicw.jvm.reflect.ReflectDemo;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.MethodAccessorImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Loose catch block</span></span><br><span class="line"><span class="comment">     * Enabled aggressive block sorting</span></span><br><span class="line"><span class="comment">     * Enabled unnecessary exception pruning</span></span><br><span class="line"><span class="comment">     * Enabled aggressive exception aggregation</span></span><br><span class="line"><span class="comment">     * Lifted jumps to return sites</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Object[] arrobject)</span> <span class="keyword">throws</span> InvocationTargetException                            </span>&#123;</span><br><span class="line">        block4: &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrobject == <span class="keyword">null</span> || arrobject.length == <span class="number">0</span>) <span class="keyword">break</span> block4;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectDemo.foo();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">super</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到  “<code>ReflectDemo.foo()</code>“，由反射调用变为直接调用了</p>
<blockquote>
<p>注意，通过查看 ReflectionFactory 源码可知：</p>
<p>1.设置系统参数 <code>sun.reflect.noInflation</code> 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）<br>2.设置系统参数<code>sun.reflect.inflationThreshold</code> 可以修改膨胀阈值  </p>
</blockquote>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>类加载</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM参数类型</title>
    <url>/20200501/jvmParamType/218e2c7235be.html</url>
    <content><![CDATA[<h1 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. 参数分类</h1><p>jvm 参数可分为三类：</p>
<ul>
<li>标准参数：以 “<code>-</code>“ 开头的参数</li>
<li>非标准参数：以 “<code>-X</code>“ 开头的参数</li>
<li>不稳定参数：以”<code>-XX</code>“ 开头的参数</li>
</ul>
<a id="more"></a>

<h1 id="2-标准参数（-）"><a href="#2-标准参数（-）" class="headerlink" title="2. 标准参数（-）"></a>2. 标准参数（-）</h1><p><strong>标准参数</strong>是指在各个JVM版本中基本保持不变，相对比较稳定。</p>
<p>标准参数统一都是以 “<code>-</code>“ 开头，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dprofile&#x3D;dev HelloWorld tom jack</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：其中<code>HelloWorld</code>  是被运行的 HelloWorld.class。<code>HelloWorld</code> 之前就是设置的JVM标准参数（-classpath、-D），<code>HelloWorld</code> 之后的参数(tom、jack)是用来传给 <code>main(String[] args)</code> 方法的args数组变量的，两者位置不要放错</p>
</blockquote>
<p><strong>查看所有标准参数</strong>：</p>
<p>打开一个命令终端，执行 “<code>java -help</code>“，就可以展示所有的JVM标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -help</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;&#x3D;&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括&#x2F;排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp&#x3D;help 和 -agentlib:hprof&#x3D;help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[&#x3D;&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;java&#x2F;javase&#x2F;documentation&#x2F;index.html。</span><br></pre></td></tr></table></figure>



<h1 id="2-非标准参数（-X）"><a href="#2-非标准参数（-X）" class="headerlink" title="2. 非标准参数（-X）"></a>2. 非标准参数（-X）</h1><p><strong>非标准参数</strong>表示不保证所有VM实现都支持这些参数，在将来的JVM版本中可能会发生改变</p>
<p>非标准参数统一以 “<code>-X</code>“ 开头，如 <code>-Xmx20M</code> 设置最大java堆大小，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有非标准参数</strong>：</p>
<p>打开一个命令终端，执行 “`java -X”，就可以展示所有的JVM非标准参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -X</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath&#x2F;a:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath&#x2F;p:&lt;用 ; 分隔的目录和 zip&#x2F;jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java&#x2F;VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>



<h1 id="3-不稳定参数-（-XX）"><a href="#3-不稳定参数-（-XX）" class="headerlink" title="3. 不稳定参数 （-XX）"></a>3. 不稳定参数 （-XX）</h1><p><strong>不稳定参数</strong>这是我们日常开发中接触到最多的参数类型，也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于JVM调优和debug</p>
<p><strong>不稳定参数</strong>统一以 “<code>-XX</code>“ 开头，书写格式分为两种：</p>
<ul>
<li>bool 类型：<ul>
<li><code>-XX:+&lt;option&gt;</code>：代表启用 true</li>
<li><code>-XX:-&lt;option&gt;</code>：代表禁用 false</li>
</ul>
</li>
<li>数值或字符串类型：<ul>
<li><code>-XX:&lt;option&gt;=&lt;number&gt;</code>。数字如果有单位一般是 兆字节的“ m”或“ M”，千字节的“ k”或“ K”以及千兆字节的“ g”或“ G”（例如32k与32768相同）</li>
<li><code>-XX:&lt;option&gt;=&lt;string&gt;</code>。字符串通常用于指定文件，路径或命令列表</li>
</ul>
</li>
</ul>
<p>如 打印GC日志 <code>-XX:+PrintGCDetails</code>、设置对象最大晋升老年代的年龄 <code>-XX:MaxTenuringThreshold=15</code>，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath E:&#x2F;code -Dfile.encoding&#x3D;UTF-8 -Dprofile&#x3D;dev -Xmx20M -XX:+PrintGCDetails -XX:MaxTenuringThreshold&#x3D;15  HelloWorld tom jack</span><br></pre></td></tr></table></figure>



<p><strong>查看所有不稳定参数（-XX:+PrintFlagsFinal）</strong></p>
<p>执行命令终端，执行 “<code>-XX:+PrintFlagsFinal</code>“，展示所有不稳定参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\taichangwei&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          &#x3D; 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    &#x3D; 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  &#x3D; 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              &#x3D; 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        &#x3D; 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx AliasLevel                                &#x3D; 3                                   &#123;C2 product&#125;</span><br><span class="line">     bool AlignVector                               &#x3D; false                               &#123;C2 product&#125;</span><br><span class="line">     intx AllocateInstancePrefetchLines             &#x3D; 1                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchDistance                  &#x3D; 192                                 &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchInstr                     &#x3D; 3                                   &#123;product&#125;</span><br><span class="line">     ...省略...</span><br><span class="line">    ccstr TraceJVMTI                                &#x3D;                                     &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               &#x3D; false                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                            :&#x3D; true                                &#123;product&#125;</span><br><span class="line">     ......</span><br><span class="line">    uintx YoungGenerationSizeIncrement              &#x3D; 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             &#x3D; 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        &#x3D; 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             &#x3D; 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  &#x3D; false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  &#x3D; 5                                   &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_161&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：参数类型</li>
<li>第二列：参数名称</li>
<li>第三列：”<code>=</code>“ 表示第四列是初始值，”<code>:=</code>“表示参数被用户或者JVM赋值了</li>
<li>第四列：参数值</li>
<li>第五列：参数类别</li>
</ul>
<p>**查看所有参数初始值(-XX:+PrintFlagsInitial)**：<br>相对于<code>-XX:+PrintFlagsFinal</code> 参数，<code>-XX:+PrintFlagsInitial</code>参数打印出的结果中第四列都是初始值</p>
<p><strong>打印已经被用户或者当前虚拟机设置过的参数(-XX:+PrintCommandLineFlags)</strong><br>相当于列举出 <code>-XX:+PrintFlagsFinal</code>的结果中所有第三列是”<code>:=</code>“的参数。一般运行程序时，最好都加上该参数，可以知道该程序运行都设置过哪些JVM参数</p>
<hr>
<p>更多参数使用说明参考官网：<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm参数</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之内存结构（一）</title>
    <url>/20200425/jvm1/9a318b08ecfc.html</url>
    <content><![CDATA[<h1 id="1-什么是-JVM？"><a href="#1-什么是-JVM？" class="headerlink" title="1. 什么是 JVM？"></a>1. 什么是 JVM？</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>JVM，即Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<a id="more"></a>

<h2 id="1-2-好处"><a href="#1-2-好处" class="headerlink" title="1.2 好处"></a>1.2 好处</h2><ol>
<li>一次编写，到处运行的基石</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数据下标越界检查</li>
<li>多态</li>
</ol>
<h2 id="1-3-JVM、JRE、JDK-比较"><a href="#1-3-JVM、JRE、JDK-比较" class="headerlink" title="1.3  JVM、JRE、JDK 比较"></a>1.3  JVM、JRE、JDK 比较</h2><p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/1-3-01.png?x-oss-process=style/watermarking"></p>
<h2 id="1-4-常见的-JVM"><a href="#1-4-常见的-JVM" class="headerlink" title="1.4 常见的 JVM"></a>1.4 常见的 JVM</h2><p>JVM 只是套规范，基于这套规范的实现常见如下几种：</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/1-3-02.PNG?x-oss-process=style/watermarking"></p>
<h1 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2. 内存结构"></a>2. 内存结构</h1><h2 id="2-1-整体架构"><a href="#2-1-整体架构" class="headerlink" title="2.1 整体架构"></a>2.1 整体架构</h2><p>JVM 内存结构主要包含：<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>、<strong>方法区</strong>，其中前三者是<strong>线程私有</strong>的，后两者是<strong>线程共享</strong>的。整体架构如下图：</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-1-01.PNG?x-oss-process=style/watermarking"></p>
<h2 id="2-2-程序计数器"><a href="#2-2-程序计数器" class="headerlink" title="2.2 程序计数器"></a>2.2 程序计数器</h2><h3 id="2-2-1-作用"><a href="#2-2-1-作用" class="headerlink" title="2.2.1 作用"></a>2.2.1 作用</h3><p>用于保存 JVM 中下一条要执行的指令的地址。</p>
<h3 id="2-2-2-特点"><a href="#2-2-2-特点" class="headerlink" title="2.2.2 特点"></a>2.2.2 特点</h3><ul>
<li><strong>线程私有</strong><ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程的代码。程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一条指令</li>
</ul>
</li>
<li><strong>不会存在内存溢出</strong>。<ul>
<li>因为永远只存储一个指令地址，JVM规范中唯一一个不存在OutOfMemoryError的区域</li>
</ul>
</li>
</ul>
<h2 id="2-3-虚拟机栈"><a href="#2-3-虚拟机栈" class="headerlink" title="2.3 虚拟机栈"></a>2.3 虚拟机栈</h2><h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h3><p>每个<strong>线程运行需要的内存空间</strong>，称为<strong>虚拟机栈</strong>。每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存。每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>。</p>
<p>使用 IDE 调试演示，从控制台可以看到方法进入虚拟机栈后的样子</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-3-2.png?x-oss-process=style/watermarking"></p>
<h3 id="2-3-2-特点"><a href="#2-3-2-特点" class="headerlink" title="2.3.2 特点"></a>2.3.2 特点</h3><ul>
<li>线程私有的</li>
<li>存在栈内存溢出</li>
</ul>
<h3 id="2-3-3-问题辨析"><a href="#2-3-3-问题辨析" class="headerlink" title="2.3.3 问题辨析"></a>2.3.3 问题辨析</h3><ul>
<li><p>垃圾回收是否涉及栈内存？</p>
<ul>
<li>不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈，内存会自动释放。所以无需通过垃圾回收机制去回收栈内存</li>
</ul>
</li>
<li><p>栈内存的分配越大越好吗？</p>
<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<ul>
<li><p>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</p>
</li>
<li><p>如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//是线程安全的，因为局部变量sb只在m1()方法内使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//不是线程安全的，因为局部变量sb是作为参数传过来的，m2()执行的同时可能会被其他线程修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//不是线程安全的，因为局部变量sb是作为返回值，可能会被多个其他线程拿到并同时修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="2-3-4-栈内存溢出"><a href="#2-3-4-栈内存溢出" class="headerlink" title="2.3.4 栈内存溢出"></a>2.3.4 栈内存溢出</h3><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p>发生原因</p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（比如无限递归）</li>
<li>每个<strong>栈帧所占用内存过大</strong></li>
</ul>
<h3 id="2-3-5-线程运行诊断"><a href="#2-3-5-线程运行诊断" class="headerlink" title="2.3.5  线程运行诊断"></a>2.3.5  线程运行诊断</h3><ul>
<li><p><strong>CPU 占用过高</strong>。Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ol>
<li><strong>top</strong> 命令，查看哪个<strong>进程</strong>占用CPU过高</li>
<li>拿到占用CPU过高的进程ID后，再通过 <strong>ps</strong> 查看哪个线程占用 CPU 过高。” <code>ps H -eo pid, tid, %cpu | grep 查到的占用CPU过高的进程ID</code>“</li>
<li>通过 “<code>jstack 进程id</code>“ 命令查看进程中线程ID(<strong>nid</strong>)，与上一步查出的线程ID(<strong>tid</strong>)来<strong>对比定位有问题的线程以及源码行号</strong>。注意jstack查找出的线程ID(nid)是16进制的需要转换。</li>
</ol>
</li>
<li><p><strong>程序运行很长时间没有结果</strong> 。一般可能是发生了<strong>线程死锁</strong>，这时需要找到死锁的线程</p>
<ul>
<li><p>找到当前运行的java程序的进程ID(也可以使用 <code>jps</code> 命令)</p>
</li>
<li><p>通过 “<code>jstack 进程id</code>“ 命令查看进程中是否有死锁线程</p>
</li>
<li><p>演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo004</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我获得了 a 和 b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我获得了 a 和 b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-3-5-001.png?x-oss-process=style/watermarking"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-本地方法栈"><a href="#2-4-本地方法栈" class="headerlink" title="2.4 本地方法栈"></a>2.4 本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。</p>
<p>本地方法栈也是 <strong>线程私有的</strong></p>
<h2 id="2-5-堆"><a href="#2-5-堆" class="headerlink" title="2.5 堆"></a>2.5 堆</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h3><p>通过<strong>new</strong>关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h3 id="2-5-2-特点"><a href="#2-5-2-特点" class="headerlink" title="2.5.2 特点"></a>2.5.2 特点</h3><ul>
<li>所有线程共享。堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
<li>存在堆内存溢出</li>
</ul>
<h3 id="2-5-3-堆内存溢出"><a href="#2-5-3-堆内存溢出" class="headerlink" title="2.5.3 堆内存溢出"></a>2.5.3 堆内存溢出</h3><p><strong>java.lang.OutofMemoryError ：java heap space</strong> 堆内存溢出</p>
<h3 id="2-5-4-堆内存诊断工具"><a href="#2-5-4-堆内存诊断工具" class="headerlink" title="2.5.4 堆内存诊断工具"></a>2.5.4 堆内存诊断工具</h3><ul>
<li>jps工具：查看当前系统中有哪些java进程</li>
<li>jmap工具：java内存映像工具。如查看堆内存占用情况 ,<code>jmap -heap pid</code></li>
<li>jconsole工具：图形界面的，Java监视与管理控制台</li>
<li>jvisualvm工具：图形界面的，多合一故障处理工具</li>
</ul>
<h2 id="2-6-方法区"><a href="#2-6-方法区" class="headerlink" title="2.6 方法区"></a>2.6 方法区</h2><h3 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1 定义"></a>2.6.1 定义</h3><p>方法区用于存储每个类的结构，比如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化中使用的特殊方法。方法区域可以是固定大小，也可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以收缩。</p>
<h3 id="2-6-2-组成"><a href="#2-6-2-组成" class="headerlink" title="2.6.2 组成"></a>2.6.2 组成</h3><p>方法区是一个抽象概念，JDK1.8以前方法区由<strong>永久代</strong>实现，JDK1.8以后方法区由<strong>元空间</strong>实现</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/5-1-1.png?x-oss-process=style/watermarking"></p>
<h3 id="2-6-3-方法区内存溢出"><a href="#2-6-3-方法区内存溢出" class="headerlink" title="2.6.3 方法区内存溢出"></a>2.6.3 方法区内存溢出</h3><ul>
<li><p>JDK1.8之前会导致永久代内存溢出</p>
<ul>
<li>设置永久代最大内存参数：**-XX:MaxPerSize=&lt;size&gt;**</li>
<li>异常信息：<strong>java.lang.OutOfMemoryError: PerGen space</strong></li>
</ul>
</li>
<li><p>JDK1.8之后会导致元空间内存溢出</p>
<ul>
<li><p>设置元空间最大内存参数：**-XX:MaxMetaspaceSize=&lt;size&gt;**</p>
</li>
<li><p>异常信息：<strong>java.lang.OutOfMemoryError: Metaspace</strong></p>
</li>
<li><p>演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo006</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; <span class="comment">// 继承ClassLoader，可以用来加载类的二进制字节码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo006 test = <span class="keyword">new</span> Demo006();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-6-03.png?x-oss-process=style/watermarking"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然我们自己编写的程序没有大量使用动态加载类，但如果我们在使用外部一些框架时，可能大量动态加载类，就可能会导致元空间内存溢出。如 spring、mybatis 的动态代理</p>
</blockquote>
<h3 id="2-6-4-常量池"><a href="#2-6-4-常量池" class="headerlink" title="2.6.4 常量池"></a>2.6.4 常量池</h3><ul>
<li><strong>常量池</strong>：Class文件中除了类的版本、字段、方法、接口等描述信息，还有<strong>常量池</strong>，用于<strong>存放编译期生成的各种字面量和符号引用</strong>。就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</li>
<li><strong>运行时常量池</strong>：常量池是class文件中的，当该类被加载，它的<strong>常量池信息就会放入运行时常量池，并把里面的符号地址翻译为真实地址</strong></li>
</ul>
<blockquote>
<p>较于Class文件常量池，<strong>运行时常量池具有动态性</strong>，在运行期间也可以将新的常量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的**intern()**方法</p>
</blockquote>
<p><strong>常量池与JVM字节码演示</strong></p>
<p>通过 “<code>javap -v &lt;class文件&gt;</code>“ 反编译，查看二进制字节码，其中包含了<strong>类基本信息</strong>，<strong>常量池</strong>，<strong>类方法定义(包含虚拟机指令）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo007</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入Demo007.class 所在目录执行，<code>javap -v Demo007.class</code>，输出结果如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile &#x2F;E:&#x2F;codes&#x2F;java_demos&#x2F;out&#x2F;production&#x2F;jvm&#x2F;indi&#x2F;taicw&#x2F;jvm&#x2F;structure&#x2F;methodarea&#x2F;constantpool&#x2F;Demo007.class</span><br><span class="line">  Last modified 2020-10-7; size 622 bytes</span><br><span class="line">  MD5 checksum 1356d96bb349e8a95e8c5df1cb36040c</span><br><span class="line">  Compiled from &quot;Demo007.java&quot;</span><br><span class="line">public class indi.taicw.jvm.structure.methodarea.constantpool.Demo007</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #6.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #21.#22        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #3 &#x3D; String             #23            &#x2F;&#x2F; hello world</span><br><span class="line">   #4 &#x3D; Methodref          #24.#25        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">   #5 &#x3D; Class              #26            &#x2F;&#x2F; indi&#x2F;taicw&#x2F;jvm&#x2F;structure&#x2F;methodarea&#x2F;constantpool&#x2F;Demo007</span><br><span class="line">   #6 &#x3D; Class              #27            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #12 &#x3D; Utf8               this</span><br><span class="line">  #13 &#x3D; Utf8               Lindi&#x2F;taicw&#x2F;jvm&#x2F;structure&#x2F;methodarea&#x2F;constantpool&#x2F;Demo007;</span><br><span class="line">  #14 &#x3D; Utf8               main</span><br><span class="line">  #15 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #16 &#x3D; Utf8               args</span><br><span class="line">  #17 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #18 &#x3D; Utf8               SourceFile</span><br><span class="line">  #19 &#x3D; Utf8               Demo007.java</span><br><span class="line">  #20 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #22 &#x3D; NameAndType        #29:#30        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #23 &#x3D; Utf8               hello world</span><br><span class="line">  #24 &#x3D; Class              #31            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #25 &#x3D; NameAndType        #32:#33        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #26 &#x3D; Utf8               indi&#x2F;taicw&#x2F;jvm&#x2F;structure&#x2F;methodarea&#x2F;constantpool&#x2F;Demo007</span><br><span class="line">  #27 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #28 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #29 &#x3D; Utf8               out</span><br><span class="line">  #30 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #31 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #32 &#x3D; Utf8               println</span><br><span class="line">  #33 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public indi.taicw.jvm.structure.methodarea.constantpool.Demo007();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lindi&#x2F;taicw&#x2F;jvm&#x2F;structure&#x2F;methodarea&#x2F;constantpool&#x2F;Demo007;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String hello world</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo007.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-6-5-字符串常量池-StringTable"><a href="#2-6-5-字符串常量池-StringTable" class="headerlink" title="2.6.5 字符串常量池 StringTable"></a>2.6.5 字符串常量池 StringTable</h3><p><strong>字符串常量池</strong> 是常量池中专门用来存放常量字符串的一块区域，使用 <strong>StringTable</strong> 进行存储，底层数据结构是一个哈希表。</p>
<p><strong>StringTable 位置</strong></p>
<ul>
<li>JDK1.6版本中，<strong>字符串常量池是在永久代</strong></li>
<li>JDK1.7版本及以后版本，JVM 已经将字符串常量池从方法区中移了出来，<strong>在 Java 堆（Heap）中开辟了一块区域存放字符串常量池</strong></li>
</ul>
<p><strong>StringTable 特性</strong></p>
<ul>
<li>常量池中的字符串仅是符号，第一次用到时才变为对象并放入字符串常量池</li>
<li>利用字符串常量池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是 StringBuilder</li>
<li>字符串常量拼接的原理是编译期优化</li>
<li>可以使用 <code>String#intern()</code> 方法，主动将当前字符串加入到字符串常量池中，并返回常量池中该字符串对象的引用<ul>
<li>JDK1.7及以后版本中调用<code>intern()</code>方法将这个字符串对象尝试放入串池，如果串池有则不会放入，如果没有则放入串池，并把串池中的对象引用返回</li>
<li>JDK1.6 版本中调用<code>intern()</code>方法将这个字符串对象尝试放入串池，如果有则并不会放入，<strong>如果没有会把对象复制一份放入串池</strong>，并把串池中的对象引用返回，而之前那个字符串对象还是存在的</li>
</ul>
</li>
</ul>
<p><strong>字符串拼接与字符串常量池相关问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo008</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;    <span class="comment">//字符串 &quot;a&quot; 放入串池，StringTable [&quot;a&quot;]</span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;    <span class="comment">//字符串 &quot;b&quot; 放入串池，StringTable [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;   <span class="comment">//字符串 &quot;ab&quot; 放入串池，StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为s1、s2是变量，只有运行时期才能确定具体值，所以底层实现是 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()，返回一个新的&quot;ab&quot;字符串对象</span></span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为 &quot;ab&quot;，所以等价于 s5 = &quot;ab&quot;，此时常量池已存在不用再创建新的&quot;ab&quot;对象</span></span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="comment">// s4调用intern()方法尝试把&quot;ab&quot;放入串池中，此时串池已存在&quot;ab&quot;, 并返回串池中的&quot;ab&quot;对象引用赋值给s6</span></span><br><span class="line">        String s6 = s4.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//false，原因：s3 是串池中&quot;ab&quot;字符串对象的引用，s4是堆中&quot;ab&quot;对象的引用</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        <span class="comment">//true，原因：s3、s5 都是串池中&quot;ab&quot;字符串对象的引用</span></span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        <span class="comment">//true，原因：s3、s6 都是串池中&quot;ab&quot;字符串对象的引用</span></span><br><span class="line">        System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        x2.intern(); <span class="comment">//把字符串&quot;cd&quot;放入串池，StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;cd&quot;]</span></span><br><span class="line">        String x1 = <span class="string">&quot;cd&quot;</span>; <span class="comment">//直接把串池中的&quot;cd&quot;对象引用赋值给 x1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//JDK1.7及之后版本，结果为true, 原因：x2调用intern()方法尝试把&quot;cd&quot;放入串池，此时串池不存在&quot;cd&quot;放入成功，此时串池中的&quot;cd&quot;对象与堆中的是同一个</span></span><br><span class="line">        <span class="comment">//JDK1.6版本，结果为false, 原因：x2调用intern()方法尝试把&quot;cd&quot;放入串池，此时串池不存在&quot;cd&quot;字符串，会复制一个新的&quot;cd&quot;对象放入串池中，此时串池中的&quot;cd&quot;对象与堆中的不是同一个</span></span><br><span class="line">        System.out.println(x1 == x2);</span><br><span class="line"></span><br><span class="line">        String x4 = <span class="keyword">new</span> String(<span class="string">&quot;e&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">        String x3 = <span class="string">&quot;ef&quot;</span>; <span class="comment">//把字符串&quot;cd&quot;放入串池，StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]</span></span><br><span class="line">        x4.intern();</span><br><span class="line">        <span class="comment">//结果为false, 原因：x4调用intern()方法尝试把&quot;ef&quot;放入串池，此时串池已存在&quot;cd&quot;放入失败，此时x3是串池中&quot;ef&quot;对象的引用，而x4是堆中的&quot;ef&quot;对象引用</span></span><br><span class="line">        System.out.println(x3 == x4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-6-StringTable-垃圾回收"><a href="#2-6-6-StringTable-垃圾回收" class="headerlink" title="2.6.6 StringTable 垃圾回收"></a>2.6.6 StringTable 垃圾回收</h3><p>因为在jdk1.7版本以后，字符串常量池是放在堆中，如果堆空间不足，字符串常量池也会进行垃圾回收。如下演示代码，设置最大堆内存为10m 并打印 gc 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo009</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123; <span class="comment">// j=100, j=10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-7-StringTable-性能调优"><a href="#2-6-7-StringTable-性能调优" class="headerlink" title="2.6.7 StringTable 性能调优"></a>2.6.7 StringTable 性能调优</h3><ul>
<li>StringTable 的数据结构是哈希表，所以可以适当增加哈希表桶的大小，来减少字符长放入StringTable所需的时间<ul>
<li>设置StringTable桶大小参数：<code>-XX:StringTableSize=&lt;桶个数&gt;</code></li>
</ul>
</li>
<li>对于有些重复的字符串可以考虑放入常量池，可以减少内存占用</li>
</ul>
<h2 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h2><h3 id="2-7-1-定义"><a href="#2-7-1-定义" class="headerlink" title="2.7.1 定义"></a>2.7.1 定义</h3><p>直接内存并不是JVM内存区域的一部分，<strong>不受JVM内存回收管理</strong>，<strong>常见于NIO操作用于数据缓存区</strong>，<strong>分配回收成本高但读写性能高</strong>。</p>
<p>java程序资源文件读取过程中，未使用直接内存和使用直接内存区别如下：</p>
<ul>
<li><strong>未使用直接内存</strong><ul>
<li>需要从用户态向内核态申请资源，内核态会创建系统缓冲区，用户态会创建一个java 缓冲区byte[]，然后数据从系统缓存区复制到java缓存区</li>
<li><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-7-1.png?x-oss-process=style/watermarking"></li>
</ul>
</li>
<li><strong>使用直接内存</strong><ul>
<li>需要从用户态向内核态申请资源，即内核态会创建一块直接内存direct memory，这块direct memory内存可以在用户态、内核态使用。直接内存是操作系统和Java代码都可以访问的一块区域，无需将数据从系统内存复制到Java堆内存，从而提高了效率</li>
<li><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-7-2.png?x-oss-process=style/watermarking"></li>
</ul>
</li>
</ul>
<p><strong>使用普通内存方式与使用直接内存方式读取大文件效率比较</strong>，演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 普通内存与直接内存读取文件效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo011</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FROM = <span class="string">&quot;C:\\Users\\taichangwei\\Downloads\\CentOS-6.10-x86_64-bin-DVD2.iso&quot;</span>; <span class="comment">//一个2.03G的文件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TO = <span class="string">&quot;E:\\a.iso&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1Mb = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        io();</span><br><span class="line">        directBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(FROM).getChannel();</span><br><span class="line">             FileChannel to = <span class="keyword">new</span> FileOutputStream(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = from.read(bb);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bb.flip();</span><br><span class="line">                to.write(bb);</span><br><span class="line">                bb.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream from = <span class="keyword">new</span> FileInputStream(FROM);</span><br><span class="line">             FileOutputStream to = <span class="keyword">new</span> FileOutputStream(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[_1Mb];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = from.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行三次分别用时</span></span><br><span class="line"><span class="comment">io 用时：4944.8368</span></span><br><span class="line"><span class="comment">directBuffer 用时：1927.7912</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">io 用时：4989.7547</span></span><br><span class="line"><span class="comment">directBuffer 用时：2287.7028</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">io 用时：5022.2618</span></span><br><span class="line"><span class="comment">directBuffer 用时：2453.5307</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-直接内存溢出"><a href="#2-7-2-直接内存溢出" class="headerlink" title="2.7.2 直接内存溢出"></a>2.7.2 直接内存溢出</h3><p>直接内存虽然不受JVM内存管理，但是物理内存是有限的，所以直接内存还是会存在内存溢出，<strong>java.lang.OutOfMemoryError: Direct buffer memory</strong></p>
<p>演示直接内存溢出，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 直接内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo012</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _100Mb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>循环了 36 次，使用了3.6G的内存导致内存溢出了</p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/2-7-3.png?x-oss-process=style/watermarking"></p>
<h3 id="2-7-3-直接内存的分配及回收原理"><a href="#2-7-3-直接内存的分配及回收原理" class="headerlink" title="2.7.3 直接内存的分配及回收原理"></a>2.7.3 直接内存的分配及回收原理</h3><ul>
<li><p>底层使用了<strong>UnSafe</strong>对象完成直接内存的<strong>分配及回收</strong>，并且回收需要主动调用**freeMemory()**方法</p>
<ul>
<li><p>直接内存分配及回收的底层原理演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 直接内存分配及回收的底层原理演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo014</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//暂定等待。此时查看任务管理器(windows系统)，会发现有一个占用1G内存的java程序</span></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        <span class="comment">//暂定等待。此时查看任务管理器(windows系统)，会发现刚才占用1G内存的java程序内存释放了</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Unsafe 构造方法是私有化的，只能通过反射获得</span></span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通常情况是我们是使用 “<code>ByteBuffer.allocateDirect(int capacity)</code>“ 来申请直接内存就可以了。<strong>ByteBuffer</strong>的实现类内部使用了<strong>Cleaner</strong>（虚引用）<strong>来检测ByteBuffer</strong>，<strong>一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean()方法调用freeMemory()来释放内存</strong></p>
<ul>
<li><p>allocateDirect(int capacity) 方法内部实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectByteBuffer(int cap) 方法内部实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;            </span><br><span class="line">    </span><br><span class="line">       <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">       <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">       <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">       <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">       Bits.reserveMemory(size, cap);</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           base = unsafe.allocateMemory(size);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">           Bits.unreserveMemory(size, cap);</span><br><span class="line">           <span class="keyword">throw</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">       unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="comment">// Round up to page boundary</span></span><br><span class="line">           address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           address = base;</span><br><span class="line">       &#125;</span><br><span class="line">       cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">       att = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了一个Cleaner的create()方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里指的是DirectByteBuffer对象）被回收以后，就会调用Cleaner的clean()方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.thunk.run();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">    </span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>其中 “<code>this.thunk</code>“ 是上一步传入的 <code>Deallocator</code> 对象，它的run方法内部实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jvm内存结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装归纳</title>
    <url>/20200308/linux4/3c087d2cbe86.html</url>
    <content><![CDATA[<h2 id="1-Linux中软件安装方式"><a href="#1-Linux中软件安装方式" class="headerlink" title="1 Linux中软件安装方式"></a>1 Linux中软件安装方式</h2><h3 id="1-1-软件包安装"><a href="#1-1-软件包安装" class="headerlink" title="1.1 软件包安装"></a>1.1 软件包安装</h3><p>Linux中的软件包(即二进制包)，主要分为两类</p>
<ul>
<li><strong>RPM包</strong>：是由Red Hat 公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便，目前很多Linux发行版都在使用这种包管理机制，包括Fedora、CentOS、SuSE等。软件包文件后缀是 “<code>.rpm</code>“。</li>
<li><strong>DPKG包</strong>：是由Debian Linux 所开发出来的包管理机制，主要应用在Debian和Unbuntu中。软件包文件后缀是 “<code>.deb</code>“。</li>
</ul>
<a id="more"></a>

<p>不论是RPM还是DPKG机制，都存在软件包依赖问题，比如软件包A依赖软件包B，软件包B又依赖软件包C，即依赖关系是 “A -&gt; B -&gt; C”，那么就必须先安装C，在安装B，最后A才能安装成功。为了解决这种依赖问题，Linux开发商都提供了<strong>在线安装</strong>机制，通过这种机制可以自动解决依赖关系，安装A时会自动安装B和C，就不需要手动去一步步安装B和C了。基于<strong>RPM</strong>包管理机制开发出了<strong>YUM在线安装机制</strong>，基于<strong>DPKG</strong>包管理机制开发出了<strong>APT在线安装机制</strong>。</p>
<table>
<thead>
<tr>
<th>发行版代表</th>
<th>软件包管理机制</th>
<th>相关指令</th>
<th>在线安装机制(指令)</th>
</tr>
</thead>
<tbody><tr>
<td>Red Hat/CentOS</td>
<td>RPM</td>
<td>rpm, rpmbuild</td>
<td>YUM(yum)）</td>
</tr>
<tr>
<td>Debian/Ubuntu</td>
<td>DPKG</td>
<td>dpkg</td>
<td>APT(apt-get)</td>
</tr>
</tbody></table>
<p><strong>软件包安装优缺点</strong></p>
<ul>
<li>优点：<ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
</li>
<li>缺点：<ul>
<li>经过编译，不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>安装过程需要依赖关系。不过有在线安装机制可以弥补这个缺点</li>
</ul>
</li>
</ul>
<h3 id="1-2-源码包安装"><a href="#1-2-源码包安装" class="headerlink" title="1.2 源码包安装"></a>1.2 源码包安装</h3><p>所谓源码包一般就是指C语言开发的源代码文件的一个压缩包(<code>.tar.gz</code>或<code>.tar.bz2</code>)。源码包的编译用到了linux系统里的编译器 <strong>gcc</strong>，利用它就可以把C语言变成可执行的二进制文件，所以如果要使用源码包安装必须先安装 gcc 编译器(可以使用 <code>yum install -y gcc</code> 完成安装)。</p>
<p><strong>源码包安装优缺点</strong></p>
<ul>
<li>优点<ul>
<li>开源，如果有足够的能力，可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装，所以更加适合自己的系统，更加稳定、效率更高</li>
<li>卸载方便。直接删除安装目录即可</li>
</ul>
</li>
<li>缺点<ul>
<li>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制包安装时间长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ul>
</li>
</ul>
<h2 id="2-RPM-管理软件包"><a href="#2-RPM-管理软件包" class="headerlink" title="2 RPM 管理软件包"></a>2 RPM 管理软件包</h2><p><strong>RPM 软件包的命名规则为</strong>：<code>软件包名-版本-发布次数-Linux平台-硬件平台.rpm</code><br>以Apache软件包的包全名为例：”httpd-2.2.15-69.el6.centos.x86_64.rpm”<br>1、httpd：软件包名<br>2、2.2.15：软件版本<br>3、69：软件发布的次数<br>4、el6.centos：适合的Linux平台<br>5、x86_64：适合的硬件平台，这里表示64位<br>6、rpm：rpm包的扩展名，注意Linux是没有扩展名的概念，这里是为了方便管理员识别</p>
<p><strong>RPM 包来源：</strong></p>
<ul>
<li>第一种方式，官网下载需要安装的RPM包</li>
<li>第二种方式，通过挂载安装光盘，光盘中包含所有的RPM包。以 Centos6 为例：<ol>
<li>给系统添加光盘，如果是虚拟机则直接在设置里找到虚拟光驱添加光盘映像文件(*.iso)即可。Centos6有两个盘，一般第一张光盘就包含了大部分常用的RPM包，也可以同时两张都挂载。如果两盘都添加的话，对应的设配文件分别为，<code>/dev/cdrom</code>、<code>/dev/cdrom1</code></li>
<li>创建两个目录作为光盘挂载点，<code>mkdir /mnt/cd1/ /mnt/cd2/</code></li>
<li>挂载光盘，<code>mount /dev/cdrom /mnt/cd1/</code>、<code>mount /dev/cdrom1 /mnt/cd2/</code>。挂载完成后，可在<code>/mnt/cd1/Packages/</code>和<code>/mnt/cd2/Packages/</code>目录下看到所有的RPM包</li>
</ol>
</li>
</ul>
<p><strong>RPM 包的默认安装位置如下：</strong></p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/</td>
<td>配置文件的安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<h3 id="2-1-RPM-命令"><a href="#2-1-RPM-命令" class="headerlink" title="2.1 RPM 命令"></a>2.1 RPM 命令</h3><p>RPM软件包的管理工具是 <code>rpm</code> 命令，命令格式：<code>rpm 选项 [软件包名]</code></p>
<ul>
<li>选项(在下面对应的场景会具体说明)</li>
<li><strong>软件包名</strong>：指定要操做的rpm软件包。如果操作的是未安装过的软件包，要使用<strong>包全名</strong>，而且要注意绝对路径；如果操作的是已安装过的软件包，可以在任意目录下直接使用包名，<strong>因为如果软件安装完毕，该软件的相关信息会被写入<code>/var/lib/rpm/</code> 目录下的数据库文件中</strong>(这个目录下的数据库文件很重要，后续软件升级和卸载就就依赖于这个数据库)</li>
</ul>
<h3 id="2-2-RPM-安装"><a href="#2-2-RPM-安装" class="headerlink" title="2.2 RPM 安装"></a>2.2 RPM 安装</h3><p>安装命令：<code>rpm -ivh 包全名</code></p>
<ul>
<li>选项<ul>
<li><code>-i</code>：安装(install)</li>
<li><code>-v</code>：显示详细信息</li>
<li><code>-h</code>：打印#显示安装进度</li>
<li><code>--nodeps</code>：不检测依赖性安装。软件安装时会检测依赖性，如果所依赖的软件还未安装则会报错，加上这个选项则不检测依赖强制安装，但这样安装的软件一般不能使用，建议不要这样做。</li>
<li><code>--replacefiles</code>：替换文件安装。如果安装的软件包中的部分文件已经存在，则会安装报错，使用该选项就会覆盖现有文件继续安装</li>
<li><code>--replacepkgs</code>：替换软件安装。如果软件包已经安装，使用该选项可把软件包重新安装一遍</li>
<li><code>--force</code>：强制安装。不管是否已经安装，都重新安装，相当于 “–replacefiles” 和 “–replacepkgs” 的综合</li>
<li><code>--test</code>：测试安装。不会实际安装，只是检测一下依赖</li>
<li><code>--prefix=安装路径</code>：指定安装路径。为安装的软件指定安装路径，而不是使用默认安装路径。注意：如果指定了安装路径，软件没有安装到默认路径中的话，系统会找不到这些安装的软件，而需要进行手工配置才能被系统识别，所以RPM包一般建议采用默认路径安装</li>
</ul>
</li>
</ul>
<h3 id="2-3-RPM-升级"><a href="#2-3-RPM-升级" class="headerlink" title="2.3 RPM 升级"></a>2.3 RPM 升级</h3><p>升级命令：<code>rpm -Uvh 包全名</code> 或 <code>rpm -Fvh 包全名</code></p>
<ul>
<li>选项<ul>
<li><code>-U</code>：升级安装。如果没有安装过，系统直接安装，如果已安装的版本较旧，则升级到新版本</li>
<li><code>-F</code>：升级安装。如果没有安装过，则不会安装，必须安装有较旧版本才能升级</li>
</ul>
</li>
</ul>
<h3 id="2-4-RPM-卸载"><a href="#2-4-RPM-卸载" class="headerlink" title="2.4 RPM 卸载"></a>2.4 RPM 卸载</h3><p>卸载命令：<code>rpm -e 包名</code></p>
<ul>
<li>选项<ul>
<li><code>-e</code>：卸载软件包</li>
<li><code>--nodeps</code>：卸载时不检查依赖性。如果卸载的软件被其他软件依赖，卸载失败，加上此选项可强制卸载</li>
</ul>
</li>
</ul>
<p>注意：卸载已安装的软件使用包名即可，不需要使用包全名</p>
<h3 id="2-5-RPM-查询"><a href="#2-5-RPM-查询" class="headerlink" title="2.5 RPM 查询"></a>2.5 RPM 查询</h3><p><strong>1. 查询软件包是否安装</strong>：<code>rpm -q 包名</code></p>
<ul>
<li>选项：<ul>
<li><code>-q</code>：查询（query）</li>
</ul>
</li>
</ul>
<p><strong>2. 查询系统中所有安装的软件包</strong>：<code>rpm -qa</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：所有（all）</li>
</ul>
</li>
</ul>
<p><strong>3. 查询软件包的详细信息</strong><br>已安装：<code>rpm -qi 包名</code><br>未安装：<code>rpm -qip 包全名</code></p>
<ul>
<li>选项：<ul>
<li><code>-i</code>：查询软件信息（information）</li>
<li><code>-p</code>：查询没有安装的软件包（package）</li>
</ul>
</li>
</ul>
<p><strong>4. 查询软件包的文件列表和安装目录</strong><br>已安装：<code>rpm -ql 包名</code><br>未安装：<code>rpm -qlp 包全名</code></p>
<ul>
<li>选项：<ul>
<li><code>-l</code>：列出软件包中所有文件和软件所安装的目录(list)</li>
</ul>
</li>
</ul>
<p><strong>5. 查询系统文件属于哪个软件包</strong>：<code>rpm -qf 系统文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>：查询拥有指定文件的软件包(file)</li>
</ul>
</li>
</ul>
<p><strong>6. 查询软件包所依赖的其他软件包</strong><br>已安装：<code>rpm -qR 包名</code><br>未安装：<code>rpm -qRp 包全名</code></p>
<ul>
<li>选项：<ul>
<li><code>-R</code>：查询软件包的依赖性(required)</li>
</ul>
</li>
</ul>
<h3 id="2-6-RPM-验证"><a href="#2-6-RPM-验证" class="headerlink" title="2.6 RPM 验证"></a>2.6 RPM 验证</h3><p><strong>1. 校验指定的已安装RPM包</strong>：<code>rpm -V 包名</code></p>
<ul>
<li>选项：<ul>
<li><code>-V</code>：校验指定的RPM包中的文件(verify)</li>
</ul>
</li>
</ul>
<p>如果执行命令后无任何提示，表明没有做任何修改，如果执行命令后有内容输出，则软件包中的文件被修改过。下面假设已安装的Apache配置文件 “/etc/httpd/conf/httpd.conf” 被修改过为例，来说明一下校验输出的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -V httpd</span><br><span class="line">S.5....T.  c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列(“S.5….T.”)是验证的内容，具体字母含义如下：<ul>
<li><code>S</code>: 文件大小是否改变</li>
<li><code>M</code>: 文件的类型或文件的权限( rwx )是否被改变</li>
<li><code>5</code>: 文件MD5 校验和是否改变( 可以看成文件内容是否改变 )</li>
<li><code>D</code>: 设备的主从代码是否改变</li>
<li><code>L</code>: 文件路径是否改变</li>
<li><code>U</code>: 文件的属主( 所有者 ) 是否改变</li>
<li><code>G</code>: 文件的属组是否改变</li>
<li><code>T</code>: 文件的修改时间是否改变</li>
</ul>
</li>
<li>第二列(“c”)是被修改的文件类型，有以下几种：<ul>
<li><code>c</code>: 配置文件(config file)</li>
<li><code>d</code>: 普通文档(documentation)</li>
<li><code>g</code>: “鬼”文件, 很少见, 就是该文件不应该被这个RPM包包含(ghost file)</li>
<li><code>L</code>: 授权文件(license file)</li>
<li><code>r</code>: 描述文件(read me) </li>
</ul>
</li>
<li>第三列(“/etc/httpd/conf/httpd.conf”)被修改的具体文件</li>
</ul>
<p><strong>2. 校验本机所有已安装RPM包</strong>：<code>rpm -Va</code></p>
<p><strong>3. 校验某个系统文件是否被修改</strong>：<code>rpm -Vf 系统文件</code></p>
<h2 id="3-YUM-管理软件包"><a href="#3-YUM-管理软件包" class="headerlink" title="3 YUM 管理软件包"></a>3 YUM 管理软件包</h2><h3 id="3-1-YUM-源文件介绍"><a href="#3-1-YUM-源文件介绍" class="headerlink" title="3.1 YUM 源文件介绍"></a>3.1 YUM 源文件介绍</h3><p><strong>yum 源</strong>指的就是获取 rpm 包的位置(默认就是官网服务器，包含所有的软件包)。yum源配置文件保存在 <code>/etc/yum.repos.d/</code> 目录下，一共有5个扩展名为 “.repo” 的文件 <code>CentOS-Base.repo</code>、<code>CentOS-fasttrack.repo</code>、<code>CentOS-Vault.repo</code>、<code>CentOS-Debuginfo.repo</code>、<code>CentOS-Media.repo</code>。默认情况下只有 <code>CentOS-Base.repo</code> 文件是生效，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# cat CentOS-Base.repo </span><br><span class="line"># CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client.  You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist&#x3D; does not work for you, as a fall back you can try the </span><br><span class="line"># remarked out baseurl&#x3D; line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name&#x3D;CentOS-$releasever - Base</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;os&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br><span class="line">#released updates </span><br><span class="line">[updates]</span><br><span class="line">name&#x3D;CentOS-$releasever - Updates</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;updates&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;updates&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name&#x3D;CentOS-$releasever - Extras</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;extras&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;extras&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name&#x3D;CentOS-$releasever - Plus</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;centosplus&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;centosplus&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br><span class="line">#contrib - packages by Centos Users</span><br><span class="line">[contrib]</span><br><span class="line">name&#x3D;CentOS-$releasever - Contrib</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;contrib&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;contrib&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 CentOS-Base.repo 文件中有5个 yum 源容器，这里主要解释一下 <code>[base]</code> 容器(其他容器类似)：</p>
<ul>
<li><code>[base]</code>：容器名称，一定要放在 [ ] 中</li>
<li><code>name</code>：容器说明，可以自己随便写</li>
<li><code>mirrorlist</code>：镜像站点，这个可以注释掉</li>
<li><code>baseurl</code>：yum源服务器的地址。mirrorlist是由yum程序自行去找镜像站点，baseurl则是指定固定的一个地址</li>
<li><code>enabled</code>：此容器是否生效，如果<strong>不写</strong>或者<strong>enabled=1</strong>则表示此容器生效，写成<strong>enabled=0</strong>则表示次容器不生效</li>
<li><code>gpgcheck</code>：如果为1表示RPM的数字证书生效；如果为0表示RPM的数字证书不生效</li>
<li><code>gpgkey</code>：数字证书的公钥文件保存位置</li>
</ul>
<p><strong>搭建本地光盘为yum源</strong><br>如果在没有网的情况下，可以把挂载的光盘作为yum源。</p>
<p>第一步，首先挂载光盘。这里假设已经挂载了两张光盘，挂载点分别为<code>/mnt/cd1/</code>和<code>/mnt/cd2/</code><br>第二步，修改 <code>CentOS-Media.repo</code> 文件。修改baseurl为两个光盘的挂载点，修改enabled=1。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c6-media]</span><br><span class="line">name&#x3D;CentOS-$releasever - Media</span><br><span class="line"># 地址为本地光盘的挂载点</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt&#x2F;cd1&#x2F;</span><br><span class="line">        file:&#x2F;&#x2F;&#x2F;mnt&#x2F;cd2&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line"># 把 enabled 改为1让这个容器生效</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三步，为了<code>CentOS-Media.repo</code>文件真正的生效，需要使其他的yum源配置文件失效。因为只有扩展名为 “*.repo” 的文件才能作为yum源配置文件，可以修改其他yum源配置为备份文件，如 <code>mv CentOS-Base.repo CentOS-Base.repo.bak</code></p>
<h3 id="3-2-YUM-命令"><a href="#3-2-YUM-命令" class="headerlink" title="3.2 YUM 命令"></a>3.2 YUM 命令</h3><p><strong>yum命令</strong>是在Fedora和RedHat以及SUSE中基于 <strong>rpm</strong> 的软件包管理器，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum 命令格式：<code>yum [选项] COMMAND [软件包]</code></p>
<ul>
<li>选项：<ul>
<li><code>-y</code>：自动回答”yes”，不再询问。如果不加该选项，安装过程中每个涉及的包安装都要手工回答 “yes” or “no”</li>
<li><code>-q</code>：静默模式。不显示安装过程</li>
<li><code>-C</code>：完全从缓存中运行，而不去下载或者更新任何头文件</li>
</ul>
</li>
<li><strong>COMMAND</strong> (要进行的操作)<ul>
<li><code>install</code>：执行安装操作</li>
<li><code>update</code>：执行升级操作</li>
<li><code>remove</code>：执行卸载操作</li>
<li><code>list</code>：显示可用软件包列表</li>
<li><code>search</code>：根据关键字匹配软件包</li>
<li><code>info</code>：显示软件包信息</li>
</ul>
</li>
<li>软件包：如果为包名，则默认为软件包的最新版本；如果要指定软件包版本，则需要使用包全名</li>
</ul>
<h3 id="3-3-YUM-安装"><a href="#3-3-YUM-安装" class="headerlink" title="3.3 YUM 安装"></a>3.3 YUM 安装</h3><p>安装指定软件包：<code>yum -y install 包名</code><br>安装全部软件包：<code>yum -y isntall</code> (不常用)</p>
<h3 id="3-4-YUM-升级"><a href="#3-4-YUM-升级" class="headerlink" title="3.4 YUM 升级"></a>3.4 YUM 升级</h3><p>升级指定软件包：<code>yum -y update 包名</code><br>升级全部软件包：<code>yum -y update</code> (不常用)</p>
<h3 id="3-5-YUM-卸载"><a href="#3-5-YUM-卸载" class="headerlink" title="3.5 YUM 卸载"></a>3.5 YUM 卸载</h3><p>卸载指定软件包：<code>yum remove 包名</code></p>
<h3 id="3-6-YUM-查询"><a href="#3-6-YUM-查询" class="headerlink" title="3.6 YUM 查询"></a>3.6 YUM 查询</h3><p><strong>1. 查询软件包列表</strong><br>查询yum源服务器上所有可安装的软件包列表：<code>yum list</code><br>查询yum源服务器上是否存在某个软件包：<code>yum list 包名</code></p>
<p><strong>2. 查询关键字属于哪个软件包</strong><br>命令格式：<code>yum search 关键字</code><br>一般用于查找 某个指令 是由哪个软件包提供的。比如，要使用 “ifconfig” 指令，需要先安装 “net-tools” 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum search ifconfig</span><br><span class="line">已加载插件：fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.huaweicloud.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Matched: ifconfig &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">net-tools.x86_64 : Basic networking tools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 查询指定软件包信息</strong>：<code>yum info 软件包</code></p>
<h3 id="3-6-YUM-缓存"><a href="#3-6-YUM-缓存" class="headerlink" title="3.6 YUM 缓存"></a>3.6 YUM 缓存</h3><p>默认情况下，通过 yum 成功安装软件后，会把下载的软件包删除。如果要保留下载的软件包，可以编辑配置文件 <code>/etc/yum.conf</code>，把里面 “keepcache” 参数改为 1 (默认 keepcache=0 )，这样每次通过 yum 安装软件时，会把下载的软件包缓存在 <code>/var/cache/yum/</code> 目录下，下次再安装相同的软件时，可以从缓存中获取软件包，即使在没有网络的情况下也可正常安装。</p>
<p><strong>1. 清除缓存</strong>：<code>yum clean packages|headers|oldheaders|all</code><br><code>packages</code>：清除缓存目下的软件包<br><code>headers</code>：清除缓存目录下的 headers<br><code>oldheaders</code>：清除缓存目录下旧的 headers<br><code>all</code>：清除全部</p>
<p><strong>2. 重新建立新的缓存</strong>：<code>yum makecache</code></p>
<p><strong>3. 只从缓存中查找软件包并安装</strong>：<code>yum -C install 包名</code></p>
<h3 id="3-7-YUM-软件组管理"><a href="#3-7-YUM-软件组管理" class="headerlink" title="3.7 YUM 软件组管理"></a>3.7 YUM 软件组管理</h3><p><strong>软件组</strong>指的是一组相关的软件包(注意，这里指的不是依赖关系)，通过 yum 命令可以对组内软件包批量管理。</p>
<p><strong>1. 列出所有可用软件组</strong>：<code>yum grouplist</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum grouplist</span><br><span class="line">已加载插件：fastestmirror, security</span><br><span class="line">设置组进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.huaweicloud.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">已安装的组：</span><br><span class="line">   Java 平台</span><br><span class="line">   NFS 文件服务器</span><br><span class="line">   ...省略...</span><br><span class="line">Installed Language Groups:</span><br><span class="line">   中文支持 [zh]</span><br><span class="line">   亚美尼亚语支持 [hy]</span><br><span class="line">   ...省略...</span><br><span class="line">有效的组:</span><br><span class="line">   MySQL 数据库服务器</span><br><span class="line">   万维网服务器</span><br><span class="line">   ...省略...</span><br><span class="line">Available Language Groups:</span><br><span class="line">   上索布语支持 [hsb]</span><br><span class="line">   不丹语支持 [dz]</span><br><span class="line">   ...省略...</span><br><span class="line">完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>2. 查询组内包含哪些软件</strong>：<code>yum groupinfo &quot;软件组名&quot;</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum groupinfo &quot;万维网服务器&quot;</span><br><span class="line">已加载插件：fastestmirror, security</span><br><span class="line">设置组进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.huaweicloud.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line"></span><br><span class="line">组：万维网服务器</span><br><span class="line"> 描述：允许将系统作为 web 服务器使用，并运行 Perl 和 Python web 应用程序。</span><br><span class="line"> 必要的软件包：</span><br><span class="line">   httpd</span><br><span class="line"> 默认的软件包：</span><br><span class="line">   crypto-utils</span><br><span class="line">   httpd-manual</span><br><span class="line">   mod_perl</span><br><span class="line">   mod_ssl</span><br><span class="line">   mod_wsgi</span><br><span class="line">   webalizer</span><br><span class="line"> 可选的软件包：</span><br><span class="line">   certmonger</span><br><span class="line">   libmemcached</span><br><span class="line">   memcached</span><br><span class="line">   mod_auth_kerb</span><br><span class="line">   ...省略...</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>注意：使用本地终端查出的组名都是英文的，命令中的软件组名也需要使用英文；远程终端(如Xshell)如果支持中文，查出的软件组名是中文的，所以命令中的软件组名既可以使用中文，也可以使用英文，<code>yum groupinfo &quot;万维网服务器&quot;</code> 和 <code>yum groupinfo &quot;Web Server&quot;</code> 是等效的</p>
<p><strong>3. 安装软件组内所有软件</strong>：<code>yum groupinstall &quot;软件组名&quot;</code><br><strong>4. 卸载软件组内多有软件</strong>：<code>yum groupremove &quot;软件组名&quot;</code></p>
<h2 id="4-DPKG-管理软件包"><a href="#4-DPKG-管理软件包" class="headerlink" title="4 DPKG 管理软件包"></a>4 DPKG 管理软件包</h2><p><strong>DPKG 软件包的命名规则为</strong>：<code>软件包名_版本号-修订号_平台.deb</code><br>例如：<code>openssh-server_8.2p1-4_amd64.deb</code></p>
<h3 id="4-1-DPKG-命令"><a href="#4-1-DPKG-命令" class="headerlink" title="4.1 DPKG 命令"></a>4.1 DPKG 命令</h3><p>DPKG 包的管理工具是 <code>dpkg</code> 命令，命令格式：<code>dpkg 选项 [软件包名]</code></p>
<ul>
<li>选项(在下面对应的场景会具体说明)</li>
<li>软件包名：指定要操做的dpkg软件包。如果操作的是未安装过的软件包，要使用<strong>包全名</strong>，而且要注意绝对路径；如果操作的是已安装过的软件包，可以在任意目录下直接使用包名，<strong>因为和RPM类似，DPKG包管理也存在文件数据库来维护已安装的软件信息， 如果软件安装完毕，该软件的相关信息会被写入<code>/var/lib/dpkg/</code>目录下的数据库文件中，一般”/var/lib/dpkg/status” 文件中存储软件状态和控制信息，”/var/lib/dpkg/info/xxx.list”文件中记录了软件安装文件清单</strong></li>
</ul>
<h3 id="4-2-DPKG-安装"><a href="#4-2-DPKG-安装" class="headerlink" title="4.2 DPKG 安装"></a>4.2 DPKG 安装</h3><p>安装命令：<code>dpkg -i 包全名</code></p>
<ul>
<li>选项<ul>
<li><code>-i</code>：安装</li>
<li><code>--unpack</code>：解开软件包</li>
<li><code>--configure</code>：配置软件包<blockquote>
<p><code>-i</code> 选项所做操作包含解开软件包和配置软件包，相当于这两步操作：<br><code>dpkg --unpack 包全名</code><br><code>dpkg --configure 包名</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-DPKG-卸载"><a href="#4-3-DPKG-卸载" class="headerlink" title="4.3 DPKG 卸载"></a>4.3 DPKG 卸载</h3><p>卸载命令：<code>dpkg -r|-P 包名</code>    </p>
<ul>
<li>选项<ul>
<li><code>-r</code>：删除已安装的软件包，但保留配置文件</li>
<li><code>-P</code>：删除已安装软件包，完全清除包（含配置文件）<h3 id="4-4-DPKG-查询"><a href="#4-4-DPKG-查询" class="headerlink" title="4.4 DPKG 查询"></a>4.4 DPKG 查询</h3></li>
</ul>
</li>
<li>*1. 查询已安装软件包列表**，命令：<code>dpkg -l [包名]</code></li>
<li>选项<ul>
<li><code>-l</code>：查询已安装软件包列表，包含状态、版本信息</li>
<li><code>包名</code>：查询指定的软件包，如果省略查询全部已安装软件包。包名可使用通配符</li>
</ul>
</li>
</ul>
<p>示例：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux004.png?x-oss-process=style/watermarking" alt="image.png"><br>图中，第一列表示软件包状态标识，状态标识共三位字符表示，<br>第一位，期望状态：<br><code>u(Unknown)</code>: 状态未知，这意味着软件包未安装，并且用户也未发出安装请求<br><code>i(Install)</code>: 用户请求安装软件包<br><code>r(Remove)</code>: 用户请求卸载软件包<br><code>p(Purge)</code>: 用户请求清除软件包<br><code>h(Hold)</code>: 用户请求保持软件包版本锁定</p>
<p>第二位，当前状态：<br><code>n(Not)</code>：软件包未安装<br><code>i(Inst)</code>：软件包安装并完成配置<br><code>c(Conf-files)</code>：软件包以前安装过，现在删除了，但是它的配置文件还留在系统中<br><code>U(Unpacked)</code>：软件包仅被解包，还未配置<br><code>F(halF-conf)</code>：试图配置软件包，但是失败了<br><code>H(Half-inst)</code>：软件包安装，但是但是没有成功<br><code>W(trig-aWait)</code>：触发器等待<br><code>T(Trig-pend)</code>：触发器未决</p>
<p>第三位，错误状态：<br><code>h</code>：软件包被强制保持，因为有其它软件包依赖需求，无法升级<br><code>R</code>：Reinst-required，软件包被破坏，可能需要重新安装才能正常使用(包括删除)<br><code>x</code>：软包件被破坏，并且被强制保持</p>
<p><strong>2. 列出软件包关联文件</strong>，命令：<code>dpkg -L 包名</code> 或 <code>dpkg -c 包全名</code></p>
<ul>
<li>选项<ul>
<li><code>-L</code>：列出已安装软件包关联文件列表</li>
<li><code>-c</code>：列出未安装软件包关联文件列表</li>
</ul>
</li>
</ul>
<p>也可以通过该命令查看软件包文件安装目录位置</p>
<p><strong>3. 显示软件包的详细状态</strong>，命令：<code>dpkg -s 包名</code></p>
<ul>
<li>选项<ul>
<li><code>-s</code> 或 <code>--status</code>：显示软件包的详细状态</li>
</ul>
</li>
</ul>
<p><strong>4. 搜索含有指定文件的软件包</strong>，命令：<code>dpkg -S 文件名</code></p>
<ul>
<li>选项<ul>
<li><code>-S</code> 或 <code>--search</code>：搜索含有指定文件的软件包。文件名可使用通配符<br>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taicw@taicw-PC:~&#x2F;Downloads$ dpkg -S apache2.conf</span><br><span class="line">apache2: &#x2F;etc&#x2F;apache2&#x2F;apache2.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>*5. 搜索系统中损坏的软件包**，命令：<code>dpkg -C</code></li>
</ul>
<h2 id="5-APT-管理软件包"><a href="#5-APT-管理软件包" class="headerlink" title="5 APT 管理软件包"></a>5 APT 管理软件包</h2><h3 id="5-1-APT-源文件介绍"><a href="#5-1-APT-源文件介绍" class="headerlink" title="5.1 APT 源文件介绍"></a>5.1 APT 源文件介绍</h3><p><strong>APT</strong> 与 <strong>YUM</strong> 类似，都是从远程软件仓库获取软件包进行安装。其中相关文件说明如下：<br><code>/etc/apt/sources.list</code>：记录了软件源的地址<br><code>var/lib/dpkg/available</code>：文件的内容是软件包的描述信息，该文件包括当前系统所使用的安装源中的所有软件包，其中包括当前系统中已安装的和未安装的软件包信息<br><code>/var/lib/apt/lists/</code>：使用 “<code>apt-get update</code>“ 命令扫会描软件源服务器，并为源服务器所有软件资源建立索引文件保存至本地目录”/var/lib/apt/lists/“下，提高系统查询效率<br><code>/var/cache/apt/archives/</code>：通过 “apt-get” 安装下载的软件包都缓存在这里。</p>
<h3 id="5-2-APT-命令"><a href="#5-2-APT-命令" class="headerlink" title="5.2 APT 命令"></a>5.2 APT 命令</h3><p>APT 管理软件包，主要由以下几个命令组成：<br><code>apt-get</code>：主要用来安装、升级和卸载软件，智能解决依赖关系(新版可用 <code>apt</code> 命令代替，去掉了”-get”)<br><code>apt-cache</code>：查询软件包缓存文件<br><code>apt-file</code>：软件包查找工具，可以查到软件包所含的文件和安装的位置</p>
<h3 id="5-3-刷新源"><a href="#5-3-刷新源" class="headerlink" title="5.3 刷新源"></a>5.3 刷新源</h3><p>命令：<code>apt-get update</code><br>该命令扫描源服务器，更新软件包列表。最好定期运行这一命令以确保软件包列表是最新的，<strong>或者在安装和升级软件之前执行该命令</strong></p>
<h3 id="5-4-APT-安装"><a href="#5-4-APT-安装" class="headerlink" title="5.4 APT 安装"></a>5.4 APT 安装</h3><p>安装命令：<code>apt-get install 包名</code></p>
<h3 id="5-5-APT-升级"><a href="#5-5-APT-升级" class="headerlink" title="5.5 APT 升级"></a>5.5 APT 升级</h3><p>升级命令：</p>
<ul>
<li><code>apt-get upgrade</code><ul>
<li>更新所有已安装软件。只是简单的更新包，不管这些依赖，它不能添加新的软件包，或是删除软件包，并且不更改相应软件的配置文件</li>
</ul>
</li>
<li><code>apt-get dist-upgrade</code><ul>
<li>可以根据依赖关系的变化，添加软件包，删除软件包，并且更改相应软件的配置文件，包括升级系统版本</li>
</ul>
</li>
</ul>
<h3 id="5-6-APT-卸载"><a href="#5-6-APT-卸载" class="headerlink" title="5.6 APT 卸载"></a>5.6 APT 卸载</h3><p>卸载命令：</p>
<ul>
<li><p><code>apt-get remove 包名</code></p>
<ul>
<li>删除指定软件，但是保留配置文件</li>
</ul>
</li>
<li><p><code>apt-get --purge remove 包名</code></p>
<ul>
<li>删除指定软件，同时删除配置文件</li>
</ul>
</li>
<li><p><code>apt-get autoremove</code></p>
<ul>
<li>删除系统内部不需要的依赖软件(一般指安装其他软件包时通过依赖安装的软件包)。该操作可能存在误删，无特殊需求尽量不要执行该命令</li>
</ul>
</li>
</ul>
<h3 id="5-7-APT-缓存清理"><a href="#5-7-APT-缓存清理" class="headerlink" title="5.7 APT 缓存清理"></a>5.7 APT 缓存清理</h3><p>使用 apt-get 安装软件时，会自动到软件源服务器下载需要的软件包(<code>xxx.deb</code> 文件)，这些文件缓存在 “/var/cache/apt/archives” 目录下，如果不需要这些文件可以执行如下命令将其清除，节约磁盘空间。</p>
<p>缓存清理命令：</p>
<ul>
<li><p><code>apt-get clean</code></p>
<ul>
<li>删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下所有”.deb” 文件</li>
</ul>
</li>
<li><p><code>apt-get autoclean</code></p>
<ul>
<li>仅删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下旧版本的软件包和无用的软件包文件，保留已安装软件包的 “.deb” 文件</li>
</ul>
</li>
</ul>
<h3 id="5-8-APT-检查"><a href="#5-8-APT-检查" class="headerlink" title="5.8 APT 检查"></a>5.8 APT 检查</h3><p>检查软件包是否有损坏的依赖：<code>apt-get check 包名</code></p>
<h3 id="5-9-APT-查询"><a href="#5-9-APT-查询" class="headerlink" title="5.9 APT 查询"></a>5.9 APT 查询</h3><p><strong>apt-cache</strong><br><code>apt-cache</code> 可以查询和显示已安装和可安装软件包的可用信息，它专门工作在本地的数据缓存上，不依赖于软件源的可用性(即离线查询)，而这些缓存可以通过比如 <code>apt-get update</code> 命令来更新。如果距离上一次更新的时间太久，那么它显示的信息可能就会过时。常用命令如下：</p>
<ul>
<li><code>apt-cache stats</code>：显示统计信息</li>
<li><code>apt-cache show 包名</code>：以便于阅读的格式介绍该软件包</li>
<li><code>apt-cache showpkg 包名</code>：显示软件包常规信息，依赖关系等</li>
<li><code>apt-cache policy 包名</code>：显示软件包的安装设置状态</li>
<li><code>apt-cache depends 包名</code>：显示指定软件包所依赖的软件包</li>
<li><code>apt-cache rdepends 包名</code>：显示软件包的反向依赖关系，即被哪些软件包依赖</li>
<li><code>apt-cache search 字符串</code>：根据正则表达式搜索软件包列表</li>
</ul>
<p><strong>apt-file</strong><br><code>apt-file</code> 软件包查找工具，可以查找某个文件属于哪个软件包。apt-file 个独立的软件包，使用之前需要先安装(<code>apt-get install apt-file</code>)。常用命令如下：</p>
<ul>
<li><code>apt-file update</code>：更新软件包的文件库，第一次使用或执行<code>apt-get update</code>后都需执行一次</li>
<li><code>apt-file search 文件名</code>：查找包含指定文件名的软件包，包括未安装的</li>
<li><code>apt-file list 包名</code>：显示指定软件包的文件</li>
</ul>
<h2 id="6-源码包安装"><a href="#6-源码包安装" class="headerlink" title="6 源码包安装"></a>6 源码包安装</h2><h3 id="6-1-注意事项"><a href="#6-1-注意事项" class="headerlink" title="6.1 注意事项"></a>6.1 注意事项</h3><ul>
<li><strong>什么情况下选择源码包安装？</strong><br>如果软件包是给大量客户提供访问的，建议源码包安装，因为源码包效率更高，如LAMP环境搭建；如果软件包是给Linux底层使用或者少量客户访问，建议使用rmp包安装，因为rmp包简单，不容易出错</li>
<li><strong>源码包从哪里来？</strong><br>rpm 包是光盘中直接包含的或者yum源服务器提供，一般不需要单独下载；而源码包是通过官方网站下载的，使用时需要单独下载。</li>
<li><strong>同一个软件是否可以用软件包方式安装后，同时又用源码包再安装一遍？</strong><br>答案是可以的，因为两种方式的软件安装位置不同，所以安装时相互不会有影响，但是需要注意，两个同时启动时需要修改端口，否则会端口冲突。一般情况下不会同一个软件安装两边，多装一个只会浪费资源</li>
</ul>
<h3 id="6-2-安装步骤"><a href="#6-2-安装步骤" class="headerlink" title="6.2 安装步骤"></a>6.2 安装步骤</h3><ol>
<li><p><strong>下载源码包</strong></p>
<ul>
<li>源码包格式一般为 <code>xxx.tar.gz</code>或 <code>xxx.tar.bz2</code>。linux下载工具参考：<a href="https://segmentfault.com/a/1190000022301195">wget 与 curl 命令详解</a></li>
<li>示例：<code> wget https://archive.apache.org/dist/httpd/httpd-2.2.15.tar.gz</code></li>
</ul>
</li>
<li><p><strong>解压缩</strong></p>
<ul>
<li>一般习惯把下载的源码包解压缩到 <code>/usr/local/src/</code> 目录下。解压缩命令参考: <a href="https://segmentfault.com/a/1190000021950993">Linux常用命令</a></li>
<li>示例：<code>tar -zxvf httpd-2.2.15.tar.gz -C /usr/local/src/</code></li>
</ul>
</li>
<li><p><strong>进入解压目录</strong></p>
<ul>
<li>示例：<code>cd /usr/local/src/httpd-2.2.15/</code></li>
</ul>
</li>
<li><p><strong>编译前准备，命令</strong>：<code>./configure --prefix=安装目录</code></p>
<ul>
<li><code>--prefix=安装目录</code>：指定安装目录。如果不指定，默认情况下会安装在 <code>/usr/local/包名/bin</code>, <code>/usr/local/包名/lib</code> 等目录下，安装文件比较分散不利于删除</li>
<li><code>configure</code> 指令是每个源码包都自带的脚本程序(即解压目录下一个名为”configure”的脚本文件)，非系统指令执行时必须指明路径，即”<code>./</code>“表明是当前路径下。执行该指令主要有如下作用：<ul>
<li>安装之前检测系统环境是否符合安装要求</li>
<li>定义需要的功能选项。如通过 “–prefix=安装目录” 指定安装目录，其他更多功能选项可以通过 “<code>./configure --help</code>“ 来查看</li>
<li>创建 <strong>Makefile</strong> 文件并把系统环境检测结果和定义的功能选项写入该文件，后续的编译和安装都需要依赖这个文件的内容</li>
</ul>
</li>
<li>示例：<code>./configure --prefix=/usr/local/apache2</code></li>
</ul>
</li>
<li><p><strong>编译，命令</strong>：<code>make</code></p>
<ul>
<li><code>make</code> 会调用 <code>gcc</code> 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为消耗时间，需要耐心等待</li>
</ul>
</li>
<li><p><strong>报错清空编译内容(非必须步骤)，命令</strong>：<code>make clean</code></p>
<ul>
<li>如果在执行 “<code>./configure</code>“ 或者 “<code>make</code>“ 命令时报错，解决报错问题后，需要重新执行命令时一定要先执行一下 “<code>make clean</code>“ 命令，它会清空 Makefile 文件和编译产生的 “.o” 头文件</li>
</ul>
</li>
<li><p><strong>安装，命令</strong>：<code>make install</code></p>
<ul>
<li>这个才是真正的安装，一般会输出程序的安装位置。如果忘记指安装目录，则可以把这个命令的执行过程保存下来，以备将来删除软件使用</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：<br>1.执行 <code>./configure</code> 命令时可能会提示缺少 <code>gcc</code> 等依赖程序，所以需要使用 yum 等方式先安装依赖程序即可</p>
<p>2.并不是所有的源码包安装一定是执行 “<code>./configure</code>“、”<code>make</code>“、”<code>make install</code>“ 这三个命令，只有极少数源码包安装命令可能有些不同，比如 mysql 版本 5.5 以后的源码包安装时，使用 “<code>cmake</code>“  命令替代了 “<code>./configure</code>“。一般源码包解压后都有安装的说明文档，安装之前可以先阅读以下说明文档</p>
<p>3.一般去第三方官网下载源码包时，也会提供已经编译好的二进制包，这种二进制包里面包括了已经经过编译可以马上运行的程序，所以解压后直接进入 “xxx/bin/“ 目录找到相关命令直接运行即可</p>
</blockquote>
<h3 id="6-3-卸载"><a href="#6-3-卸载" class="headerlink" title="6.3 卸载"></a>6.3 卸载</h3><p>通过源码包安装时如果指定了安装目录，比如 “<code>./configure --prefix=/usr/local/apache2</code>“，卸载时只需要删除整个安装目录就可以了 “<code>rm -rf /usr/local/apache2</code>“，而且是100%卸载，不会像windows那样经常会残留那多注册表之类的垃圾。</p>
<p>如果源码包安装时没有指定安装目录，那么安装软件生成的文件会分别存储在 /usr/local/ 下的 bin、lib、etc 等目录下，删除起来就比较麻烦一点了。所以建议源码包安装一定要指定安装目录，方便卸载。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>rpm</tag>
        <tag>yum</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>wget与curl命令详解</title>
    <url>/20200305/linux3/19aea672d7e8.html</url>
    <content><![CDATA[<h2 id="wget-命令"><a href="#wget-命令" class="headerlink" title="wget 命令"></a>wget 命令</h2><p><strong>wget命令</strong>用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<a id="more"></a>

<p>命令格式：<code>wget [选项] URL资源</code></p>
<p><strong>1. 下载单个文件</strong></p>
<ul>
<li><code>wget http://www.example.com/testfile.zip</code></li>
</ul>
<p>下载的文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）</p>
<p><strong>2. 下载并以不同的文件名保存</strong></p>
<ul>
<li><code>wget -O myfile.zip http://www.example.com/testfile.zip</code> <ul>
<li><code>-O 自定义文件名</code>：重命名下载的文件</li>
</ul>
</li>
</ul>
<p>如果不指定”-O” 选项，wget默认会以 url 路径最后一个 “<code>/</code>“ 的后面全部字符为下载的文件名，如<code>wget http://www.example.com/testfile?id=123</code>，下载后的文件名就为 <code>testfile?id=123</code></p>
<p><strong>3. 断点续传</strong></p>
<ul>
<li><code>wget -c http://www.example.com/testfile.zip</code><ul>
<li><code>-c</code>：继续接着执行上次未下载完的任务</li>
</ul>
</li>
</ul>
<p>当下载的文件特别大或者网络原因，文件没有下载完连接就已经被断开，使用 <code>-c</code> 选项可以在网络连接恢复时接着上次的下载任务继续下载，而不需要重头开始下载文件</p>
<blockquote>
<p>wget默认重试20次连接下载文件，如果网络一直有问题下载可能失败。如果需要的话，你可以使用<code>--tries</code>增加重试次数。例如设置最多重试40次：<code>wget --tries=40 http://www.example.com/testfile.zip</code></p>
</blockquote>
<p><strong>4. 后台下载</strong></p>
<ul>
<li><code>wget -b http://www.example.com/testfile.zip</code><ul>
<li><code>-b</code>：以后台运行的方式下载</li>
</ul>
</li>
</ul>
<p>对于下载非常大的文件不能及时下载完时，可以进行后台下载。后台下载时会在当前下载目录下创建一个 “wget-log” 文件记录下载日志，可以使用 <code>tail -f wget-log</code> 命令查看下载进度</p>
<p><strong>5. 带宽控制和下载配额</strong></p>
<ul>
<li><code>wget --limit-rate=下载速度 http://www.example.com/testfile.zip</code><ul>
<li><code>--limit-rate=下载速度</code>：限定不超过指定的下载速度。例如：–limit-rate=300k</li>
</ul>
</li>
</ul>
<p>当你执行wget的时候，它默认会占用全部可能的宽带下载，但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。</p>
<p>如果还需要限制下载配额，可使用选项 “<code>-Q 下载配额</code>“，下载数据超过了指定配额会停止下载。注意，该选项对于单个文件下载无效，只适用于<strong>多文件下载</strong>或<strong>递归下载</strong>，例如：<code>wget -Q 10m -i dowload.txt</code>，如果不指定下载配额会下载download.txt文件包含的所有url，如果指定了下载配额为10m，下载数据超过了10m会停止后面url的下载（一个文件正在下载过程中下载数据超过了下载配额会继续完成该文件的下载不会立即停止下载）。</p>
<p><strong>6. 多文件下载</strong></p>
<ul>
<li><code>wget -i url文件</code><ul>
<li><code>-i url文件</code>：从指定文件获取要下载的URL地址</li>
</ul>
</li>
</ul>
<p>如果有多个url资源需要下载，那么可以先生成一个文件，把下载地址的url按行写入该文件，然后使用 “-i” 选项指定该文件就可以批量下载了</p>
<p><strong>7. 密码认证下载</strong></p>
<ul>
<li><code>wget --http-user=USER --http-password=PASS http://www.example.com/testfile.zip</code><ul>
<li><code>--http-user=USER</code>：设置 http 用户名为 USER</li>
<li><code>--http-password=PASS</code>：设置 http 密码为 PASS</li>
<li><code>--ftp-user=USER</code>：设置 ftp 用户名为 USER</li>
<li><code>--ftp-password=PASS</code>：设置 ftp 密码为 PASS</li>
</ul>
</li>
</ul>
<p>对于需要证书做认证的网站，就只能利用其他下载工具了，例如curl</p>
<p><strong>8. 递归下载</strong></p>
<ul>
<li><code>wget -r http://www.example.com/path1/path2/</code><ul>
<li><code>-r</code>：递归在下整个站点（<a href="http://www.example.com)资源/">www.example.com）资源</a></li>
<li><code>-nd</code>：递归下载时不创建一层一层的目录，把所有的文件下载到当前目录；不指定该选项默认按照资源在站点位置创建相应目录</li>
<li><code>-np</code>：递归下载时不搜索上层目录，只在当前路径path2下进行下载；不指定该选项默认搜素整个站点</li>
<li><code>-A 后缀名</code>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-R 后缀名</code>：排除要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-L</code>：递归时不进入其它主机。不指定该选项的话，如果站点包含了外部站点的链接，这样可能会导致下载内容无限大</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例，只下载path2路径下的所有pdf和png文件，不创建额外目录全都保存在当前下载目录下:<br><code>wget -r -nd -np -A pdf,png http://www.example.com/path1/path2/</code></p>
</blockquote>
<h2 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h2><p><strong>curl命令</strong>是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>
<h3 id="与wget类似的下载功能"><a href="#与wget类似的下载功能" class="headerlink" title="与wget类似的下载功能"></a>与wget类似的下载功能</h3><p><strong>1. 单个文件下载</strong></p>
<ul>
<li><code>curl [-o 自定义文件名|-O] http://www.example.com/index.html</code><ul>
<li><code>-o 自定义文件名</code>：把服务器响应输出到指定文件</li>
<li><code>-O</code>：与<code>-o</code>选项作用一样，区别在于以 url 路径最后一个”/“之后的部分作为文件名</li>
</ul>
</li>
</ul>
<p>如果这两个选项都不写，curl 默认会把服务器响应内容输出到终端</p>
<p><strong>2. 断点续传</strong></p>
<ul>
<li><code>curl -O -C 偏移量 http://www.example.com/testfile.zip</code><ul>
<li><code>-C 偏移量</code>：从指定的偏移量处继续下载，偏移量以字节为单位</li>
</ul>
</li>
</ul>
<p>如果让curl自动推断出正确的续传位置可以使用 “<code>-</code>“ 代替偏移量，例如：<br><code>curl -O -C - http://www.example.com/testfile.zip</code></p>
<p><strong>3. 带宽控制和下载配额</strong></p>
<ul>
<li><code>curl -O --limit-rate 下载速度 http://www.example.com/testfile.zip</code><ul>
<li><code>--limit-rate 下载速度</code>：限定不超过指定的下载速度。例：–limit-rate 500k</li>
<li><code>--max-filesize 下载配额</code>：指定最大可下载文件大小</li>
</ul>
</li>
</ul>
<h3 id="处理复杂的web请求"><a href="#处理复杂的web请求" class="headerlink" title="处理复杂的web请求"></a>处理复杂的web请求</h3><p><strong>1. 自动跳转</strong></p>
<ul>
<li><code>curl -L http://www.example.com</code><ul>
<li><code>-L</code>：自动跳转到重定向链接(Location)<br>有些链接访问时会自动跳转(响应状态码为3xx)，<code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。例如：访问 “<a href="http://a.com&quot;/">http://a.com&quot;</a> 会重定向到 “<a href="http://b.com&quot;,使用&quot;`-l`&quot;选项会返回/">http://b.com&quot;，使用&quot;`-L`&quot;选项会返回</a> “<a href="http://b.com&quot;/">http://b.com&quot;</a> 的响应内容</li>
</ul>
</li>
</ul>
<p><strong>2. 显示响应头信息</strong></p>
<ul>
<li><code>curl -i http://www.example.com</code><ul>
<li><code>-i</code>：输出包含响应头信息</li>
<li><code>-I</code>：输出仅包含响应头信息，不包含响应内容</li>
</ul>
</li>
</ul>
<p><strong>3. 显示通信过程</strong></p>
<ul>
<li><code>curl -v http://www.example.com</code><ul>
<li><code>-v</code>：显示一次http通信的整个过程，包括端口连接和http request头信息</li>
</ul>
</li>
</ul>
<p>如果还需要查看额外的通信信息，还可以使用选项 “<code>--trace 输出文件</code>“ 或者 “<code>--trace-ascii 输出文件</code>“，例如：<code>curl --trace-ascii output.txt http://www.example.com</code>，打开文件 “output.txt”可以查看结果。</p>
<p><strong>4. 指定http请求方式</strong></p>
<ul>
<li><code>curl -X 请求方式 http://www.example.com/test</code><ul>
<li><code>-X 请求方式</code>：指定http请求方式(GET|POST|DELETE|PUT等)。默认是”GET”</li>
</ul>
</li>
</ul>
<p><strong>5. 添加http请求头</strong></p>
<ul>
<li><code>curl -H &#39;kev:value&#39; http://www.example.com/test</code><ul>
<li><code>-H &#39;kev:value&#39;</code>：添加http请求头。例：<code>-H &#39;Content-Type:application/json&#39;</code><br>添加多个请求头，<code>-H</code> 选项重复多次即可。例如：<br><code>curl -H &#39;Accept-Language: en-US&#39; -H &#39;Secret-Message: xyzzy&#39; http://www.example.com/test</code></li>
</ul>
</li>
</ul>
<p><strong>6. 传递请求参数</strong></p>
<ul>
<li><code>curl -X POST -d &#39;参数&#39; http://www.example.com/test</code><ul>
<li><code>-d &#39;参数&#39;</code>：指定POST请求体。参数形式可以是 “k1=v1&amp;k2=v2”, 也可以是json串</li>
<li><code>--data-urlencode &#39;参数&#39;</code>：与 <code>-d</code> 相同，区别在于会自动将发送的数据进行 URL 编码</li>
</ul>
</li>
</ul>
<p>使用 <code>-d</code> 参数以后，HTTP 请求会自动加上标头”<code>Content-Type:application/x-www-form-urlencoded</code>“，并且会自动将请求转为 POST 方法，因此可以省略 “<code>-X POST</code>“。如果要发送的请求体为json串，需要指定”Content-Type:application/json”，例如：<br><code>curl -d &#39;&#123;&quot;user&quot;:&quot;zhangsan&quot;, &quot;password&quot;:&quot;123456&quot;&#125;&#39; -H &#39;Content-Type:application/json&#39; http://www.example.com/login</code></p>
<blockquote>
<p>参数较多时，可以下把参数数据保存到本地文本中，然后从文本中读取参数数据。例如：<br><code>curl -d &#39;@requestData.txt&#39; -H &#39;Content-Type:application/json&#39; http://www.example.com/login</code></p>
</blockquote>
<blockquote>
<p>如果要以GET请求方式发送表单数据，可以直接把参数直接追加url之后。例如：<br><code>curl http://www.example.com/login?user=zhansan&amp;password=123456</code></p>
</blockquote>
<p><strong>7. 文件上传</strong></p>
<ul>
<li><code>curl -F &#39;file=@文件&#39; https://www.example.com/test</code><ul>
<li><code>-F &#39;file=@文件&#39;</code>：模拟http表单向服务器上传文件。更多参数形式：<code>file=@文件;name1=value1;name2=value2</code></li>
</ul>
</li>
</ul>
<p>文件上传时 <code>-F</code> 选项默认会给 HTTP 请求头加上 <code>Content-Type: multipart/form-data</code>，默认文件MIME类型为 <code>application/octet-stream</code></p>
<blockquote>
<p><strong>指定上传文件 MIME 类型</strong>。下面示例指定MIME类型为”image/png”<br><code>curl -F &#39;file=@photo.png;type=image/png&#39; https://google.com/profile</code></p>
<p><strong>指定上传文件名</strong>。下面示例中原始文件名为”photo.png”，但是服务器接收到的文件名为 “me.png”<br><code>curl -F &#39;file=@photo.png;filename=me.png&#39; https://google.com/profile</code></p>
</blockquote>
<p><strong>8. 设置来源网址</strong></p>
<ul>
<li><code>curl -e &#39;源网址&#39; https://www.example.com</code><ul>
<li><code>-e &#39;源网址&#39;</code> 或 <code>--referer &#39;源网址&#39;</code>：设置来源网址，即http请求头的 <code>Referer</code>字段。和 <code>-H</code> 选项直接设置请求头 “Referer” 字段等效</li>
</ul>
</li>
</ul>
<p><strong>9. 设置客户端用户代理</strong></p>
<ul>
<li><code>curl -A &#39;代理信息&#39; https://www.example.com</code><ul>
<li><code>-A &#39;代理信息&#39;</code> 或 <code>--user-agent &#39;代理信息&#39;</code>：设置客户端用户代理，即http请求头的 <code>User-Agent</code>字段。和 <code>-H</code> 选项直接设置请求头 “User-Agent” 字段等效</li>
</ul>
</li>
</ul>
<blockquote>
<p>将”User-Agent”改成 Chrome 浏览器，示例：<br><code>curl -A &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Mobile Safari/537.36&#39; https://www.example.com</code></p>
<p>移出 “User-Agent” 请求头，示例：<br><code>curl -A &#39;&#39; https://www.example.com</code></p>
</blockquote>
<p><strong>10. 设置cookie</strong></p>
<ul>
<li><code>curl -b &#39;参数&#39; https://www.example.com</code><ul>
<li><code>-b &#39;参数&#39;</code> 或 <code>--cookie &#39;参数&#39;</code>：设置cookie参数。参数形式可以是 <code>key1=value1;key2=value2...</code>，也可以是一个文件</li>
<li><code>-c 文件</code>：把服务器响应的cookie信息写入到文件中</li>
</ul>
</li>
</ul>
<blockquote>
<p>至于具体的cookie的值，可以从http response头信息的 “Set-Cookie” 字段中得到，可以保存服务器返回的cookie信息到文件，再用这文件作为下次请求的cookie信息，如下：<br><code>curl -c cookies.txt http://example.com</code><br><code>curl -b cookies.txt http://example.com</code></p>
</blockquote>
<p><strong>11. 设置服务器认证的用户名和密码</strong></p>
<ul>
<li><code>curl -u &#39;user[:password]&#39; https://www.example.com</code><ul>
<li><code>-u &#39;user[:password]&#39;</code>：设置服务器认证的用户名和密码。只有用户名时，执行curl后提示输入密码</li>
</ul>
</li>
</ul>
<h2 id="wget与curl对比"><a href="#wget与curl对比" class="headerlink" title="wget与curl对比"></a>wget与curl对比</h2><p>wget 是一个独立的下载程序，无需额外的资源库，它也允许你下载网页中或是 FTP 目录中的任何内容, 能享受它超凡的下载速度，简单直接。<br>curl是一个多功能工具，是libcurl这个库支持的。它可以下载网络内容，但同时它也能做更多别的事情。</p>
<p>从用途方面，wget倾向于网络文件下载；curl倾向于网络接口调试，相当于一个无图形界面的 PostMan 工具</p>
<hr>
<p>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2011/09/curl.html">http://www.ruanyifeng.com/blog/2011/09/curl.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>wget</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/20200228/linux2/20f52a23110c.html</url>
    <content><![CDATA[<h2 id="1-命令的基本格式"><a href="#1-命令的基本格式" class="headerlink" title="1 命令的基本格式"></a>1 命令的基本格式</h2><h3 id="1-1-命令的提示符"><a href="#1-1-命令的提示符" class="headerlink" title="1.1 命令的提示符"></a>1.1 命令的提示符</h3><p><strong>[root@localhost ~]#</strong></p>
<ul>
<li><code>[]</code>：这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>：显示的是当前的登录用户， 目前使用的是root用户登录。</li>
<li><code>@</code>：分隔符号，没有特殊含义。</li>
<li><code>localhost</code>：当前系统的简写主机名（完整主机名是 localhost.localdomain）。</li>
<li><code>~</code>：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>：命令提示符。超级用户是#，普通用户是$</li>
</ul>
<a id="more"></a>

<h3 id="1-2-命令的基本格式"><a href="#1-2-命令的基本格式" class="headerlink" title="1.2 命令的基本格式"></a>1.2 命令的基本格式</h3><p><strong>[root@localhost ~]# 命令 [选项] [参数]</strong></p>
<ul>
<li><code>选项</code>：是用于调整命令的功能的</li>
<li><code>参数</code>：是命令的操作对象</li>
</ul>
<h2 id="2-目录操作命令"><a href="#2-目录操作命令" class="headerlink" title="2 目录操作命令"></a>2 目录操作命令</h2><h3 id="2-1-ls命令"><a href="#2-1-ls命令" class="headerlink" title="2.1 ls命令"></a>2.1 ls命令</h3><p>ls 是最常见的目录操作命令，主要作用是显示目录下的内容</p>
<ul>
<li>命令名称：ls</li>
<li>英文原意：list</li>
<li>所在路径：/bin/ls</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示目录下的内容</li>
</ul>
<p>命令格式：<code>ls [选项] [目录名]</code></p>
<ul>
<li>选项<ul>
<li>-a: 显示所有文件</li>
<li>–color=when: 支持颜色输出，when的值默认是<em>always</em>(总显示颜色)，也可以是<em>never</em>(从不显示颜色)和<em>auto</em>(自动)</li>
<li>-d: 显示目录信息，而不是目录下的文件</li>
<li>-h: 人性化显示，按照我们习惯的单位显示文件大小</li>
<li>-i: 显示文件的节点号</li>
<li>-l: 长格式显示</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">#权限 引用计数 所有者 所属组 大小 文件修改时间 文件名</span><br><span class="line">-rw-------. 1 root root  1446 12月 19 16:15 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“-l” 选项用于显示文件的详细信息，那么“-l”选项显示的这 7 列分别是什么含义？<br>第一列：权限。<br>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录<br>有多少个一级子目录。<br>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户<br>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。<br>第五列：大小。默认单位是字节。<br>第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个<br>时间不是文件的创建时间。<br>第七列：文件名。</p>
</blockquote>
<h3 id="2-2-cd命令"><a href="#2-2-cd命令" class="headerlink" title="2.2 cd命令"></a>2.2 cd命令</h3><p>cd是切换所在目录的命令，基本信息如下：</p>
<ul>
<li>命令名称：cd</li>
<li>英文原意：change directory</li>
<li>所在路径：shell内置命令</li>
<li>执行权限：所有用户</li>
<li>功能描述：切换所在目录</li>
</ul>
<p>命令格式：<code>cd [-L|-P] [dir]</code></p>
<ul>
<li>选项：<ul>
<li><code>-L</code>:（默认值）如果要切换到的目标目录是一个符号连接，那么切换到符号连接的目录。 </li>
<li><code>-P</code>: 如果要切换到的目标目录是一个符号连接，那么切换到它指向的物理位置目录。</li>
</ul>
</li>
<li>参数:<ul>
<li>可以是绝对路径(以根目录为参照物)或相对路径(以当前目录为参照物)</li>
</ul>
</li>
</ul>
<blockquote>
<p>简化用法<br><code>cd ~</code>: 当前用户的加目录<br><code>cd -</code>：上一次所在目录<br><code>cd .</code>: 当前目录<br><code>cd ..</code>: 上级目录</p>
</blockquote>
<h3 id="2-3-pwd命令"><a href="#2-3-pwd命令" class="headerlink" title="2.3 pwd命令"></a>2.3 pwd命令</h3><p>pwd命令是查询所在目录的命令，基本信息如下：</p>
<ul>
<li>命令名称：pwd</li>
<li>英文原意：print name of current/working directory</li>
<li>所在路径：/bin/pwd</li>
<li>执行权限：所有用户</li>
<li>功能描述：查询当前所在目录</li>
</ul>
<h3 id="2-4-mkdir命令"><a href="#2-4-mkdir命令" class="headerlink" title="2.4 mkdir命令"></a>2.4 mkdir命令</h3><ul>
<li>命令名称：mkdir</li>
<li>英文原意：make directories</li>
<li>所在路径：/bin/mkdir</li>
<li>执行权限：所有用户</li>
<li>功能描述：创建空目录</li>
</ul>
<p>命令格式：mkdir [选项] 目录名</p>
<ul>
<li>选项：<ul>
<li><code>-p</code>: 递归建立所需目录</li>
<li><code>-m 权限</code>：建立目录的同时设置目录的权限</li>
</ul>
</li>
</ul>
<h3 id="2-5-rmdir命令"><a href="#2-5-rmdir命令" class="headerlink" title="2.5 rmdir命令"></a>2.5 rmdir命令</h3><p>rmdir命令删除空目录，基本信息如下：</p>
<ul>
<li>命令名称：rmdir</li>
<li>英文原意：remove empty directories</li>
<li>所在路径：/bin/rmdir</li>
<li>执行权限：所有用户</li>
<li>功能描述：删除空目录</li>
</ul>
<p>命令格式：<code>rmdir [选项] 目录名</code></p>
<ul>
<li>选项：<ul>
<li><code>-p</code>: 递归删除目录</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>rmdir</code>命令的作用十分有限，只能删除空目录，一旦目录中有内容就会报错。所以一般不论删除的是文件还是目录，都会使用<code>rm</code>命令</p>
</blockquote>
<h2 id="3-文件操作命令"><a href="#3-文件操作命令" class="headerlink" title="3 文件操作命令"></a>3 文件操作命令</h2><h3 id="3-1-touch命令"><a href="#3-1-touch命令" class="headerlink" title="3.1 touch命令"></a>3.1 touch命令</h3><p>touch命令创建空文件或修改文件时间，基本信息如下：</p>
<ul>
<li>命令名称：touch</li>
<li>英文原意：change file timestamps</li>
<li>所在路径：/bin/touch</li>
<li>执行权限：所有用户</li>
<li>功能描述：创建文件或改文件时间戳</li>
</ul>
<p>命令格式：<code>touch [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：或–time=atime或–time=access或–time=use 更改存取时间为当前时间(access time)</li>
<li><code>-m</code>：或–time=mtime或–time=modify 更该变动时间为当前时间(modify time)</li>
<li><code>-t 日期时间</code>: 使用指定的日期时间(格式：[[CC]YY]MMDDhhmm[.ss])，而非现在的时间</li>
<li><code>-r 参考文件或目录</code>: 把指定文件或目录的日期时间统统设成参考文件或目录的日期时间<h3 id="3-2-cat命令"><a href="#3-2-cat命令" class="headerlink" title="3.2 cat命令"></a>3.2 cat命令</h3>cat命令用来查看文件内容，进本信息如下：</li>
</ul>
</li>
<li>命令名称：cat</li>
<li>英文原意：concatenate files and print on the standard output</li>
<li>所在路径：/bin/cat</li>
<li>执行权限：所有用户</li>
<li>功能描述：合并文件并打印输出到标准输出</li>
</ul>
<p>命令格式：<code>cat [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-E</code>: 列出每行结尾的回车符$</li>
<li><code>-n</code>: 显示行号</li>
<li><code>-T</code>: 把Tab键用^I显示出来</li>
<li><code>-v</code>: 列出特殊字符</li>
<li><code>-A</code>: 相当于-vET选项的整合，用于列出所有隐藏符号</li>
</ul>
</li>
</ul>
<h3 id="3-3-more-命令"><a href="#3-3-more-命令" class="headerlink" title="3.3 more 命令"></a>3.3 more 命令</h3><p>more是分屏显示文件的命令，基本信息如下：</p>
<ul>
<li>命令名称：more</li>
<li>英文原意：file perusal filter for crt viewin</li>
<li>所在路径：/bin/more</li>
<li>执行权限：所有用户</li>
<li>功能描述：分屏显示文件内容</li>
</ul>
<p>命令格式：<code>more [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：显示“[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions]”；</li>
<li><code>-c</code>：不进行滚屏操作。每次刷新这个屏幕</li>
<li><code>-s</code>：将多个空行压缩成一行显示</li>
<li><code>-u</code>：禁止下划线</li>
<li><code>-数字</code>：指定每屏显示的行数</li>
<li><code>+数字</code>：从指定数字的行开始显示  </li>
</ul>
</li>
</ul>
<blockquote>
<p> more 命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用的交互命令如下：</p>
<ul>
<li>空格键：向下翻页</li>
<li>B键: 向上翻页</li>
<li>/字符串：搜索指定的字符串</li>
<li>q: 退出</li>
</ul>
</blockquote>
<h3 id="3-4-less-命令"><a href="#3-4-less-命令" class="headerlink" title="3.4 less 命令"></a>3.4 less 命令</h3><p>less命令和more命令类似，只是more命令是分屏显示，而less是分行显示命名，less命令允许用户向前(PageUp键)或向后(PageDown键)浏览文件，基本信息如下：</p>
<ul>
<li>命令名称：less</li>
<li>英文原意：opposite of more</li>
<li>所在路径：/usr/bin/more</li>
<li>执行权限：所有用户</li>
<li>功能描述：分行显示文件内容</li>
</ul>
<p>命令格式：<code>less [选项] 文件名</code></p>
<ul>
<li><code>-e</code>：文件内容显示完毕后，自动退出</li>
<li><code>-f</code>：强制显示文件</li>
<li><code>-g</code>：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度</li>
<li><code>-l</code>：搜索时忽略大小写的差异</li>
<li><code>-N</code>：每一行行首显示行号</li>
<li><code>-s</code>：将连续多个空行压缩成一行显示</li>
<li><code>-S</code>：在单行显示较长的内容，而不换行显示</li>
<li><code>-x数字</code>：将TAB字符显示为指定个数的空格字符</li>
</ul>
<h3 id="3-5-head-命令"><a href="#3-5-head-命令" class="headerlink" title="3.5 head 命令"></a>3.5 head 命令</h3><p>head 命令是用来显示文件开头内容的命令，基本信息如下：</p>
<ul>
<li>命令名称：head</li>
<li>英文原意：output the first part files</li>
<li>所在路径：/usr/bin/head</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件开头的内容</li>
</ul>
<p>命令格式：<code>head [选项] 文件名</code></p>
<ul>
<li><code>-n 行数</code>：从文件开头开始，显示指定行数</li>
<li><code>-v</code>：显示文件名</li>
</ul>
<h3 id="3-6-tail-命令"><a href="#3-6-tail-命令" class="headerlink" title="3.6 tail 命令"></a>3.6 tail 命令</h3><p>tail 命令是用来显示文件结尾内容的命令</p>
<ul>
<li>命令名称：tail</li>
<li>英文原意：output the last part files</li>
<li>所在路径：/usr/bin/tail</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件结尾的内容</li>
</ul>
<p>命令格式：<code>tail [选项] 文件名</code></p>
<ul>
<li><code>-n 行数</code>：从文件结尾开始，显示指定行数</li>
<li><code>-v</code>：显示文件名</li>
<li><code>-f</code>: 监听文件新增内容</li>
</ul>
<h3 id="3-7-ln-命令"><a href="#3-7-ln-命令" class="headerlink" title="3.7 ln 命令"></a>3.7 ln 命令</h3><p>ln命令用来为文件创件链接，连接类型分为硬连接和符号连接(软链接)两种，基本信息如下：</p>
<ul>
<li>命令名称：ln</li>
<li>英文原意：make links between file</li>
<li>所在路径：/bin/tail</li>
<li>执行权限：所有用户</li>
<li>功能描述：在文件之间建立链接</li>
</ul>
<p>命令格式：<code>ln [选项] 源文件 [目标文件]</code></p>
<ul>
<li>选项：<ul>
<li>-s: 建立软链接文件。如果不加’-s’选项，则建立硬链接文件</li>
<li>-f: 强行删除已存在的链接文件。如果链接文件已存在，则删除目标文件后再建立链接文件</li>
</ul>
</li>
<li><strong>源文件</strong>：指定链接的源文件。如果使用<code>-s</code>选项创建软链接，则“源文件”可以是<strong>文件或者目录</strong>，创建硬链接时，则“源文件”参数只能是<strong>文件</strong>。（源文件最好用绝对路径名，这样可以在任何工作目录下进行符号链接，而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接）</li>
<li><strong>目标文件</strong>：指定源文件的目标链接文件，省略则在当前目录下新建与源文件名称相同的链接文件</li>
</ul>
<blockquote>
<p>硬链接和源文件实际上是同一个文件，不会创建新的文件（类似于Java中，一个对象有多个引用）；而软链接会创建一个新文件来保存源文件的路径，从而间接读取或修改源文件内容<br>硬链接与软链接的特征<br><strong>硬链接特征</strong>：<br>1.源文件和硬链接文件拥有相同的Indoe和Block<br>2.修改任意一个文件，另一个都改变<br>3.删除任意一个文件，另一个都能使用<br>4.硬链接建立或删除，原文件连接数相应加一或减一<br>5.硬链接不能链接目录<br>6.硬链接不能跨分区<br>7.硬链接标记不清，很难确认硬链接文件位置，不建议使用</p>
<p><strong>软链接特征</strong>：<br>1.软链接和源文件拥有不同的Inode和Block<br>2.两个文件修改任意一个，另一个都改变<br>3.删除软链接，源文件不受影响；删除源文件，软链接不能使用<br>4.软链接建立或删除，原文件链接数不变<br>5.软链接可以链接目录<br>6.软链接可以跨分区<br>7.软链接特征明显，建议使用软链接<br>8.软链接没有实际数据，只是保存源文件的Inode，不论源文件多大，软链接大小不变<br>9.软链接的权限是最大权限<code>lrwxrwxrwx.</code>，但是由于没有实际数据，最终访问时需要参考源文件权限</p>
</blockquote>
<h2 id="4-文件和目录都能操作的命令"><a href="#4-文件和目录都能操作的命令" class="headerlink" title="4 文件和目录都能操作的命令"></a>4 文件和目录都能操作的命令</h2><h3 id="4-1-rm-命令"><a href="#4-1-rm-命令" class="headerlink" title="4.1 rm 命令"></a>4.1 rm 命令</h3><p>rm是最强大的删除命令，不仅可以删除文件，也可以删除目录，基本信息如下：</p>
<ul>
<li>命令名称：rm</li>
<li>英文原意：remove files or directories</li>
<li>所在路径：/bin/rm</li>
<li>执行权限：所有用户</li>
<li>功能描述：删除文件或目录</li>
</ul>
<p>命令格式：<code>rm [选项] 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>: 强制删除</li>
<li><code>-i</code>: 交互删除，在删除之前会询问用户</li>
<li><code>-r</code>: 递归删除，可以删除目录</li>
</ul>
</li>
</ul>
<h3 id="4-2-cp-命令"><a href="#4-2-cp-命令" class="headerlink" title="4.2 cp 命令"></a>4.2 cp 命令</h3><p>cp命令用于复制文件或目录，基本信息入下：</p>
<ul>
<li>命令名称：cp</li>
<li>英文原意：copy files and directories</li>
<li>所在路径：/bin/cp</li>
<li>执行权限：所有用户</li>
<li>功能描述：复制文件或目录</li>
</ul>
<p>命令格式：<code>cp [选项] 源文件 目标文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>: 如果文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接</li>
<li><code>-i</code>: 询问，如果目标文件已经存在，则会询问是否覆盖</li>
<li><code>-p</code>: 复制后目标文件保留源文件的属性(包括所有者、所有组、权限和时间)</li>
<li><code>-r</code>: 递归复制，用于复制目录</li>
<li><code>-a</code>: 相当于<code>-dpr</code>选项的集合</li>
</ul>
</li>
</ul>
<h3 id="4-3-mv-命令"><a href="#4-3-mv-命令" class="headerlink" title="4.3 mv 命令"></a>4.3 mv 命令</h3><p>mv命令用来剪贴文件或目录，基本信息如下：</p>
<ul>
<li>命令名称：mv</li>
<li>英文原意：move(rename) files</li>
<li>所在路径：/bin/mv</li>
<li>执行权限：所有用户</li>
<li>功能描述：移动文件或目录</li>
</ul>
<p>命令格式：<code>cp [选项] 源文件 目标文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>: 强制覆盖，如果目标文件已经存在，则不询问直接强制覆盖</li>
<li><code>-i</code>: 交互模式，如果目标文件已经存在，则询问用户是否覆盖（默认选项）</li>
<li><code>-v</code>：显示详细信息</li>
</ul>
</li>
</ul>
<h3 id="4-4-stat命令"><a href="#4-4-stat命令" class="headerlink" title="4.4 stat命令"></a>4.4 stat命令</h3><p>stat命令是查看文件详细的命令，基本信息如下：</p>
<ul>
<li>命令名称：stat</li>
<li>英文原意：display file or file system status</li>
<li>所在路径：/usr/bin/stat</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示文件或文件系统的详细信息</li>
</ul>
<p>命令格式：<code>stat [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-f</code>：显示文件系统状态而非文件状态</li>
<li><code>-t</code>：以简洁方式输出信息</li>
</ul>
</li>
</ul>
<h2 id="5-基本权限管理"><a href="#5-基本权限管理" class="headerlink" title="5 基本权限管理"></a>5 基本权限管理</h2><h3 id="5-1-权限介绍"><a href="#5-1-权限介绍" class="headerlink" title="5.1 权限介绍"></a>5.1 权限介绍</h3><p>使用ls命令时，长格式显示的第一列就是文件的权限，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l install.log</span><br><span class="line">-rw-r--r--. 1 root root 28425 11月 30 18:50 install.log</span><br></pre></td></tr></table></figure>
<p>第一列的权限位(<code>-rw-r--r--.</code>)如果不计最后的 “<strong>.</strong>“  (这个点代表受SELinux安全上下文保护，这里暂时忽略不做介绍)，则共10位，这10位权限位的含义如下图所示：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux003.png?x-oss-process=style/watermarking" alt="权限位"></p>
<ul>
<li><p><strong>第1位</strong>：代表文件类型。Linux不像Windows使用扩展名表示文件类型，而是使用权限位的第一位表示文件类型。虽然Linux文件的种类不像Windows中那么多，但是分类也不少，详细情况可以使用“<code>info ls</code>” 命令查看。这里列出一些常见的文件类型：</p>
<ul>
<li><code>-</code>: 普通文件</li>
<li><code>d</code>: 目录文件。Linux中一切皆文件，所以目录也是文件的一种</li>
<li><code>l</code>: 软链接文件</li>
<li><code>b</code>: 块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1就是这种文件</li>
<li><code>c</code>: 字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等</li>
<li><code>p</code>: 管道符文件。这是一种非常少见的特殊设备文件。</li>
<li><code>s</code>: 套接字文件。这也是一种特殊设备文件，一些服务支持socket访问就会产生这样的文件</li>
</ul>
</li>
<li><p><strong>第2~4位</strong>：代表文件所有者的权限</p>
<ul>
<li><code>r</code>: 代表read，是读取权限</li>
<li><code>w</code>： 代表write，是写权限</li>
<li><code>x</code>: 代表execute，是执行权限</li>
</ul>
</li>
<li><p><strong>第5~7位</strong>：代表文件所属组的权限，同样拥有“rwx”权限</p>
</li>
<li><p><strong>第8~10位</strong>：代表文件其他人的权限，同样拥有“rwx”权限</p>
</li>
</ul>
<p><strong>权限含义的解释：</strong><br>读、写、执行权限对文件和目录的作用是不同的。</p>
<ul>
<li><p>权限对文件的作用</p>
<ul>
<li>读(r)：对文件有读权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读权限，就可以对文件执行<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code>等文件查看命令</li>
<li>写(w)：对文件有写权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写权限，就可以对文件执行<code>vim</code>、<code>echo</code>等修改文件数据的命令。<strong>注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据，如果想要删除文件，则需要对文件的上级目录拥有写权限</strong>。</li>
<li>执行(x)：对文件有执行权限，代表文件可以运行。在Linux中，只要文件有执行权限，这个文件就是执行文件了，只是这个文件到底能不能正确执行，不仅需要看执行权限，还要看文件的代码是不是正确的语言代码。对文件来说，执行权限是最高权限</li>
</ul>
</li>
<li><p>权限对目录的作用</p>
<ul>
<li>读(r)：对目录有读权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些文件和子目录。如果包权限对应到命令上，那么一旦对目录拥有了读权限，就可以在目录下执行<code>ls</code>命令查看目录下的内容了</li>
<li>写(w)：对目录有写权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪贴子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写权限，就可以在目录下执行<code>touch</code>、<code>rm</code>、<code>cp</code>、<code>mv</code>等命令。对目录来说，写权限是最高权限</li>
<li>执行(x)：目录是不能运行的，那么对目录拥有执行权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行权限，就可以对目录执行<code>cd</code>命令进入目录</li>
</ul>
</li>
</ul>
<h3 id="5-2-chmod-命令"><a href="#5-2-chmod-命令" class="headerlink" title="5.2 chmod 命令"></a>5.2 chmod 命令</h3><p>chmod用来修改文件的权限，基本信息如下：</p>
<ul>
<li>命令名称：chmod</li>
<li>英文原意：change file mode bits</li>
<li>所在路径：/bin/chmod</li>
<li>执行权限：所有用户</li>
<li>功能描述：修改文件的权限模式</li>
</ul>
<p>命令格式：<code>chmod [选项] 权限模式 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-R</code>: 递归设置权限，也就是给予目录中的所有文件设定权限</li>
<li><code>--reference=RFILE</code>：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。</li>
</ul>
</li>
</ul>
<blockquote>
<p>chmod命令的<strong>权限模式</strong>分为<strong>符号组合</strong>和<strong>八进制数组合</strong><br>符号组合的格式是<code>[ugoa][[+-=][permission]]</code>，也就是<code>[用户身份][[赋予方式][权限]]</code>的格式。</p>
<ul>
<li>用户身份<ul>
<li><code>u</code>：代表所有者(user)</li>
<li><code>g</code>：代表所属组(group)</li>
<li><code>o</code>：代表其他人(other)</li>
<li><code>a</code>：代表全部身份(all)</li>
</ul>
</li>
<li>赋予方式<ul>
<li><code>+</code>：加入权限</li>
<li><code>-</code>：减去权限</li>
<li><code>=</code>：设置权限  </li>
</ul>
</li>
<li>权限<ul>
<li><code>r</code>: 读取权限(read)</li>
<li><code>w</code>: 写权限(write)</li>
<li><code>x</code>: 执行权限(execute)<br>八进制数组合的格式是<code>[0-7][0-7][0-7]</code>三位数字组成(每一位数字都是权限之和)，第一位是所有者权限，第二位是所属组权限，第三位其他人权限</li>
</ul>
</li>
<li><code>r</code>读取权限对应的数字是<code>4</code> </li>
<li><code>w</code>写权限对应的数字是<code>2</code> </li>
<li><code>x</code>执行权限对应的数字是<code>1</code></li>
<li>例如读写权限<code>rw</code>八进制数表示 <code>6</code> </li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加组用户的写权限。</span><br><span class="line">chmod g+w .&#x2F;test.log </span><br><span class="line"># 删除其他用户的所有权限。  </span><br><span class="line">chmod o&#x3D; .&#x2F;test.log </span><br><span class="line"># 使得所有用户都没有写权限。  </span><br><span class="line">chmod a-w .&#x2F;test.log </span><br><span class="line"># 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。  </span><br><span class="line">chmod u&#x3D;rwx, g&#x3D;rw, o&#x3D;r .&#x2F;test.log (等价的八进制数表示:chmod 754 .&#x2F;test.log )   </span><br><span class="line"># 将目录以及目录下的文件都设置为所有用户拥有读写权限。注意，使用&#39;-R&#39;选项一定要保留当前用户的执行和读取权限，否则会报错！  </span><br><span class="line">chmod -R a&#x3D;rw .&#x2F;testdir&#x2F; </span><br><span class="line"># 根据其他文件的权限设置文件权限。  </span><br><span class="line">chmod --reference&#x3D;.&#x2F;1.log .&#x2F;test.log</span><br></pre></td></tr></table></figure>

<h3 id="5-3-chown-命令"><a href="#5-3-chown-命令" class="headerlink" title="5.3 chown 命令"></a>5.3 chown 命令</h3><p>chown 命令用来修改文件和目录的所有者和所属组，基本信息如下：</p>
<ul>
<li>命令名称：chown</li>
<li>英文原意：change file owner and group</li>
<li>所在路径：/bin/chown</li>
<li>执行权限：所有用户</li>
<li>功能描述：修改文件和目录的所有者和所属组</li>
</ul>
<p>命令格式：<code>chown [选项] 所有者[:所属组] 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-R</code>：递归设置权限，也就是给予子目录的所有文件设置权限</li>
</ul>
</li>
<li>当省略 “:所属组” ，仅改变文件所有者</li>
</ul>
<blockquote>
<p>注意：普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行。普通用户可以修改所有者是自己的文件权限。</p>
</blockquote>
<h3 id="5-4-umask-命令"><a href="#5-4-umask-命令" class="headerlink" title="5.4 umask 命令"></a>5.4 umask 命令</h3><p>umask命令用来显示或设置创建文件或目录的权限掩码。</p>
<p>我们需要先了解一下新建文件和目录的默认最大权限，对于文件来讲，新建文件的默认最大权限是<code>666</code>，没有执行权限，只是因为执行权限对文件来讲比较危险，不能再新建文件的时候默认赋予，而必须通过用户手工赋予；对于目录来讲，新建目录的默认最大权限是<code>777</code>，这是因为对目录而言，执行权限仅仅代表进入目录，所以即使新建目录时直接默认赋予也没有什么危险。</p>
<p>按照官方的标准算法，<code>umask</code>默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限，这种方法既不好计算也不好理解，不推荐。我们这里按照权限字母来讲解<code>umask</code>权限的计算方。我们就按照默认的<code>umask</code>值是<code>0022</code>(等效于<code>022</code>)分别来计算一下新建文件和目录的默认权限，</p>
<ul>
<li><p>文件的默认权限最大只能是<code>666</code>，而<code>umask</code>的值是<code>022</code>，则 <code>rw-rw-rw-</code> 减去 <code>----w--w-</code>等于<code>rw-r--r--</code>，所以新建文件的默认权限是<code>rw-r--r--</code></p>
</li>
<li><p>目录的默认权限最大是<code>777</code>，而<code>umask</code>的值是<code>022</code>，则 <code>rwxrwxrwx</code> 减去 <code>----w--w-</code>等于<code>rwxr-xr-x</code>，所以新建目录的默认权限是<code>rwxr-xr-x</code></p>
</li>
<li><p>同理，如果<code>umask</code>的值是<code>033</code>，新建文件的默认权限为 <code>rw-rw-rw-</code> 减去 <code>----wx-wx</code>等于<code>rw-r--r--</code> </p>
</li>
</ul>
<p>命令格式：<code>umask  [选项] [模式]</code></p>
<ul>
<li>选项：<ul>
<li><code>-p</code>：输出的权限掩码可直接作为指令来执行 </li>
<li><code>-S</code>：以符号组合的方式输出权限掩码，不使用该选项时以八进制数的形式输出   </li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以八进制数的形式输出权限掩码</span><br><span class="line">[root@localhost tmp]# umask</span><br><span class="line">0022</span><br><span class="line"># 以八进制数的形式输出权限掩码，并作为指令来执行 </span><br><span class="line">[root@localhost tmp]# umask -p</span><br><span class="line">umask 0022</span><br><span class="line"># 以符号组合的方式输出权限掩码。</span><br><span class="line">[root@localhost tmp]# umask -S</span><br><span class="line">u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</span><br><span class="line"></span><br><span class="line">#上条命令以符号组合的方式输出权限掩码，输出的结果u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx转化为八进制数等于0755，</span><br><span class="line">#用八进制数来设置同样的权限，umask需要额外的执行减法&quot;0777 - 0755&quot;即0022</span><br><span class="line">[root@localhost tmp]# umask 0022</span><br><span class="line"></span><br><span class="line"># 为组用户添加写权限</span><br><span class="line">[root@localhost tmp]# umask g+w</span><br><span class="line"># 删除其他用户的写、执行权限</span><br><span class="line">[root@localhost tmp]# umask o-wx</span><br><span class="line"># 赋值全部用户所有权限，等价于umask u&#x3D;rwx,g&#x3D;rwx,o&#x3D;rwx</span><br><span class="line">[root@localhost tmp]# umask a&#x3D;rwx</span><br><span class="line">#清除其他用户的读、写、执行权限</span><br><span class="line">[root@localhost tmp]# umask o&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-帮助命令"><a href="#6-帮助命令" class="headerlink" title="6 帮助命令"></a>6 帮助命令</h2><h3 id="6-1-man-命令"><a href="#6-1-man-命令" class="headerlink" title="6.1 man 命令"></a>6.1 man 命令</h3><p>man命令是最常见的帮助命令，也是Linux最主要的帮助命令，基本信息如下：</p>
<ul>
<li>命令名称：man</li>
<li>英文原意：format and display the on-line manual pages</li>
<li>所在路径：/usr/bin/chown</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示连机帮助手册</li>
</ul>
<p>命令格式：<code>man [选项] [章节] 命令</code></p>
<ul>
<li>选项：<ul>
<li>-f: 查看命令有哪些章节的帮助和简短描述信息，等价于<code>whatis</code>指令</li>
<li>-k: 查看和命令相关的所有帮助</li>
</ul>
</li>
</ul>
<p><code>man</code>命令交互快捷键：</p>
<ul>
<li><code>上箭头</code>：向上移动一行 </li>
<li><code>下箭头</code>：向下移动一行 </li>
<li><code>PgUP</code>：向上翻一页 </li>
<li><code>PgDn</code>：向下翻一页</li>
<li><code>g</code>：移动到第一页</li>
<li><code>G</code>：移动到最后一页</li>
<li><code>q</code>：退出 </li>
<li><code>/字符串</code>：从当前向下搜索字符串 </li>
<li><code>?字符串</code>：从当前向上搜索字符串 </li>
<li><code>n</code>：当搜索字符串时，可以用n键找到下一个字符串</li>
<li><code>N</code>：当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则N键表示向上搜索字符串；如果使用“?字符串”方式搜索，则N键表示向下搜索字符串</li>
</ul>
<p><code>man</code>手册章节：</p>
<ul>
<li><code>1</code>： 用户在shell环境可操作的命令或执行文件</li>
<li><code>2</code>： 系统内核可调用的函数与工具等</li>
<li><code>3</code>： 一些常用的函数(function)与函数库(library)，大部分为C的函数库(libc)</li>
<li><code>4</code>： 设备文件说明，通常在/dev下的文件</li>
<li><code>5</code>： 配置文件或某些文件格式</li>
<li><code>6</code>： 游戏帮助(个人版的Linux中是有游戏的)</li>
<li><code>7</code>： 惯例与协议等，如Linux文件系统，网络协议，ASCII code等说明</li>
<li><code>8</code>： 系统管理员可用的管理命令</li>
<li><code>9</code>： 跟kernel有关的文件</li>
</ul>
<p><code>man</code>手册的格式：</p>
<ul>
<li><code>NAME</code>: 命令名称及功能简要说明</li>
<li><code>SYNOPSIS</code>：用法说明，包括可用的选项<ul>
<li><code>[]</code>：可选内容</li>
<li><code>&lt;&gt;</code>：必选内容</li>
<li><code>a|b</code>：二选一</li>
<li><code>&#123;&#125;</code>：分组</li>
<li><code>...</code>：同意内容可出现多次</li>
</ul>
</li>
<li><code>DESCRIPTION</code>：命令功能的详细说明，可能包括每一个选项的意义</li>
<li><code>OPTIONS</code>：说明每一项的意义</li>
<li><code>EXAMPLES</code>：使用示例</li>
<li> <code>FILES</code>：此命令相关的配置文件</li>
<li> <code>AUTHOR</code>：作者</li>
<li> <code>COPYRIGHT</code>：版本信息</li>
<li> <code>REPORTTING BUGS</code>：bug信息        </li>
<li><code>SEE ALSO</code>：参考其他帮助</li>
</ul>
<p>示例：<br>我们输入 <code>man ls</code>，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输 <code>man ifconfig</code> 它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man [章节号] 手册名称”。</p>
<p><code>man</code>是按照手册的章节号的顺序进行搜索的，比如：<code>man sleep</code> 只会显示sleep命令的手册，如果想查看库函数sleep，就要输入：<code>man 3 sleep</code></p>
<h3 id="6-2-info-命令"><a href="#6-2-info-命令" class="headerlink" title="6.2 info 命令"></a>6.2 info 命令</h3><p>info 命令的帮助信息是一套完整的资料，每个单独命令的<code>man</code>帮助信息只是这套完整资料的某一个区段(节点)，基本信息如下：</p>
<ul>
<li>命令名称：info</li>
<li>英文原意：info</li>
<li>所在路径：/usr/bin/info</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示一套完整的帮助信息资料</li>
</ul>
<p>命令格式：<code>info [选项] 参数</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：添加包含info格式帮助文档的目录</li>
<li><code>-f</code>：指定要读取的info格式的帮助文档</li>
<li><code>-n</code>：指定首先访问的info帮助文件的节点</li>
<li><code>-o</code>：输出被选择的节点内容到指定文件</li>
</ul>
</li>
<li>参数：指定需要获得帮助的主题，可以是指令、函数以及配置文件</li>
</ul>
<p><code>info</code>命令交互快捷键</p>
<ul>
<li><code>上箭头</code>：向上移动一行 </li>
<li><code>下箭头</code>：向下移动一行 </li>
<li><code>PgUP</code>：向上翻一页 </li>
<li><code>PgDn</code>：向下翻一页</li>
<li><code>Tab</code>：在有“*”符号的节点间切换</li>
<li><code>回车</code>：进入有“*” 符号的子页面，查看详细帮助信息</li>
<li><code>u</code>：进入上一层信息(回车是进入下一层信息)</li>
<li><code>q</code>：退出info帮助信息 </li>
<li><code>n</code>：进入下一小节信息</li>
<li><code>p</code>：进入上一下节信息</li>
<li><code>?</code>：查看帮助信息</li>
</ul>
<h3 id="6-3-help-命令"><a href="#6-3-help-命令" class="headerlink" title="6.3 help 命令"></a>6.3 help 命令</h3><p>help 命令只能获取shell内置命令的帮助，基本信息如下：</p>
<ul>
<li>命令名称：help</li>
<li>英文原意：help</li>
<li>所在路径：shell 内置命令</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示shell内置命令的帮助。可以使用shell内置命令<code>type</code>来区分内置命令与外部命令，对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>命令查看</li>
</ul>
<p>命令格式：<code>help [选项] 内置命令</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：显示内建命令的简要描述。 </li>
<li><code>-m</code>：按照man手册的格式输出内置命令的帮助信息。 </li>
<li><code>-s</code>：仅输出内建命令的命令格式。 </li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以man手册的格式查看内置命令type的帮助信息</span><br><span class="line">[root@localhost ~]# help -m type</span><br><span class="line">NAME</span><br><span class="line">    type - Display information about command type.</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    type [-afptP] name [name ...]</span><br><span class="line"> (省略。。。)</span><br><span class="line"></span><br><span class="line"># 查看ls、help命令是否是内置命令</span><br><span class="line">[root@localhost ~]# type ls</span><br><span class="line">ls is aliased to &#96;ls --color&#x3D;auto&#39;</span><br><span class="line">[root@localhost ~]# type help</span><br><span class="line">help is a shell builtin</span><br></pre></td></tr></table></figure>


<h3 id="6-4-–help-选项"><a href="#6-4-–help-选项" class="headerlink" title="6.4 –help 选项"></a>6.4 –help 选项</h3><p>绝大多数命令都可以使用<code>--help</code>选项来查看帮助，者也是一种获取帮助的方法。例如 <code>ls --help</code>，这种方法非常简单，输出的帮助信息基本上是<code>man</code>命令的信息简要版。</p>
<h2 id="7-搜索命令"><a href="#7-搜索命令" class="headerlink" title="7 搜索命令"></a>7 搜索命令</h2><h3 id="7-1-whereis-命令"><a href="#7-1-whereis-命令" class="headerlink" title="7.1 whereis 命令"></a>7.1 whereis 命令</h3><p>whereis 是搜索命令的命令，也就是说whereis不能搜索普通文件，而只能搜索系统命令，基本信息如下：</p>
<ul>
<li>命令名称：whereis</li>
<li>英文原意：locate the binary,source,and manual page files for a command</li>
<li>所在路径：/usr/bin/whereis</li>
<li>执行权限：所有用户</li>
<li>功能描述：查找二进制命令、源文件和帮助文档的路径</li>
</ul>
<p>命令格式：<code>whereis [选项] 参数</code></p>
<ul>
<li>选项：<ul>
<li><code>-b</code>：只查找二进制文件 </li>
<li><code>-B 目录</code>：只在设置的目录下查找二进制文件</li>
<li><code>-m</code>：只查找说明文件</li>
<li><code>-M 目录</code>：只在设置的目录下查找说明文件</li>
<li><code>-s</code>：只查找原始代码文件</li>
<li><code>-S 目录</code>：只在设置的目录下查找原始代码文件</li>
<li><code>-f</code>：不显示文件名前的路径名称 </li>
</ul>
</li>
</ul>
<h3 id="7-2-which-命令"><a href="#7-2-which-命令" class="headerlink" title="7.2 which 命令"></a>7.2 which 命令</h3><p>which 也是搜索系统命令的命令，和<code>whereis</code>的区别在于，<code>whereis</code>命令可以在查找二进制命令的同时，查找帮助文档的位置，而<code>which</code>命令在查找到二进制命令的同时，如果这个命令有别名，则还可以查到别名命令。基本信息如下：</p>
<ul>
<li>命令名称：which</li>
<li>英文原意：shows the full path of (shell) commands</li>
<li>所在路径：/usr/bin/which</li>
<li>执行权限：所有用户</li>
<li>功能描述：列出二进制命令路径和别名。<code>which</code>只会在环境变量$PATH设置的目录里查找符合条件的命令</li>
</ul>
<p>命令格式：<code>which [选项] 参数</code></p>
<h3 id="7-3-find-命令"><a href="#7-3-find-命令" class="headerlink" title="7.3 find 命令"></a>7.3 find 命令</h3><p>find命令用来在指定目录下查找文件，基本信息如下：</p>
<ul>
<li>命令名称：find</li>
<li>英文原意：search for files in a directory hierarchy</li>
<li>所在路径：/bin/find</li>
<li>执行权限：所有用户</li>
<li>功能描述：在指定目录中搜索文件</li>
</ul>
<p>命令格式：<code>find [搜索路径] [选项]</code></p>
<ul>
<li>搜索路径：省略则默认为当目录，相当于 “find .”</li>
<li>选项：<ul>
<li><code>-name 范本样式</code>：按照文件名称搜索，支持通配符模糊查询</li>
<li><code>-iname 范本样式</code>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别</li>
<li><code>-inum inode编号</code>：查找符合指定的inode编号的文件或目录</li>
<li><code>-path 范本样式</code>：查找路径包含范本样式的文件或目录</li>
<li><code>-regex 范本样式</code>：正则表达式搜索</li>
<li><code>-iregex 范本样式</code>：同”-regex”，忽略大小写</li>
<li><code>-size [+|-]文件大小[cwbkMG] </code>：查找符合指定的文件大小的文件<ul>
<li>“+” 的意思是搜索比指定大小还要大的文件，”-“ 的意思是搜索比指定大小还要小的文件</li>
<li>“cwbkMG”是单位，c——字节，w——字(2字节)，b——块(512字节)，k——千字节，M——兆字节，G——吉字节。如果不写单位默认是b</li>
</ul>
</li>
<li><code>-atime [+|-]天数</code>：按照文件最后一次访问时间搜索，单位每天<ul>
<li>“+”、”-“的含义，例如”5”表示恰好5天前的那一天，”+5”超过5天前的时间，”-5”5天内的时间。(以下按时间搜索选项中”+”、”-“含义相同)</li>
</ul>
</li>
<li><code>-mtime [+|-]天数</code>：按照文件数据最后一次修改时间搜索，单位每天</li>
<li><code>-ctime [+|-]天数</code>：按照文件元数据(如权限等)最后一次修改时间搜索，单位每天</li>
<li><code>-amin [+|-]分钟数</code>：按照文件最后一次访问时间搜索，单位每分钟</li>
<li><code>-mmin [+|-]分钟数</code>：按照文件数据最后一次修改时间搜索，单位每分钟</li>
<li><code>-cmin [+|-]分钟数</code>：按照文件元数据(如权限等)最后一次修改时间搜索，单位每分钟</li>
<li><code>-perm [+|-]权限数值</code>：查找符合指定的权限数值的文件或目录。例如，权限数值为”766”表示权限恰好等于766，”-766”表示文件权限必须全部包含766，”+766”表示文件权限包含766任意一个权限</li>
<li><code>-uid 用户ID</code>：查找所有者是指定用户ID的文件</li>
<li><code>-user 用户名</code>：查找所有者是指定用户名的文件</li>
<li><code>-gid 组ID</code>：查找所有组是指定组ID的文件</li>
<li><code>-group 组名</code>：查找所有组是指定组名的文件</li>
<li><code>-nouser</code>：查找没有所有者的文件<ul>
<li>按照所有者和所有组搜索时，”-nouser”选项比较常用，主要用于查找垃圾文件。没有所有者的文件比较少见，那就是外来文件，比如光盘和U盘的文件是由Windows复制的，在Linux中查看就是没有所有者的文件，再比如手工源码包安装的文件也可能没有所有者</li>
</ul>
</li>
<li><code>-type 文件类型</code>：只寻找符合指定的文件类型的文件<ul>
<li><code>f</code>——普通文件，<code>l</code>——符号连接，<code>d</code>——目录，<code>c</code>——字符设备，<code>b</code>——块设备，<code>s</code>——套接字，<code>p</code>——Fifo</li>
</ul>
</li>
<li><code>-empty</code>：查找文件大小为0的文件</li>
<li><code>-maxdepth 目录层级数</code>：设置搜索的最大目录层级</li>
<li><code>-mindepth 目录层级</code>：设置搜索的最小目录层级</li>
<li><code>-exec 执行指令</code>：把find命令查找结果交由”-exec”调用的命令来处理<ul>
<li>格式：<code>find [搜索路径] [选项] -exec 命令 &#123;&#125; \;</code>, 其中”{}”代表find命令的查询结果</li>
</ul>
</li>
<li><code>-ok 执行指令</code>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户是否执行</li>
<li><code>-prune</code>：不寻找字符串作为寻找文件或目录的范本样式</li>
<li><code>-a</code>：and 逻辑与</li>
<li><code>-o</code>: or 逻辑或</li>
<li><code>-not</code>：not 逻辑非</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;根据文件名或者正则表达式进行匹配&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#列出当前目录及子目录下所有文件和文件夹</span><br><span class="line">[root@localhost ~]# find .</span><br><span class="line">#在&#96;&#x2F;home&#96;目录下查找以.txt结尾的文件名</span><br><span class="line">[root@localhost ~]# find &#x2F;home -name &quot;*.txt&quot;</span><br><span class="line">#同上，但忽略大小写</span><br><span class="line">[root@localhost ~]# find &#x2F;home -iname &quot;*.txt&quot;</span><br><span class="line">#当前目录及子目录下查找所有以.txt和.pdf结尾的文件</span><br><span class="line">[root@localhost ~]# find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br><span class="line">#查找路径包含local的文件或者目录</span><br><span class="line">[root@localhost ~]# find &#x2F;usr&#x2F; -path &quot;*local*&quot;</span><br><span class="line">#基于正则表达式匹配文件路径</span><br><span class="line">[root@localhost ~]# find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;借助&#96;-exec&#96;选项与其他命令结合使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#找出当前目录下所有root的文件，并把所有权更改为用户tom</span><br><span class="line">[root@localhost ~]# find .-type f -user root -exec chown tom &#123;&#125; \;</span><br><span class="line">#找出自己家目录下所有的.txt文件并删除，删除前先询问</span><br><span class="line">[root@localhost ~]# find $HOME&#x2F;. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br><span class="line">#查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span><br><span class="line">[root@localhost ~]# find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br><span class="line">#将30天前的.log文件移动到old目录中</span><br><span class="line">[root@localhost ~]# find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br><span class="line">#找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</span><br><span class="line">[root@localhost ~]# find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;逻辑运算符&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#查找文件大小超过2k并且是普通文件类型的文件</span><br><span class="line">[root@localhost ~]# find . -size +2k -a -type f</span><br><span class="line">#找出&#x2F;home下不是以.txt结尾的文件</span><br><span class="line">[root@localhost tmp]# find . -not -name &quot;*.txt&quot;</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# find &#x2F;home ! -name &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;搜索但跳出指定的目录&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span><br><span class="line">[root@localhost ~]# find . -path &quot;.&#x2F;sk&quot; -prune -o -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-locate-命令"><a href="#7-4-locate-命令" class="headerlink" title="7.4 locate 命令"></a>7.4 locate 命令</h3><p>locate命令其实是<code>find -name</code>的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录(<code>find</code> 是去硬盘找)，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code>，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用<code>locate</code>命令查不到最新变动过的文件，为了避免这种情况，可以在使用<code>locate</code>之前，先使用<code>updatedb</code>命令手动更新数据库。locate命令基本信息如下：</p>
<ul>
<li>命令名称：locate</li>
<li>英文原意：find files by name</li>
<li>所在路径：/usr/bin/locate</li>
<li>执行权限：所有用户</li>
<li>功能描述：按照文件名搜索文件</li>
</ul>
<p>命令格式：<code>locate [选项] 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>: 指定资料库的路径。默认是/var/lib/mlocate/mlocate.db</li>
<li><code>-n</code>：至多显示n个输出</li>
</ul>
</li>
</ul>
<p>数据库配置文件(<code>/etc/updatedb.conf</code>)内容说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;etc&#x2F;updatedb.conf</span><br><span class="line">#开启搜索限制，也就是让这个文件生效</span><br><span class="line">PRUNE_BIND_MOUNTS &#x3D; &quot;yes&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索这些文件类型</span><br><span class="line">PRUNEFS &#x3D; &quot;9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fusectl gfs gfs2 gpfs hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索这些扩展名的文件</span><br><span class="line">PRUNENAMES &#x3D; &quot;.git .hg .svn&quot;</span><br><span class="line">##在locate执行搜索时，禁止搜索这些系统目录</span><br><span class="line">PRUNEPATHS &#x3D; &quot;&#x2F;afs &#x2F;media &#x2F;net &#x2F;sfs &#x2F;tmp &#x2F;udev &#x2F;var&#x2F;cache&#x2F;ccache &#x2F;var&#x2F;spool&#x2F;cups &#x2F;var&#x2F;spool&#x2F;squid &#x2F;var&#x2F;tmp&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>locate优缺点：<br><strong>优点</strong>：按照数据库搜索，搜索速度快，消耗资源小<br><strong>缺点</strong>：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等</p>
</blockquote>
<h3 id="7-5-grep-命令"><a href="#7-5-grep-命令" class="headerlink" title="7.5 grep 命令"></a>7.5 grep 命令</h3><p>grep命令的作用是在文件中提取和匹配符合条件的字符串行，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。基本信息如下：</p>
<ul>
<li>命令名称：grep</li>
<li>英文原意：global search regular expression(RE) and print out the line</li>
<li>所在路径：/usr/bin/grep</li>
<li>执行权限：所有用户</li>
<li>功能描述：全面搜索正则表达式并把行打印出来</li>
</ul>
<p>命令格式：<code>grep [选项] 搜索内容 文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-i</code>：忽略大小写</li>
<li><code>-n</code>：输出行号</li>
<li><code>-v</code>：反向查找</li>
<li><code>-d 动作</code>: 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。动作包含：read、recurse、skip</li>
<li><code>-R</code>或<code>-r</code>: 此参数的效果和指定“-d recurse”参数相同，递归查找目录下的所有文件内容</li>
<li><code>--color=auto</code>：搜素出的关键字用颜色高亮显示</li>
</ul>
</li>
</ul>
<p>find也是搜索命令，那么find与grep命令有什么区别呢？<br><strong>find</strong>：find命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，通配符是完全匹配。(find命令也可以通过”-regex”选项，把匹配规则转为正则表达式规则)<br><strong>grep</strong>：grep命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，正则表达式是包含匹配。</p>
<blockquote>
<p>通配符与正则表达式的区别</p>
<ul>
<li>通配符：一般用于匹配文件名，完全匹配<ul>
<li><code>?</code>：匹配一个任意字符</li>
<li><code>*</code>：匹配0个或多个任意字符，也就是可以匹配任何内容</li>
<li><code>[]</code>：匹配中括号里任意一个字符。例如，[abc]代表一定匹配一个字符，或是a，或是b，或是c</li>
<li><code>[-]</code>：匹配中括号里任意一个字符，”-“代表一个范围。例如，[a-z]代表匹配一个小写字母</li>
<li><code>[^]</code>：逻辑非，表示匹配不是中括号里的一个字符。例如，[^0-9]代表匹配一个不是数字的字符</li>
</ul>
</li>
<li>正则表达式：一般用于匹配字符串<ul>
<li><code>?</code>：匹配前一个字符重复0次或1次</li>
<li><code>*</code>：匹配前一个字符重复0次或多次</li>
<li><code>[]</code>：匹配中括号里任意一个字符。例如，[abc]代表一定匹配一个字符，或是a，或是b，或是c</li>
<li><code>[-]</code>：匹配中括号里任意一个字符，”-“代表一个范围。例如，[a-z]代表匹配一个小写字母</li>
<li><code>[^]</code>：逻辑非，表示匹配不是中括号里的一个字符。例如，[^0-9]代表匹配一个不是数字的字符</li>
<li><code>^</code>：匹配行首</li>
<li><code>$</code>：匹配行尾   </li>
</ul>
</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</span><br><span class="line">[root@localhost ~]# grep match_pattern file_name</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_name</span><br><span class="line">#在多个文件中查找：</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_1 file_2 file_3</span><br><span class="line">#标记匹配颜色 --color&#x3D;auto 选项：</span><br><span class="line">[root@localhost ~]# grep &quot;match_pattern&quot; file_name --color&#x3D;auto</span><br><span class="line">#在当前目录中对文本进行递归搜索</span><br><span class="line">[root@localhost ~]# grep -r &quot;match_pattern&quot; .</span><br><span class="line">#正则匹配输出以数字开头的所有行</span><br><span class="line">[root@localhost ~]# grep &quot;^[0-9].*&quot; file_name</span><br></pre></td></tr></table></figure>


<h3 id="7-6-管道符"><a href="#7-6-管道符" class="headerlink" title="7.6 | 管道符"></a>7.6 | 管道符</h3><p>命令格式：<code>命令1 | 命令2</code><br>“|”管道符的作用是把命令1的正确输出作为命令2的操作对象</p>
<p><strong>示例1</strong>：<br>我们经常使用 “ll” 命令查看文件的长格式，不过在有些目录中文件很多，不如/etc/目录使用 “ll” 命令显示的内容就非常多，只能看到最后的内容而不能看到前面输出的内容，这时我们马上想到 “more” 命令可以分屏显示文件内容，一种笨方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用输出重定向，把&quot;ll&quot;命令的输出保存到&#x2F;root&#x2F;testfile</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; &gt; &#x2F;root&#x2F;testfile</span><br><span class="line">#然后用more分屏显示</span><br><span class="line">[root@localhost ~]# more &#x2F;root&#x2F;testfile</span><br></pre></td></tr></table></figure>
<p>这样操作实在是不方便，这时可以利用管道符，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#把&quot;ll&quot;命令的输出作为&quot;more&quot;命令的操作对象</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; | more</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在&quot;ll&quot;命令输出内容中搜索yum的文件名</span><br><span class="line">[root@localhost ~]# ll -a &#x2F;etc&#x2F; | grep yum</span><br></pre></td></tr></table></figure>


<p><strong>示例3</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#统计具体的网络连接数量（&quot;grep&quot;命令筛选，&quot;wc&quot;命令统计）</span><br><span class="line">[root@localhost ~]# netstat -an | grep -i &quot;ESTABLISHED&quot; | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="7-7-alias-命令"><a href="#7-7-alias-命令" class="headerlink" title="7.7 alias 命令"></a>7.7 alias 命令</h3><p>alias命令用来设置指令的别名，我们可以使用该命令可以将一些较长的命令进行简化。</p>
<p><strong>alias基本使用方法</strong>：</p>
<ul>
<li>打印已经设置的命令别名<ul>
<li><code>alias</code> 或  <code>alias -p</code></li>
</ul>
</li>
<li>给命令设置别名<ul>
<li>格式：<code>alias 新的命令=&#39;实际命令&#39;</code>。必须使用单引号’’实际命令引起来，防止特殊字符导致错误</li>
<li>例如：<code>alias l=&#39;ls -lsh&#39;</code>，现在只用输入 “l” 就可以列出目录了，相当于输入”ls -lsh”；<code>alias ser=&#39;service network restart&#39;</code>，现在输入”ser”就可以重启网络服务了</li>
</ul>
</li>
</ul>
<blockquote>
<p>直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？<br>使用编辑器打开<del>/.bashrc，在文件中加入别名设置，如：alias rm=’rm -i’，保存后执行source ~/.bashrc，这样就可以永久保存命令的别名了。因为修改的是当前用户目录下的</del>/.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc/bashrc文件就可以了。</p>
</blockquote>
<h2 id="8-压缩和解压缩命令"><a href="#8-压缩和解压缩命令" class="headerlink" title="8 压缩和解压缩命令"></a>8 压缩和解压缩命令</h2><p>在Linux中可以识别的常见压缩格式有十几种，比如”.zip”、”.gz”、”.bz2”、”.tar”、”.tar.gz”、”.tar.bz2”等。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间</p>
<h3 id="8-1-“-zip”-格式"><a href="#8-1-“-zip”-格式" class="headerlink" title="8.1 “.zip” 格式"></a>8.1 “.zip” 格式</h3><p>“.zip”是Windows中最常见的压缩格式，Liunx也可以正确识别”.zip”格式，这可以方便地和Windows系统通用压缩文件。</p>
<h4 id="8-1-1-zip-命令"><a href="#8-1-1-zip-命令" class="headerlink" title="8.1.1 zip 命令"></a>8.1.1 zip 命令</h4><p>zip命令就是”.zip”格式的压缩命令，基本信息如下：</p>
<ul>
<li>命令名称：zip</li>
<li>英文原意：package and compress(archive) files</li>
<li>所在路径：/usr/bin/zip</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩文件和目录</li>
</ul>
<p>命令格式：<code>zip [选项] 压缩包名 源文件或目录</code></p>
<ul>
<li>选项：<ul>
<li><code>-r</code>：压缩目录递归处理，将指定目录下的所有文件和子目录一并处理</li>
</ul>
</li>
</ul>
<h4 id="8-1-2-unzip-命令"><a href="#8-1-2-unzip-命令" class="headerlink" title="8.1.2 unzip 命令"></a>8.1.2 unzip 命令</h4><p>unzip命令就是”.zip”格式的解压缩命令，基本信息如下：</p>
<ul>
<li>命令名称：unzip</li>
<li>英文原意：list, test and extract compressed files in a zip archive</li>
<li>所在路径：/usr/bin/unzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：列表、测试和提取压缩文件中的文件</li>
</ul>
<p>命令格式：<code>unzip [选项] 压缩包名</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：指定解压的位置</li>
</ul>
</li>
</ul>
<h3 id="8-2-“-gz”-格式"><a href="#8-2-“-gz”-格式" class="headerlink" title="8.2 “.gz” 格式"></a>8.2 “.gz” 格式</h3><p>“.gz”格式是Linux中最常见的压缩格式。</p>
<h4 id="8-2-1-gzip-命令"><a href="#8-2-1-gzip-命令" class="headerlink" title="8.2.1 gzip 命令"></a>8.2.1 gzip 命令</h4><p>gzip命令是”.gz”格式的压缩和解压缩命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。<strong>注意：gzip不会打包文件，压缩的过程源文件会对应变为”.gz”格式的压缩文件(源文件被删除)，解压缩的过程将”.gz”格式的压缩文件再恢复成对应的源文件</strong>。基本信息如下：</p>
<ul>
<li>命令名称：gzip</li>
<li>英文原意：compress or expand files</li>
<li>所在路径：/bin/gzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩或解压缩 “.gz” 格式的文件或目录</li>
</ul>
<p>命令格式：<code>gzip [选项] 源文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：执行解压缩</li>
<li><code>-r</code>：递归处理，将指定目录下的所有文件及子目录一并处理</li>
<li><code>-c</code>：将压缩数据输出到标准输出中，可以保留源文件<ul>
<li>使用”-c”选项，压缩数据会直接输出到屏幕上，为了不让压缩数据输出到屏幕上而是重定向到压缩文件中，并且同时保留源文件，命令可以这样写：<code>gzip -c abc &gt; abc.gz</code></li>
</ul>
</li>
<li><code>-l</code>：列出压缩文件的相关信息 </li>
</ul>
</li>
</ul>
<h4 id="8-2-2-gunzip-命令"><a href="#8-2-2-gunzip-命令" class="headerlink" title="8.2.2 gunzip 命令"></a>8.2.2 gunzip 命令</h4><p>gunzip命令用来解压缩 “.gz” 格式的文件(即使用 “gzip” 命令压缩的文件)，作用相当于 “gzip -d 压缩文件”，因此不论是压缩或解压缩，都可通过 “gzip” 指令单独完成。基本下信息如下：</p>
<ul>
<li>命令名称：gunzip</li>
<li>英文原意：expand files</li>
<li>所在路径：/bin/gunzip</li>
<li>执行权限：所有用户</li>
<li>功能描述：解压缩”.gz” 格式的文件或目录</li>
</ul>
<p>命令格式：<code>gunzip [选项] 压缩文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-r</code>：递归处理，将指定目录下的所有文件及子目录一并处理</li>
<li><code>-c</code>：把解压后的文件数据输出到标准输出中，可以保留压缩文件</li>
<li><code>-l</code>：列出压缩文件的相关信息</li>
</ul>
</li>
</ul>
<h3 id="8-3-“-bz2”-格式"><a href="#8-3-“-bz2”-格式" class="headerlink" title="8.3 “.bz2” 格式"></a>8.3 “.bz2” 格式</h3><p>“.bz2” 格式是Linux的另一种压缩格式，从理论上来讲，”.bz2” 格式的算法更新进、压缩比更好；而 “.gz” 格式相对来讲压缩的时间更快</p>
<h4 id="8-3-1-bzip2-命令"><a href="#8-3-1-bzip2-命令" class="headerlink" title="8.3.1 bzip2 命令"></a>8.3.1 bzip2 命令</h4><p>bzip2 命令是 “.bz2” 格式文件的压缩和解压缩命令。<strong>注意：”bzip2”不能用来压缩目录</strong>。基本信息如下：</p>
<ul>
<li>命令名称：bzip2</li>
<li>英文原意：a block-sorting file compressor</li>
<li>所在路径：/usr/bin/bzip2</li>
<li>执行权限：所有用户</li>
<li>功能描述：压缩或解压缩 “.bz2” 格式的文件</li>
</ul>
<p>命令格式：<code>bzip2 [选项] 源文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：执行解压缩</li>
<li><code>-k</code>：压缩或解压缩后，会删除原始文件，若要保留原始文件，请使用此参数</li>
<li><code>-f</code>：在压缩或解压缩时，若输出文件与现有文件同名，强制覆盖现有文件</li>
<li><code>-c</code>：将压缩与解压缩的数据输出到标准输出中</li>
</ul>
</li>
</ul>
<h4 id="8-3-2-bunzip2-命令"><a href="#8-3-2-bunzip2-命令" class="headerlink" title="8.3.2 bunzip2 命令"></a>8.3.2 bunzip2 命令</h4><p>bunzip2命令用来解压缩 “.bz2” 格式的文件(即使用 “bzip2” 命令压缩的文件)，作用相当于 “bzip2 -d 压缩文件”，因此不论是压缩或解压缩，都可通过 “bzip2” 指令单独完成。基本信息如下：</p>
<ul>
<li>命令名称：bunzip2</li>
<li>英文原意：a block-sorting file compressor</li>
<li>所在路径：/usr/bin/bunzip2</li>
<li>执行权限：所有用户</li>
<li>功能描述：解压缩 “.bz2” 格式的文件</li>
</ul>
<p>命令格式：<code>bunzip2 [选项] 压缩文件</code></p>
<ul>
<li>选项：<ul>
<li><code>-k</code>：bzip2在解压缩后，会删除原始压缩文件，若要保留原始压缩文件，请使用此参数</li>
<li><code>-f</code>：解压缩时，若输出的文件与现有文件同名时，强制覆盖现有的文件</li>
<li><code>-c</code>：将解压缩的数据输出到标准输出中</li>
</ul>
</li>
</ul>
<h3 id="8-4-“-tar”、”-tar-gz”、”-tar-bz2”-格式"><a href="#8-4-“-tar”、”-tar-gz”、”-tar-bz2”-格式" class="headerlink" title="8.4 “.tar”、”.tar.gz”、”.tar.bz2” 格式"></a>8.4 “.tar”、”.tar.gz”、”.tar.bz2” 格式</h3><p>tar命令可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。<strong>注意：打包和压缩是两个不同的概念，打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</strong>。为什么要区分这两个概念呢？这源于Linux中很多压缩程序(gzip、bzip2)只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar），然后再用压缩程序进行压缩。tar命令基本信息如下：</p>
<ul>
<li>命令名称：tar</li>
<li>英文原意：tar</li>
<li>所在路径：/usr/bin/tar</li>
<li>执行权限：所有用户</li>
<li>功能描述：打包与解打包文件</li>
</ul>
<p>命令格式：<br><strong>打包</strong>：<code>tar -c [选项] [-f 包文件名] 源文件或目录</code><br><strong>解打包</strong>：<code>tar -x [选项] -f 包文件名</code></p>
<ul>
<li>选项：<ul>
<li><code>-c</code>：执行打包</li>
<li><code>-x</code>：执行解打包</li>
<li><code>-z</code>：支持压缩和解压缩 “.tar.gz” 格式文件</li>
<li><code>-j</code>：支持压缩和解压缩 “.tar.bz2” 格式文件</li>
<li><code>-C 目录路径</code>：指定解打包位置</li>
<li><code>-f 包文件名</code>: 指定打包文件名(.tar)或压缩包文件名(.tar.gz、.tar.bz2)。（执行打包时不写此选项，会默认把打包数据输出到屏幕）</li>
<li><code>-v</code>: 显示打包或解打包过程</li>
<li><code>-t</code>：测试，就是不解打包，只是查看包中有哪些文件</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#打包不会压缩</span><br><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line">#解打包到当前目录</span><br><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar</span><br><span class="line">#解打包到指定目录</span><br><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar -C &#x2F;testdir&#x2F;</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar.gz&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#把&#x2F;tmp&#x2F;目录直接打包并压缩为&quot;.tar.gz&quot;格式</span><br><span class="line">[root@localhost ~]# tar -zcvf tmp.tar.gz &#x2F;tmp&#x2F;</span><br><span class="line">#解压缩并解打包&quot;.tar.gz&quot;格式文件</span><br><span class="line">[root@localhost ~]# tar -zxvf tmp.tar.gz</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.tar.bz2&quot;格式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#把&#x2F;tmp&#x2F;目录直接打包并压缩为&quot;.tar.bz2&quot;格式</span><br><span class="line">[root@localhost ~]# tar -jcvf tmp.tar.gz &#x2F;tmp&#x2F;</span><br><span class="line">#解压缩并解打包&quot;.tar.bz2&quot;格式文件</span><br><span class="line">[root@localhost ~]# tar -jxvf tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-关机和重启命令"><a href="#9-关机和重启命令" class="headerlink" title="9 关机和重启命令"></a>9 关机和重启命令</h2><h3 id="9-1-sync-数据同步"><a href="#9-1-sync-数据同步" class="headerlink" title="9.1 sync 数据同步"></a>9.1 sync 数据同步</h3><p>sync命令用于强制被改变的内容立刻写入磁盘。在Linux/Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行sync命令，系统会自动执行update或bdflush操作，将缓冲区的数据写入磁盘。<strong>只有在update或bdflush无法执行或用户需要非正常关机时，才需手动执行sync命令</strong>。基本信息如下：</p>
<ul>
<li>命令名称：sync</li>
<li>英文原意：flush file system buffers</li>
<li>所在路径：/bin/sync</li>
<li>执行权限：所有用户</li>
<li>功能描述：刷新文件系统缓冲区</li>
</ul>
<p>命令格式：<code>sync [选项]</code></p>
<h3 id="9-2-shutdown-命令"><a href="#9-2-shutdown-命令" class="headerlink" title="9.2 shutdown 命令"></a>9.2 shutdown 命令</h3><p>shutdown命令用来系统关机。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。基本信息如下：</p>
<ul>
<li>命令名称：shutdown</li>
<li>英文原意：bring the system down</li>
<li>所在路径：/sbin/shutdown</li>
<li>执行权限：超级用户</li>
<li>功能描述：关机和重启</li>
</ul>
<p>命令格式：<code>shutdown [选项] 时间 [警告信息]</code></p>
<ul>
<li><p>选项：</p>
<ul>
<li><code>-c</code>：取消将要执行的shutdown命令</li>
<li><code>-h</code>：系统关机</li>
<li><code>-r</code>：系统重启</li>
</ul>
</li>
<li><p>时间：<code>now</code> 立即执；<code>hh:mm</code> 指定确定时间点执行；<code>+分钟数</code> 延迟指定分钟后执行 </p>
</li>
<li><p>警告信息：执行指令时，同时送出警告信息给登入用户</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#立即关机</span><br><span class="line">[root@localhost ~]# shutdown -h now</span><br><span class="line">#指定5分钟后关机，同时送出警告信息给登入用户：</span><br><span class="line">[root@localhost ~]# shutdown +5 &quot;System will shutdown after 5 minutes&quot;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-reboot-命令"><a href="#9-3-reboot-命令" class="headerlink" title="9.3 reboot 命令"></a>9.3 reboot 命令</h3><p>reboot命令用来重新系统，命令也是安全的，而且不需要过多的选项</p>
<ul>
<li>命令名称：reboot</li>
<li>英文原意：reboot</li>
<li>所在路径：/sbin/reboot</li>
<li>执行权限：超级用户</li>
<li>功能描述：重启系统</li>
</ul>
<p>命令格式：<code>reboot [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-d</code>：重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有“-n”参数效果；</li>
<li><code>-f</code>：强制重新开机，不调用shutdown指令的功能；</li>
<li><code>-i</code>：在重开机之前，先关闭所有网络界面；</li>
<li><code>-n</code>：重开机之前不检查是否有未结束的程序；</li>
<li><code>-w</code>：仅做测试，并不真正将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件。</li>
</ul>
</li>
</ul>
<h3 id="9-4-halt-和-poweroff-命令"><a href="#9-4-halt-和-poweroff-命令" class="headerlink" title="9.4 halt 和 poweroff 命令"></a>9.4 halt 和 poweroff 命令</h3><p>halt 和 poweroff 这两都是系统关机命令，直接执行即可。但是两个命令不会完整关闭和保存系统的服务，不建议使用。</p>
<h3 id="9-5-init-命令"><a href="#9-5-init-命令" class="headerlink" title="9.5 init 命令"></a>9.5 init 命令</h3><p>init 命令是修改Linux 运行级别的命令，是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。也可以用于关机和重启，这个命令并不安全，不建议使用</p>
<p>命令格式：<code>init [选项] 系统运行级别</code></p>
<ul>
<li>选项：<ul>
<li><code>-b</code>：不执行相关脚本而直接进入单用户模式</li>
<li><code>-s</code>：切换到单用户模式</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关机，也就是调用系统的0级别</span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line">#重启，也就是调用系统的6级别</span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>Linux有7个系统运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为Windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留，没有用到</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<blockquote>
<p><code>runlevel</code> 命令可查看当前系统运行级别</p>
</blockquote>
<h2 id="10-常用网络命令"><a href="#10-常用网络命令" class="headerlink" title="10 常用网络命令"></a>10 常用网络命令</h2><h3 id="10-1-配置IP地址"><a href="#10-1-配置IP地址" class="headerlink" title="10.1 配置IP地址"></a>10.1 配置IP地址</h3><p>IP地址是计算机在互联网中唯一的地址编码，每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的IP地址</p>
<p>IP地址的配置有两种方法：</p>
<ul>
<li><strong>setup 工具</strong></li>
<li><strong>手工修改网卡配置文件</strong><ul>
<li>第一步：编辑网卡文件，<code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code>，”ifcfg-eth0”是第一块网卡，第二块网卡则为”ifcfg-eth1”，以此类推。网卡文件内容配置项如下： <ul>
<li>DEVICE=eth0 #网卡设备名</li>
<li>BOOTPROTO=static  #[none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</li>
<li>HWADDR=00:15:5D:00:46:83 #MAC地址</li>
<li>UUID=5753e2ed-add1-4d1c-8a69-21a89647b050 # 唯一识别码</li>
<li>NM_CONTROLLED=yes  #是否可以由Network Manager图形管理工具托管</li>
<li>ONBOOT=yes  #[yes|no]，是否随网络服务启动，如果配置”no”，使用”ifconfig”命令时看不到该网卡</li>
<li>TYPE=Ethernet # 网络类型</li>
<li>IPADDR=192.168.1.10  #IP地址</li>
<li>NETMASK=255.255.255.0  #子网掩码</li>
<li>NETWORK=192.168.1.0  #网络地址</li>
<li>BROADCAST=192.168.1.255  #广播地址</li>
<li>GATEWAY=192.168.1.1  #网关地址</li>
<li>DNS1=202.109.14.5   #首选DNS服务地址</li>
<li>DNS2=219.141.136.10  #备用DNS服务地址</li>
<li>USERCTL=no  #[yes|no]（非root用户是否可以控制该设备）</li>
</ul>
</li>
<li>第二步：查看DNS服务配置文件，<code>vim /etc/resolv.conf</code>，里面的内容是系统自动生成的，一般不需要修改</li>
<li>第三步：重启网络服务，<code>service network restart</code> 或 <code>/etc/init.d/network restart</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用虚拟机克隆时，UUID可能复制的是一样的，导致网络服务启动失败，需要重置UUID值：<br>第一步：编辑网卡文件，删除UUID和MAC地址<br>第二步: 删除MAC地址和UUID绑定文件，<code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code><br>第三部：重启系统</p>
</blockquote>
<h3 id="10-2-ifconfig-命令"><a href="#10-2-ifconfig-命令" class="headerlink" title="10.2 ifconfig 命令"></a>10.2 ifconfig 命令</h3><p>ifconfig 被用于配置和显示Linux内核中网络接口的网络参数。<strong>用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在</strong>，要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。基本信息如下：</p>
<ul>
<li>命令名称：ifconfig</li>
<li>英文原意：configure a network interface</li>
<li>所在路径：/sbin/ifconfig</li>
<li>执行权限：超级用户</li>
<li>功能描述：配置网络接口</li>
</ul>
<p>命令格式：<code>ifconfig [参数]</code></p>
<ul>
<li>参数：<ul>
<li><code>add 地址</code>：设置网络设备IPv6的ip地址；</li>
<li><code>del 地址</code>：删除网络设备IPv6的IP地址；</li>
<li><code>down</code>：关闭指定的网络设备；</li>
<li><code>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;</code>：设置网络设备的类型与硬件地址；</li>
<li><code>io_addr I/O地址</code>：设置网络设备的I/O地址；</li>
<li><code>irq IRQ地址</code>：设置网络设备的IRQ；</li>
<li><code>media 网络媒介类型</code>：设置网络设备的媒介类型；</li>
<li><code>mem_start 内存地址</code>：设置网络设备在主内存所占用的起始地址；</li>
<li><code>metric 数目</code>：指定在计算数据包的转送次数时，所要加上的数目；</li>
<li><code>mtu 字节</code>：设置网络设备的MTU；</li>
<li><code>netmask 子网掩码</code>：设置网络设备的子网掩码；</li>
<li><code>tunnel 地址</code>：建立IPv4与IPv6之间的隧道通信地址；</li>
<li><code>up</code>：启动指定的网络设备；</li>
<li><code>IP地址</code>：指定网络设备的IP地址；</li>
<li><code>网络设备</code>：指定网络设备的名称。</li>
</ul>
</li>
</ul>
<p>ifconfig 命令最主要的作用就是查看IP地址的信息，直接输入<code>ifconfig</code>命令即可显示激活状态的网络设备信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  </span><br><span class="line">          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)</span><br></pre></td></tr></table></figure>
<p>内容说明：</p>
<ul>
<li><strong>eth0</strong> 表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:16:3E:00:1E:51</li>
<li><strong>inet addr</strong> 用来表示网卡的IP地址，此网卡的IP地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0</li>
<li><strong>lo</strong> 是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回环地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了，但只是本机能看得到，局域网的其它主机或用户无从知道<ul>
<li>第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）</li>
<li>第二行：网卡的IP地址、子网、掩码</li>
<li>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节</li>
<li>第四、五行：接收、发送数据包情况统计</li>
<li>第七行：接收、发送数据字节数统计信息</li>
</ul>
</li>
</ul>
<p>其他示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动和关闭网卡eth0。关闭网卡eth0，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡</span><br><span class="line">[root@localhost ~]# ifconfig eth0 up</span><br><span class="line">[root@localhost ~]# ifconfig eth0 down</span><br><span class="line"></span><br><span class="line">#为网卡eth0配置IPv6地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F;64  </span><br><span class="line"> #为网卡eth0删除IPv6地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F;64 </span><br><span class="line"></span><br><span class="line">#用ifconfig修改MAC地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE</span><br><span class="line">#ifconfig配置IP地址</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</span><br><span class="line"></span><br><span class="line">#启用和关闭arp协议</span><br><span class="line">[root@localhost ~]# ifconfig eth0 arp   </span><br><span class="line">[root@localhost ~]# ifconfig eth0 -arp</span><br><span class="line"></span><br><span class="line">#设置最大传输单元，这里设置能通过的最大数据包大小为 1500 bytes</span><br><span class="line">[root@localhost ~]# ifconfig eth0 mtu 1500 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-3-ping-命令"><a href="#10-3-ping-命令" class="headerlink" title="10.3 ping 命令"></a>10.3 ping 命令</h3><p>ping 命令是常用的网络命令，主要通过ICMP协议进行网络探测，测试网络中主机的通信情况。基本信息如下：</p>
<ul>
<li>命令名称：ping</li>
<li>英文原意：send ICMP ECHO_REQUEST to network hosts</li>
<li>所在路径：/bin/ping</li>
<li>执行权限：所有用户</li>
<li>功能描述：向网络主机发送ICMP请求</li>
</ul>
<p>命令格式： <code>ping [选项] IP</code></p>
<ul>
<li>选项：<ul>
<li>-b：用于对整个网段进行探测。IP需要为广播地址</li>
<li>-c 次数：设置完成要求回应的次数</li>
<li>-s 字节数：设置数据包的大小</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#探测整个网段中有多少主机是可以和本机通信的，而不是一个一个IP地址地进行探测</span><br><span class="line">[root@localhost ~]# ping -b -c 3 192.168.199.255</span><br><span class="line">WARNING: pinging broadcast address</span><br><span class="line">PING 192.168.199.255 (192.168.199.255) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.199.216: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;77.7 ms</span><br><span class="line">64 bytes from 192.168.199.131: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;102 ms</span><br><span class="line">64 bytes from 192.168.199.216: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;19.5 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.199.255 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2023ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 19.515&#x2F;66.701&#x2F;102.798&#x2F;34.892 ms</span><br></pre></td></tr></table></figure>

<h3 id="10-4-netstat-命令"><a href="#10-4-netstat-命令" class="headerlink" title="10.4 netstat 命令"></a>10.4 netstat 命令</h3><p>netstat是网络状态查看命令，既可以查看到本机开启的端口，也可以查看哪些客户端连接。在CentOS 7.x中 netstat 命令默认没有安装，如果需要使用，需要先安装 “net-snmp” 和 “net-tools” 软件包。基本信息如下：</p>
<ul>
<li>命令名称：network</li>
<li>英文原意：print network connections, routing tables, interface statistics, masquerade connections, and mulicast memberships</li>
<li>所在路径：/bin/netstat</li>
<li>执行权限：所有用户</li>
<li>功能描述：打印网络连接、路由表、接口统计信息、伪装连接和多播成员身份</li>
</ul>
<p>命令格式：<code>netstat [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：列出所有网络状态，包括Socket程序</li>
<li><code>-c 秒数</code>：制定每隔几秒刷一次网络状态</li>
<li><code>-n</code>：使用IP地址和端口号显示，不使用域名与服务名</li>
<li><code>-p</code>：显示PID和程序</li>
<li><code>-t</code>：显示使用TCP协议端口的连接情况</li>
<li><code>-u</code>：显示使用UDP协议端口的连接情况</li>
<li><code>-l</code>：仅显示监听状态的连接</li>
<li><code>-r</code>：显示路由表</li>
</ul>
</li>
</ul>
<p><strong>示例 1：查看本机开启的端口</strong><br>这是本机最常用的方式，使用”-tuln”选项。因为使用了”-l”选项，所以只能看到监听状态的连接，而不能看到已经建立连接状态的连接，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tuln</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State            </span><br><span class="line">tcp        0      0 0.0.0.0:3306                0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:11211               0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 :::11211                    :::*                        LISTEN</span><br><span class="line">tcp        0      0 :::80                       :::*                        LISTEN</span><br><span class="line">tcp        0      0 :::22                       :::*                        LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:11211               0.0.0.0:* </span><br><span class="line">udp        0      0 :::11211                    :::*  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个命令输出内容较多，下面对每列进行说明：</p>
<ul>
<li><strong>Proto</strong>：网络连接的协议，一般就是 TCP 协议或者 UDP 协议</li>
<li><strong>Recv-Q</strong>：接收队列。表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走</li>
<li><strong>Send-Q</strong>：发送队列。表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备ACK标志的数据包</li>
<li><strong>Local Address</strong>：本机的 IP 地址和端口号。</li>
<li><strong>Foreign Address</strong>：远程主机的 IP 地址和端口号。</li>
<li><strong>State</strong>：状态。常见的状态主要有以下几种：<ul>
<li>LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听</li>
<li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态</li>
<li>SYN_SENT：SYN 发起包，就是主动发起连接的数据包</li>
<li>SYN_RECV：接收到主动连接的数据包</li>
<li>FIN_WAIT1：正在中断的连接</li>
<li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认</li>
<li>TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束</li>
<li>CLOSED：套接字没有被使用</li>
<li>在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种代表已经建立连接</li>
</ul>
</li>
</ul>
<p><strong>示例 2：查看本机有哪些程序开启的端口</strong><br>如果使用“-p”选项，查询结果会多出一列”PID/Program name”，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tulnp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address      Foreign Address     State      PID&#x2F;Program name       </span><br><span class="line">tcp        0      0 0.0.0.0:3306       0.0.0.0:*           LISTEN     2359&#x2F;mysqld</span><br><span class="line">tcp        0      0 0.0.0.0:11211      0.0.0.0:*           LISTEN     1563&#x2F;memcached</span><br><span class="line">tcp        0      0 0.0.0.0:22         0.0.0.0:*           LISTEN     1490&#x2F;sshd</span><br><span class="line">tcp        0      0 :::11211           :::*                LISTEN     1563&#x2F;memcached</span><br><span class="line">tcp        0      0 :::80              :::*                LISTEN     21025&#x2F;httpd</span><br><span class="line">tcp        0      0 :::22              :::*                LISTEN     1490&#x2F;sshd</span><br><span class="line">udp        0      0 0.0.0.0:11211      0.0.0.0:*                      1563&#x2F;memcached</span><br><span class="line">udp        0      0 :::11211           :::*                           1563&#x2F;memcached</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：查看所有连接</strong><br>使用选项“-an”可以查看所有连接，包括监听状态的连接（LISTEN）、已经建立连接状态的<br>连接（ESTABLISHED）、Socket 程序连接等。因为连接较多，所以输出的内容有很多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -an</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State            </span><br><span class="line">tcp        0      0 0.0.0.0:3306                0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:11211               0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 117.79.130.170:80           78.46.174.55:58815          SYN_RECV</span><br><span class="line">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 117.79.130.170:22           124.205.129.99:10379        ESTABLISHED</span><br><span class="line">tcp        0      0 117.79.130.170:22           124.205.129.99:11811        ESTABLISHED</span><br><span class="line">...省略部分内容...</span><br><span class="line">udp        0      0 0.0.0.0:11211               0.0.0.0:* </span><br><span class="line">udp        0      0 :::11211                    :::* </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12668  &#x2F;var&#x2F;run&#x2F;mcelog-client</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12193  @&#x2F;var&#x2F;run&#x2F;hald&#x2F;dbus-ZeYsMXZ7Uf</span><br><span class="line">...省略部分内容...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 “Active UNIX domain sockets” 开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网<br>络服务产生的连接。我们可以在“-an”选项的输出中看到各种网络连接状态，而之前的“-tuln”选项则只能看到监听状态的连接</p>
<h3 id="10-5-write-命令"><a href="#10-5-write-命令" class="headerlink" title="10.5 write 命令"></a>10.5 write 命令</h3><p>write 命令用于向指定登录用户终端上发送信息。通过write命令可传递信息给另一位登入系统的用户，当输入完毕后，键入 “回车” 表示发送，键入 “Ctrl+C” 表示信息结束。如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。基本信息：</p>
<ul>
<li>命令名称：write</li>
<li>英文原意：send a message to another user</li>
<li>所在路径：/usr/bin/write</li>
<li>执行权限：所有用户</li>
<li>功能描述：向其他用户发送消息</li>
</ul>
<p>命令格式 ：<code>write 用户名 [终端编号]</code></p>
<ul>
<li><code>用户名</code>：指定要接受信息的登录用户</li>
<li><code>终端编号</code>：指定接收信息的用户的登录终端，如果省略，且用户在多个终端登录，会发送给其中一个终端</li>
</ul>
<h3 id="10-6-wall-命令"><a href="#10-6-wall-命令" class="headerlink" title="10.6 wall 命令"></a>10.6 wall 命令</h3><p>wall命令用于向系统当前所有打开的终端上输出信息，而 “write” 命令用于给指定用户发送消息。</p>
<p>命令格式：<code>wall 消息</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wall &quot;I will be in 5 minutes to restart, please save your data&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-系统痕迹命令"><a href="#11-系统痕迹命令" class="headerlink" title="11 系统痕迹命令"></a>11 系统痕迹命令</h2><p>系统中有一些重要的痕迹日志文件，如 /var/log/wtmp、 /var/run/utmp、 /var/log/btmp、/var/log/lastlog 等日志文件，如果你用 vim 打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误登录等重要的系统信息。这些信息要是可以通过 vim 打开，就能编辑，这样痕迹信息就不准确，所以这些重要的痕迹日志，只能通过对应的命令来进行查看。</p>
<h3 id="11-1-w-命令"><a href="#11-1-w-命令" class="headerlink" title="11.1 w 命令"></a>11.1 w 命令</h3><p>w 命令是显示系统中正在登录的用户信息的命令，这个命令查看的痕迹日志是 “/var/run/utmp”。基础信息如下：</p>
<ul>
<li>命令名称：w</li>
<li>英文原意：show who is logged on and what they are doing</li>
<li>所在路径：/usr/bin/w</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示登录用户和他们正在做什么</li>
</ul>
<p>命令格式：<code>w [选项] [用户名]</code></p>
<ul>
<li>选项：<ul>
<li><code>-h</code>：不打印头信息；</li>
<li><code>-u</code>：当显示当前进程和cpu时间时忽略用户名；</li>
<li><code>-s</code>：使用短输出格式；</li>
<li><code>-f</code>：显示用户从哪登录；</li>
</ul>
</li>
<li>用户：仅显示指定用户</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 18:31:08 up 1 day, 16 min,  3 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     tty1     -                Sat18   49:23   0.07s  0.07s -bash</span><br><span class="line">root     pts&#x2F;0    192.168.199.119  18:22    8:17   0.02s  0.02s -bash</span><br><span class="line">root     pts&#x2F;1    192.168.199.119  18:22    0.00s  0.03s  0.00s w</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>第一行内容：<ul>
<li>18:31:08：系统当前时间</li>
<li>up 1 day, 16 min：系统的运行时间</li>
<li>3 users：当前登录终端数量</li>
<li>load average: 0.00, 0.00, 0.00：系统在之前1分钟、5分钟、15分钟的平均负载。如果CPU是单核的，则这个数据超过1就是高负载；如果CPU是四核的，则这个数值超过4就是高负载</li>
</ul>
</li>
<li>第二行内容：<ul>
<li>USER：当前登录的用户</li>
<li>TTY：登录的终端。tty1-6: 本地字符终端(alt+F1-6 切换)，tty7: 本地图形终端(ctrl+F7切换，必须安装启动图形界面)，pts/0-255: 远程终端</li>
<li>FROM：登录的IP地址，如果是本地终端，则是空</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户空闲时间  </li>
<li>JCPU：所有的进程占用的CPU时间   </li>
<li>PCPU：当前进程占用的CPU时间 </li>
<li>WHAT：用户正在进行的操作</li>
</ul>
</li>
</ul>
<h3 id="11-2-who-命令"><a href="#11-2-who-命令" class="headerlink" title="11.2 who 命令"></a>11.2 who 命令</h3><p>who 命令和 w 命令类似，用于查看正在登录的用户，但显示的内容更加简单，也是查看 “/var/run/utmp” 日志。</p>
<p>命令格式：<code>who [选项] [查询文件]</code></p>
<ul>
<li>选项：<ul>
<li><code>-H</code>：显示各栏位的标题信息列</li>
<li><code>-q</code>：只显示登入系统的帐号名称和总人数</li>
<li><code>-w</code>：显示用户的信息状态栏</li>
<li><code>-u</code>：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串</li>
</ul>
</li>
<li>查询文件：指定要查询的文件，默认是/var/run/utmp</li>
</ul>
<h3 id="11-3-last-命令"><a href="#11-3-last-命令" class="headerlink" title="11.3 last 命令"></a>11.3 last 命令</h3><p>last 命令查看系统所有登录过的用户信息，包括正在登录的用户和之前登录的用户，这个命令查看的是 “/var/log/wtmp” 痕迹日志文件</p>
<p>命令格式：<code>last [选项] [用户|终端]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：把从何处登入系统的主机名称或ip地址，显示在最后一行</li>
<li><code>-d</code>：将IP地址转换成主机名称</li>
<li><code>-f 记录文件</code>：指定记录文件</li>
<li><code>-n 显示列数</code>或<code>-显示列数</code>：设置列出名单的显示列数</li>
<li><code>-R</code>：不显示登入系统的主机名称或IP地址</li>
<li><code>-x</code>：显示系统关机，重新开机，以及执行等级的改变等信息</li>
</ul>
</li>
<li>用户|终端：显示指定的用户或终端</li>
</ul>
<h3 id="11-4-lastlog-命令"><a href="#11-4-lastlog-命令" class="headerlink" title="11.4 lastlog 命令"></a>11.4 lastlog 命令</h3><p>lastlog 命令是查看系统中所有用户最好一次的登录时间的命令，这个命令查看的是 “/var/log/lastlog” 痕迹日志文件</p>
<p>命令格式：<code>lastlog [选项]</code></p>
<ul>
<li>选项：<ul>
<li><code>-b 天数</code>：显示指定天数前的登录信息</li>
<li><code>-t 天数</code>：显示指定天数以来的登录信息</li>
<li><code>-u 用户名</code>：显示指定用户的最近登录信息</li>
</ul>
</li>
</ul>
<h3 id="11-5-lostb-命令"><a href="#11-5-lostb-命令" class="headerlink" title="11.5 lostb 命令"></a>11.5 lostb 命令</h3><p>lastb 命令是查看错误登录的信息的，查看的是 “/var/log/btmp” 痕迹日志</p>
<p>命令格式：<code>lostb [选项] [用户|终端]</code></p>
<ul>
<li>选项：<ul>
<li><code>-a</code>：把从何处登入系统的主机名称或ip地址显示在最后一行</li>
<li><code>-d</code>：将IP地址转换成主机名称</li>
<li><code>-f 记录文件</code>：指定记录文件</li>
<li><code>-n 显示列数</code>或<code>-显示列数</code>：设置列出名单的显示列数</li>
<li><code>-R</code>：不显示登入系统的主机名称或IP地址</li>
<li><code>-x</code>：显示系统关机，重新开机，以及执行等级的改变等信息</li>
</ul>
</li>
<li>用户|终端：显示指定的用户或终端</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分区与挂载</title>
    <url>/20200207/linux1/9694dab2a110.html</url>
    <content><![CDATA[<h2 id="1-Linux版本"><a href="#1-Linux版本" class="headerlink" title="1.Linux版本"></a>1.Linux版本</h2><p>Linux分为<strong>内核版</strong>和<strong>发行版</strong>，Linux内核其实就是一个操作系统最底层的核心及其提供的核心工具，仅有内核而没有应用软件的操作系统是无法使用的，为了让使用者能够接触到Linux，于是很多的商业公司或非营利团体，就将 Linux Kernel(含 tools)与可运行的软件整合起来，加上自己具有创意的工具程序，这个工具程序可以让用户以光盘/DVD 或者透过网络直接安装/管理 Linux 系统，这个『Kernel + Softwares + Tools + 可完全安装程序』的咚咚，我们称之为Linux发行版。</p>
<a id="more"></a>

<p>Linux发行版本根据软件包管理方式大致可以分为两类，<strong>RPM方式管理软件的系统</strong>(RedHat系列：RedHat、CentOS、OpenSuSe等)，<strong>DPKG方式管理软件的系统</strong>(Debian系列：Debian、Ubuntu等)</p>
<h2 id="2-Linux分区与挂载"><a href="#2-Linux分区与挂载" class="headerlink" title="2.Linux分区与挂载"></a>2.Linux分区与挂载</h2><p>用于学习或者实验的话，一般采用虚拟机安装Linux操作系统即可，比较常用的虚拟机软件有VMware、VirtualBox，如果你的电脑是win10系统的话可以直接使用系统自带虚拟机软件Hyper-v，具体使用和安装过程这里不再详述可以自行参照网上教程，这里主要说一下Linux的分区与挂载。</p>
<h3 id="2-1-分区方式"><a href="#2-1-分区方式" class="headerlink" title="2.1 分区方式"></a>2.1 分区方式</h3><p>常见的两种分区表现形式，<br><strong>MBR分区表</strong>：最大支持2.1T硬盘，最多支持4个分区，支持32位和64位系统；<br><strong>GPT分区表</strong>(全局唯一标示分区表)：支持9.4ZB(1ZB=1024PB, 1PB=1024EB, 1EB=1024TB)，理论上支持的分区数没有限制(但windows限制128个主分区)，只支持64位系统。<br>虽然GPT是一个较新的分区机制，解决了MBR很多缺点，但是目前使用最多的还是MBR分区方式。MBR最多有4个分区，分区类型有三种：</p>
<ul>
<li><strong>主分区</strong></li>
<li><strong>扩展分区</strong><ul>
<li>最多有一个</li>
<li>扩展分区+主分区数最多不超过4个</li>
<li>不能写入数据，不能格式化，只能用来包含逻辑分区</li>
</ul>
</li>
<li><strong>逻辑分区</strong><ul>
<li>包含在扩展分区内，可以有多个</li>
<li>扩展分区至少要包含一个逻辑分区</li>
</ul>
</li>
</ul>
<h3 id="2-2-设备挂载"><a href="#2-2-设备挂载" class="headerlink" title="2.2 设备挂载"></a>2.2 设备挂载</h3><p>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，windows是通过设备管理器来管理硬件的，linux的设备文件保存在<code>/dev/</code>目录中，比如硬盘文件是<code>/dev/sd[a-p]</code>，光盘文件是<code>/dev/hdc</code>等，硬件设备需要挂载到相应的目录文件才能使用。</p>
<p>所谓的<strong>挂载</strong>就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区的意思，这个动作我们称为<strong>挂载</strong>，那个进入点的目录我们称为<strong>挂载点</strong>。 由于整个 Linux 系统最重要的是根目录(<code>/</code>)，因此根目录一定需要挂载到某个分区， 至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。</p>
<p>常见的硬件设备文件名如下：</p>
<table>
<thead>
<tr>
<th>硬件</th>
<th>设备名称</th>
</tr>
</thead>
<tbody><tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom或/dev/sr0</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[01-1]</td>
</tr>
<tr>
<td>打印机(25针)</td>
<td>/dev/lp[0-2]</td>
</tr>
<tr>
<td>打印机(USB)</td>
<td>/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
</tbody></table>
<p>图示说明：<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux001.png?x-oss-process=style/watermarking" alt="linux设备挂载示意图"></p>
<p>上图所示，硬盘被分为三个可用分区，其中sda1、sda2为主分区分别挂载在/boot和 / 目录下，sda3为扩展分区内部包含一个逻辑分区sda5，sda5挂载在/home目录下。/boot目录下的所有数据存储在sda1分区里，/home目录下的所有数据存储在sda5分区里，根目录 / (除了/boot、/home)下的数据都存储在sda2分区里。</p>
<blockquote>
<p>1.sda1表示第一块硬盘第一个分区，sda2表示第一块硬盘第二个分区，sdb1表示第二块硬盘一个分区，以此类推…<br>2.逻辑分区一定是从sda5开始，因为sda1、sda2、sda3和sda4文件名被主分区或扩展分区占用</p>
</blockquote>
<p>Linux系统安装时，一般分区如下：</p>
<ul>
<li>必须分区<ul>
<li>/ （根分区）</li>
<li>swap （交换分区）<ul>
<li>如果真实内存小于4GB, swap为内存的两倍</li>
<li>如果真实内存大于4GB, swap和内存一致</li>
<li>实验环境，不大于2GB即可</li>
</ul>
</li>
</ul>
</li>
<li>推荐分区<ul>
<li>/boot (启动分区，一般1GB，仅存放系统启动所需的数据)</li>
</ul>
</li>
<li>常用分区<ul>
<li>/home (用于文件服务器)</li>
<li>/www (用于web服务器)<blockquote>
<p>swap分区的文件系统类型式为swap，其余分区文件系统类型一般为ext4。一般系统安装存在 /、swap、/boot三个分区即可</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-挂载命令"><a href="#2-3-挂载命令" class="headerlink" title="2.3 挂载命令"></a>2.3 挂载命令</h3><ol>
<li><strong>mount</strong> 或 <strong>mount -l</strong><ul>
<li>查询系统中已挂载的设备，-l会显示卷标名称</li>
</ul>
</li>
<li><strong>mount -a</strong><ul>
<li>依据配置文件/etc/fstab的内容，自动挂载</li>
</ul>
</li>
<li><strong>mount [-t 文件系统类型] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</strong><ul>
<li>手动挂载</li>
<li>选项<ul>
<li>-t 文件系统：加入文件系统类型来指定挂载的类型，可以是ext3、ext4、iso9660等文件系统 </li>
<li>-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</li>
<li>-o 特殊选项: 可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。具体的特殊选项见下表</li>
</ul>
</li>
</ul>
</li>
<li><strong>umount 设备文件名</strong> 或 <strong>umount 挂载点</strong><ul>
<li>卸载已挂载设备</li>
<li>因为设备文件名和挂载点已经连接到一起，所以卸载哪一个都可以</li>
</ul>
</li>
</ol>
<blockquote>
<p>补充（挂载特殊选项参数说明）：<br>| 特殊选项 | 说明 |<br>| — | — |<br>|atime/noatime | 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新|<br>|async/sync | 异步/同步，默认为异步|<br>|auto/noauto | 自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动|<br>|defaults|定义默认值，相当于 rw,suid,dev,exec,auto,nouser,async这七个选项|<br>|exec/noexec | 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec允许|<br>|remount | 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限。示例：<code>mount -o remount,noexec /boot</code> 重新挂载/boot分区并使用noexec权限|<br>|rw/ro|读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw|<br>|suid/nosuid | 具有/不具有 SUID权限，设定文件系统是否具有 SUID和 SGID的权限，默认是具有|<br>|user/nouser | 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认不允许，只有root可以挂载分区|<br>|usrquota | 写入代表文件系统支持用户磁盘配额，默认不支持|<br>|grpquota | 写入代表文件系统支持组磁盘配额，默认不支持 |</p>
</blockquote>
<h3 id="2-4-LVM逻辑卷管理"><a href="#2-4-LVM逻辑卷管理" class="headerlink" title="2.4 LVM逻辑卷管理"></a>2.4 LVM逻辑卷管理</h3><h4 id="2-4-1-LVM简介"><a href="#2-4-1-LVM简介" class="headerlink" title="2.4.1 LVM简介"></a>2.4.1 LVM简介</h4><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。传统分区使用固定大小分区，重新调整大小十分麻烦。LVM将一个或多个硬盘的分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘的分区加入其中，这样可以实现磁盘空间的动态管理，相对于传统的磁盘分区有很大的灵活性。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/linux002.png?x-oss-process=style/watermarking" alt="LVM示意图"></p>
<ul>
<li>**物理卷(PV, Physical Volume)**：就是真正的物理硬盘或分区</li>
<li>**卷组(VG, Volume Group)**：将多个物理卷合起来就组成卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘的不同分区，可以把物理卷想象为一个逻辑硬盘。</li>
<li>**逻辑卷(LV, Logival Volume)**：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区我们称作逻辑卷，逻辑卷可以格式化和写入数据。</li>
</ul>
<h4 id="2-4-2-建立LVM步骤"><a href="#2-4-2-建立LVM步骤" class="headerlink" title="2.4.2 建立LVM步骤"></a>2.4.2 建立LVM步骤</h4><ol>
<li>使用<code>fdisk</code>交互命令把物理硬盘分成分区，当然也可以是整块硬盘。</li>
<li>把物理分区建立成为物理卷(PV)，也可以把整块硬盘都建立为物理卷。<ul>
<li>建立物理卷：<code>pvcreate [设备文件名]</code><ul>
<li>把整块硬盘都建立成物理卷，命令为<code>pvcreate /dev/sdb</code>，即第二块硬盘整个都建立成物理卷；把分区建立成物理卷，命令为<code>pvcreate /dev/sdb5</code>，即第二块硬盘第五个分区建立成物理卷</li>
</ul>
</li>
<li>查看物理卷：<code>pvscan</code> 或 <code>pvdisplay</code>(查看更加详细的物理卷状态)</li>
<li>删除物理卷：<code>pvremove [物理卷名(建立物理卷时的设备文件名)]</code></li>
</ul>
</li>
<li>把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。<ul>
<li>建立卷组：<code>vgcreate [选项] 卷组名 物理卷名(多个空格隔开)</code><ul>
<li>选项 ‘<code>-s PE大小</code>‘:指定PE(保存数据的最小单元)的大小，单位可以是MB、GB、TB等，如果不写默认PE大小是4MB。</li>
<li>示例：<code>vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</code>， 把物理卷/dev/sdb5、/dev/sdb6加入卷组scvg</li>
</ul>
</li>
<li>查看卷组：<code>vgscan</code> 或 <code>vgdisplay</code></li>
<li>扩充卷组容量：<code>vgextend 卷组名 物理卷名</code></li>
<li>减小卷组容量：<code>vgreduce 卷组名 物理卷名</code></li>
<li>删除卷组：<code>vgremove 卷组名</code><ul>
<li>卷组如果已经添加了逻辑卷，要先删除逻辑卷才能删除卷组，卷组删除后才能删除物理卷</li>
</ul>
</li>
</ul>
</li>
<li>把卷组再划分为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成分区，所以也需要格式化和挂载。</li>
</ol>
<ul>
<li>建立逻辑卷：<code>lvcreate [选项] [-n 逻辑卷名] 卷组名</code></li>
<li>选项<ul>
<li><code>-L 容量</code>：指定逻辑卷大小，单位MB、GB、TB</li>
<li><code>-l 个数</code>：按照PE个数指定逻辑卷大小，这个参数需要换算容量</li>
<li><code>-n 逻辑卷名</code>：指定逻辑卷名</li>
</ul>
</li>
<li>示例：<code>lvcreate -L 2GB -n userlv scvg</code>，在卷组scvg中建立一个容量2GB名称为userlv的逻辑卷</li>
<li>建立完逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。格式化和挂载命令和操作普通分区时一样，不过需要注意的是逻辑卷的设备文件名是“**/dev/卷组名/逻辑卷名**”，比如示例这里建立的逻辑卷设备文件名是<code>/dev/scvg/userlv</code><ul>
<li>格式化逻辑卷：<code>mkfs -t ext4 /dev/scvg/userlv</code></li>
<li>创建挂载目录：<code>mkdir /disklvm</code></li>
<li>挂载逻辑卷：<code>mount /dev/scvg/userlv /disklvm/</code></li>
</ul>
</li>
</ul>
<h2 id="3-目录结及说明"><a href="#3-目录结及说明" class="headerlink" title="3.目录结及说明"></a>3.目录结及说明</h2><p>Linux目录结构及说明如下</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>bin是Binary的缩写, 这个目录存放着最经常使用的命令</td>
</tr>
<tr>
<td>/sbin/</td>
<td>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>系统用户使用的应用程序</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>超级用户使用的比较高级的管理程序和系统守护程序</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存于系统启动相关的文件，如内核文件和启动引导程序（grup）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td>
</tr>
<tr>
<td>/lib/</td>
<td>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</td>
</tr>
<tr>
<td>/lib64/</td>
<td>64位函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期Linux只有这一个挂载目录，并没有细分，现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘等。虽然有三个默认的挂载目录/media/、/misc/、/mnt/，但是到底使用哪个目录挂载什么设备都可以由管理员自己决定。一般习惯挂载目录只用一个/mnt/, 在/mnt/目录下建立不同的目录挂载不同的设备，如/mnt/cdrom挂载光盘、/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。一般习惯把软件放到/usr/local/目录中，也就是说/usr/local/目录也可以用来安装软件</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。改目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net 是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/root/</td>
<td>root用户的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在 / 下</td>
</tr>
<tr>
<td>/run/</td>
<td>系统运行时产生的数据，如ssid, pid等相关数据。</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放历史文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录不要保存重要数据，最好每次开机把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是”UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。手工下载的源码包和内核源码包都可以保存到这里。一般习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中</td>
</tr>
<tr>
<td>/usr/src/kernels/</td>
<td>内核源码保存位置</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。只要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
<tr>
<td>/var/www/html/</td>
<td>RPM包安装Apache的网页主目录</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用和改变的数据保存位置。如mysql的数据库保存在/var/lib/mysql/目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>系统日志保存位置</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的PID(进程ID)保存位置。是/run/目录的软链接</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列</td>
</tr>
<tr>
<td>/var/spool/mail/</td>
<td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>系统的定时任务队列保存位置。系统的计划任务会保存在这里</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分区</tag>
        <tag>挂载</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL报only_full_group_by错误</title>
    <url>/20190824/informal001/5ed6d48e6e64.html</url>
    <content><![CDATA[<p>之前执行正常的一条分组sql语句，今天在本地执行时突然报错了，报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column list which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>网上搜索了一番很快就找到了答案，就顺便做一下记录。原来是和 mysql 的版本有关，mysql 5.7 或以上版本 的 <code>sql_mode</code> 默认包含 “<code>ONLY_FULL_GROUP_BY</code>“ 选项，通过执行 “<code>SELECT @@sql_mode</code>“ 输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure>

<p><code>ONLY_FULL_GROUP_BY</code>模式意味着使用 <code>GROUP BY</code> 分组查询时，<code>SELECT</code> 查询的字段列表必须是<strong>分组字段</strong>或者<strong>使用了聚合函数的非分组字段</strong>。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 报错</span><br><span class="line">select name, age from e group by name;</span><br><span class="line"># 不报错</span><br><span class="line">select name, max(age) from e group by name;</span><br></pre></td></tr></table></figure>



<p><strong>那么如何解决这个问题，使之前分组 sql 不报错呢</strong>？ </p>
<ol>
<li><p>第一种方式，关闭 “<code>ONLY_FULL_GROUP_BY</code>“ 模式。</p>
<p>先把  “<code>SELECT @@sql_mode</code>“ 的查询结果copy出来，删除其中的”<code>ONLY_FULL_GROUP_BY</code>“，然在执行 “<code>SET @@sql_mode=&#39;...&#39;</code>“，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@sql_mode &#x3D; &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;</span><br></pre></td></tr></table></figure>

<p>设置之后，再执行之前的分组sql就不会报错了。但是，这样设置只对当前会话生效，只是临时的，要想永久生效，只能修改mysql配置文件，在<code>[mysqld]</code> 下修改 <code>sql_mode</code>。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql_mode &#x3D; STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure>

<p>然后重启mysql服务。</p>
</li>
</ol>
<ol start="2">
<li><p>第二种方式，使用 <code>any_value()</code> 函数查询非分组字段。</p>
<p><strong>any_value() 函数的作用是，选择同一组数据里的第一条数据的指定列值作为返回数据</strong>，这样即使开启了<code>ONLY_FULL_GROUP_BY</code> 模式也能达到 mysql5.7 版本之前的分组查询效果了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name, any_value(age) from e group by name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果项目已经运行了很长时间且代码里已经使用了很多的 <code>GROUP BY</code> 语句，那么修改的地方就非常多了，对于这种情况这种方式一般就不太适合了</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件之ActiveMQ入门</title>
    <url>/20190816/post/191434a07b67.html</url>
    <content><![CDATA[<h1 id="1-JMS与消息中间件"><a href="#1-JMS与消息中间件" class="headerlink" title="1. JMS与消息中间件"></a>1. JMS与消息中间件</h1><h2 id="1-1-jms介绍"><a href="#1-1-jms介绍" class="headerlink" title="1.1 jms介绍"></a>1.1 jms介绍</h2><p>jms是java消息服务接口规范，主要包含四大元素：<strong>生产者</strong>、<strong>消费者</strong>、<strong>消息</strong>、<strong>消息服务</strong>。  </p>
<ul>
<li><p>生产者：创建消息，并把消息发动到消息服务；  </p>
</li>
<li><p>消费者：从消息服务接收消息；</p>
</li>
<li><p>消息服务：即MQ消息服务（broker），而生产者与消费者相对其均为客服端；</p>
</li>
<li><p>消息：整个消息服务的传输对象，消息包含消息头、消息属性、消息体；</p>
<a id="more"></a>

</li>
</ul>
<blockquote>
<p><strong>常用消息头属性</strong>：JMSDestination(消息目的地，如果生产者指定了目的地，在发送时会改为生产者绑定的目的地)、JMSDeliveryMode(是持久还是非持久)、JMSExpiration(过期时间，默认永久)、JMSPriority(优先级，0-9，数值越大优先级越高，默认为4)、JMSMessageId(唯一的消息ID)；<br><strong>消息属性</strong>：可视为消息头属性的扩展，通过setXxxProperty(k,v)设置；<br><strong>消息体</strong>：封装消息的具体数据，发送与接收的消息体类型必须一致，消息体类型总共有5种，TextMessage、Mapmessage、BytesMessage、StreamMessage、ObjectMessage；</p>
</blockquote>
<h2 id="1-2-jms消息传递模式"><a href="#1-2-jms消息传递模式" class="headerlink" title="1.2 jms消息传递模式"></a>1.2 jms消息传递模式</h2><p>jms消息传递模式有如下两种，<br><strong>点对点消息传递模式（P2P）</strong>：消息发送到一个特殊队列(queue), 消费者从队列获取消息，一条消息只能被只能被一个消费者消费；<br>**发布/订阅消息传递模式(publish-subscribe)**：消息被发送到一个主题上(topic)，所有订阅了该主题的消费者，都能接收到消息。</p>
<h2 id="1-3-jms编码总体架构"><a href="#1-3-jms编码总体架构" class="headerlink" title="1.3 jms编码总体架构"></a>1.3 jms编码总体架构</h2><p>JMS应用程序由如下基本模块组成，</p>
<ol>
<li>连接工厂对象，创建消息客户端(生产者、消费者)与消息服务端的连接(connection)；</li>
<li>连接对象，创建回话对象(session);</li>
<li>会话对象，创建生产者对象(producer)、消费者对象(consumer)以及消息对象(message)；</li>
<li>目的地(queue/topic)，点对点模式下目的地是队列(queue)，发布/订阅模式下目的地是主题(topic)，生产者把消息发送到目的地，消费者从目的地接收消息</li>
</ol>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq1.png?x-oss-process=style/watermarking"></p>
<h2 id="1-4-消息中间件"><a href="#1-4-消息中间件" class="headerlink" title="1.4 消息中间件"></a>1.4 消息中间件</h2><p>  消息中间件是实现了jms规范的落地产品，目前市场上主流的消息中间件有 ActiveMQ、Kafka、RocketMQ、RabbitMQ等。企业开发中使用消息中间件的主要目的是<strong>解决耦合调用</strong>、**抵御洪峰流量(削峰)**等。 以下主要讲解ActiveMQ的使用。</p>
<h1 id="2-ActiveMQ安装并启动"><a href="#2-ActiveMQ安装并启动" class="headerlink" title="2. ActiveMQ安装并启动"></a>2. ActiveMQ安装并启动</h1><p>具体安装步骤这里不再详述，可参考官网[<a href="http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行">http://activemq.apache.org][2]。安装成功后，进入安装目录，在bin目录下执行</a> <code>./activemq start</code>命令，即可启动MQ服务，如果启动服务需要指定配置文件，命令为 <code>./activemq start xbean:file:../conf/myConfig.xml</code>，不指定默认为conf目录下的activemq.xml。停止MQ服务的命令为 <code>./activemq stop</code>。</p>
<p>在conf目录下找到<code>activemq.xml</code>配置文件打开，里面包含如下内容,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里配置的是MQ服务的各种传输协议连接和默认端口。再往下会发现这行内容<code>&lt;import resource=&quot;jetty.xml&quot;/&gt;</code>，activemq.xml文件中导入了一个名为<code>jetty.xml</code>的配置文件，在conf目录下找到jetty.xml文件打开，里面配置了访问MQ服务web控制台的一些信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jettyPort&quot; class&#x3D;&quot;org.apache.activemq.web.WebConsolePort&quot; init-method&#x3D;&quot;start&quot;&gt;</span><br><span class="line">    &lt;!-- the default port number for the web console --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;0.0.0.0&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;8161&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>其中8161为web控制台端口，MQ服务启动后，浏览器中访问[<a href="http://localhost:8161/admin][3]%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%83%BD%E4%B8%BAadmin%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C">http://localhost:8161/admin][3]，输入用户名和密码，默认都为admin，即可看到如下页面，</a></p>
<p><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq2.png?x-oss-process=style/watermarking"></p>
<h1 id="3-编码实战"><a href="#3-编码实战" class="headerlink" title="3. 编码实战"></a>3. 编码实战</h1><p>ActiveMQ服务启动成功后，可以编写生产者客户端往MQ服务发送消息，消费者客户端从MQ服务获取消息。项目建好之后需要先引入ActiveMQ相关依赖，以gradle为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &#39;org.apache.activemq&#39;, name: &#39;activemq-all&#39;, version: &#39;5.15.9&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-点对点消息"><a href="#3-1-点对点消息" class="headerlink" title="3.1 点对点消息"></a>3.1 点对点消息</h2><h3 id="3-1-1-生产者"><a href="#3-1-1-生产者" class="headerlink" title="3.1.1 生产者"></a>3.1.1 生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂。这里传入ActiveMQ消息服务连接地址，并使用默认用户名和密码。</span></span><br><span class="line">        <span class="comment">// 也可使用ActiveMQConnectionFactory()构造器或者ActiveMQConnectionFactory(String userName, String password, String brokerURL)构造器，连接接信息全部使用默认值或者全部指定</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        <span class="comment">//2、通过工厂对象创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">//3、通过连接对象创建会话。第一个参数是否开启事务，第二参数指定签收类型</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4、通过会话对象创建目的地（队列或者主题）。这里创建了一个名为 &quot;queue001&quot; 的队列</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        <span class="comment">//5、通过会话对象创建生产者，并指定目的地</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line">        <span class="comment">//6、连续创建3条消息，并有生产者发送到消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">            System.out.println(textMessage.getJMSDestination());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息&quot;</span> + textMessage.getText() + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main()方法后，进入web控制台可以看到待消费消息有3条，入队消息有3条，说明消息已经成功发送至MQ服务器。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq3.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-2-消费者"><a href="#3-1-2-消费者" class="headerlink" title="3.1.2 消费者"></a>3.1.2 消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line">        connection.start();</span><br><span class="line">        Message message = consumer.receive();</span><br><span class="line">        <span class="keyword">while</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String text = ((TextMessage) message).getText();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            message = consumer.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者客户端编码过程与生产者基本一致，只不过一个是生产者发送调用<code>send()</code>方法，一个是消费者接收调用<code>receive()</code>方法。其中需要注意的是<code>receive()</code>方法是一个阻塞方法，接收不到消息会一直阻塞等待，并且调用<code>receive()</code>之前必须调用<code>connection.start()</code>启动连接，否者接收不到消息。<br>执行main()方法后，进入web控制台可以看到待消费消息变为0条，出队消息变为3条，并且有一个消费者，说明消息被消费成功。<br><img src="https://taicw-blog.oss-cn-beijing.aliyuncs.com/202001/acticeMq4.png?x-oss-process=style/watermarking"></p>
<h3 id="3-1-3-消息监听器实现异步非阻塞消费消息"><a href="#3-1-3-消息监听器实现异步非阻塞消费消息" class="headerlink" title="3.1.3 消息监听器实现异步非阻塞消费消息"></a>3.1.3 消息监听器实现异步非阻塞消费消息</h3><p>上面我们了解到<code>MessageConsumer#receive()</code>方法是个阻塞方法，实际开发中不可能一直去阻塞等待，可以为消费者对象设置消息监听器来实现异步非阻塞消费消息，修改消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by taichangwei on 2019/6/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, InterruptedException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在调用receive()方法之前必须要调用start()方法启动连接，否者receive()接收不到消息会被一直阻塞</span></span><br><span class="line"><span class="comment">//        connection.start();</span></span><br><span class="line"><span class="comment">//        Message message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        while (message != null) &#123;</span></span><br><span class="line"><span class="comment">//            String text = ((TextMessage) message).getText();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;接收queue消息：&quot; + text);</span></span><br><span class="line"><span class="comment">//            message = consumer.receive();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line">        consumer.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String text = ((TextMessage) message).getText();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收queue消息：&quot;</span> + text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep为了使程序不退出</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        consumer.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMessageListener()</code>方法需要传入一个<code>MessageListener</code>实例对象，并实现<code>onMessage()</code>，这里使用的是lambda表达式。</p>
<h2 id="3-2-发布-订阅消息"><a href="#3-2-发布-订阅消息" class="headerlink" title="3.2 发布/订阅消息"></a>3.2 发布/订阅消息</h2><p>发布订阅消息与上面点对点消息的生产者与消费者编码一致，唯一要改变的是把消息目的地由queue改为topic。</p>
<ul>
<li>生产者<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME); </span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure></li>
<li>消费者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...省略... </span><br><span class="line">Topic topic &#x3D; session.createTopic(TOPIC_NAME);</span><br><span class="line">MessageConsumer consumer &#x3D; session.createConsumer(topic);</span><br><span class="line">...省略... </span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>1.在点对点消息示例中，当同时启动多个消费者时(即同时执行多次main()方法)，生产者发布的每条消息只能被其中一个消费者消费一次；<br>2.在发布/订阅消息示例中，消费者不能消费订阅主题之前的消息，当同时启动多个消费者时，生产者发布的每条消息可以同时被多个消费者消费；</p>
</blockquote>
<h1 id="4-传输协议"><a href="#4-传输协议" class="headerlink" title="4. 传输协议"></a>4. 传输协议</h1><h2 id="4-1-ActiveMQ默认支持的传输协议"><a href="#4-1-ActiveMQ默认支持的传输协议" class="headerlink" title="4.1 ActiveMQ默认支持的传输协议"></a>4.1 ActiveMQ默认支持的传输协议</h2><p>ActiveMQ出厂默认支持的传输协议有<code>tcp</code>、<code>amqp</code>、<code>stomp</code>、<code>mqtt</code>、<code>ws</code>，在<code>activemq.xml</code>配置文件可以找到这几种协议的配置，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于java开发后四种协议不经常使用，这里主要说一次tcp协议。tcp协议的client监听端口默认是61616，在网络上传输数据，必须序列化数据，消息是通过一个write protocol来序列化为字节流。默认情况 ActiveMQ会把wire protocol叫做Open Wire，它的目的是促使网络上的效率和数据快速交互。<br>tcp传输的优点：</p>
<ol>
<li>传输可靠性高、稳定性强</li>
<li>高效性：字节流方式传递，效率高</li>
<li>有效性、可用性：应用广泛，支持任何平台<br>tcp连接的URL形式如：<strong>tcp://hostname:port?key=value</strong>。更多协议的可配置参数请参考 <a href="http://activemq.apache.org/tcp-transport-reference">http://activemq.apache.org/tcp-transport-reference</a></li>
</ol>
<h2 id="4-2-使用NIO传输协议提供更好的性能"><a href="#4-2-使用NIO传输协议提供更好的性能" class="headerlink" title="4.2 使用NIO传输协议提供更好的性能"></a>4.2 使用NIO传输协议提供更好的性能</h2><p>使用tcp协议，每一个连接都会创建一个线程，当client连接较多时需要大量的系统开销，nio支持多个连接使用同一个线程，相比tcp需要更少的线程数。  </p>
<p>nio协议基于tcp协议之上进行了扩展和优化。要使ActiveMQ支持nio协议，只需要做少量的修改即可。打开<code>activemq.xml</code>配置文件，在<code>&lt;transportConnectors&gt;</code> 节点内添加，<code>&lt;transportConnector name=&quot;nio&quot; uri=&quot;nio://0.0.0.0:61617&quot;/&gt;</code>，同时客户端代码url连接形式要改为 <code>nio://hostname:port?key=value</code>，后面的可选参数与tcp协议一致。  </p>
<blockquote>
<p>tcp协议也好nio协议也好，都绑定了特定的端口，如何实现一个端口可以支持多种协议呢？ActiveMQ提供了一个auto协议，类似于一个适配器协议，在不改变端口的情况下可以切换协议。详细配置参考官方文档 <a href="http://activemq.apache.org/auto">http://activemq.apache.org/auto</a>  </p>
</blockquote>
<p>其他协议配置参见官网文档 <a href="http://activemq.apache.org/configuring-transports.html">http://activemq.apache.org/configuring-transports.html</a></p>
<h1 id="5-ActiveMQ消息高可用"><a href="#5-ActiveMQ消息高可用" class="headerlink" title="5 ActiveMQ消息高可用"></a>5 ActiveMQ消息高可用</h1><h2 id="5-1-消息持久化"><a href="#5-1-消息持久化" class="headerlink" title="5.1 消息持久化"></a>5.1 消息持久化</h2><h3 id="5-1-1-持久化编码"><a href="#5-1-1-持久化编码" class="headerlink" title="5.1.1 持久化编码"></a>5.1.1 持久化编码</h3><p>如果生产者把消息发送到了MQ消息服务，消费者还没有来得及消费，此时MQ服务停止或意外宕机，那么这些未被消费的消息改怎么处理呢？分为消息非持久化和消息持久化两种情况，<strong>消息非持久化</strong>这些未被处理的消息直接丢失，<strong>消息持久化</strong>会把这些未被消费的消息暂时存储起来，当MQ消息服务重新启动时恢复这些消息，消费者可以继续消费。</p>
<ul>
<li><strong>队列消息持久化</strong><br>基于上面的示例代码，只需要为生产者客户端代码添加一行通过MessageProducer对象设置就可以了。（队列消息默认开启持久化这一行实际上可以省略）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></li>
<li><strong>主题消息持久化</strong><br>主题消息默认不持久化，支持主题消息持久化，只需要修改消费者客户端代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> ...</span><br><span class="line">connection.setClientID(<span class="string">&quot;client_0001&quot;</span>);</span><br><span class="line"> ...</span><br><span class="line">Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">TopicSubscriber subscriber =  session.createDurableSubscriber(topic, <span class="string">&quot;remark...&quot;</span>);</span><br><span class="line">connection.start();</span><br><span class="line">subscriber.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先必须要通过<code>connection.setClientID(&quot;client_0001&quot;)</code>指定订阅者ID，因为如果不指定唯一ID,订阅者（非持久化订阅者）每次连接时都会随机创建一个ID，在消息持久化状态下，订阅者需要保证从离线到重新在线ClientID唯一不变，这样MQ消息服务才能确定主题消息是否被所有持久化订阅者消费了（如果MQ服务停止或宕机时，主题消息未被所有持久化订阅者消费的会被存储起来，已经被所有持久化订阅者消费的主题消息会直接丢弃）。  </p>
<p>然后通过<code>session.createDurableSubscriber(topic, &quot;remark...&quot;)</code>创建一个TopicSubscriber对象，告诉MQ服务其订阅的此主题消息要做持久化处理。</p>
<h3 id="5-1-2-持久化存储机制"><a href="#5-1-2-持久化存储机制" class="headerlink" title="5.1.2 持久化存储机制"></a>5.1.2 持久化存储机制</h3><p>ActiveMQ的消息持久化机制有JDBC、AMQ、KahaDB和LevelDB，无论使用哪种持久化方式，消息的存储逻辑都是一致的，就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等再试图将消息发送给接受者，成功则将消息从存储中删除，失败则继续尝试发送。MQ消息服务启动以后首先要检查指定的存储位置，如果有未发送成功的消息则需要把消息继续发送出去。下面分别介绍一下KahaDB与JDBC持久化机制。</p>
<ul>
<li><strong>KahaDB存储</strong><br>KahaDB是一个基于文件的持久性数据库，消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。KahaDB是目前默认的存储方式，可用于任何场景，提高了性能和恢复能力。在<code>activemq.xml</code>配置文件可查看其配置信息，更多的配置信息可参见官网 <a href="http://activemq.apache.org/kahadb">http://activemq.apache.org/kahadb</a></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>directory</code>这里指明了kahadb数据存储路径，默认为ActiveMQ安装目录下<code>/data/kahadb</code>，其中主要包含4类文件和一个lock：</p>
<ol>
<li><strong>db-<number>.log</strong>：kahaDB存储消息到预定大小（默认32M）的数据记录文件中，文件命名为db-<number>.log，当数据文件已满时，一个新的文件会随之创建，number数值也会随之递增，当不再有引用到数据文件中的消息时，文件会被删除或者归档；</li>
<li><strong>db.data</strong>：改文件包含了持久化的BTree索引，它是消息的索引文件，使用BTree作为索引指向db-<nubmer>.log里面存储的消息；</li>
<li><strong>db.free</strong>：记录当前db.data文件里哪些页面是空闲的，文件具体内容是所有空闲页的ID;</li>
<li><strong>db.redo</strong>：用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引；</li>
<li><strong>lock</strong>：文件锁，表示当前获得kahaDB读写权限的broker；  </li>
</ol>
<ul>
<li><strong>JDBC存储</strong><br>如果采用JDBC机制存储，需要准备一个第三方数据库，这里以MySql数据库为例，更多信息参考<a href="http://activemq.apache.org/jdbc-support">http://activemq.apache.org/jdbc-support</a></li>
</ul>
<p>1.首先将mysql数据库的驱动包<code>mysql-connector-java-5.1.41.jar</code>添加到<code>ActiveMQ安装目录/lib</code>目录下，用于连接mysql数据库；</p>
<p>2.打开<code>activemq.xml</code>配置文件，找到<code>&lt;beans&gt;</code>节点添加数据库连接池配置信息<code>dataSource</code> bean，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysql-ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>3.<code>activemq.xml</code>配置文件中找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span> <span class="attr">createTablesOnStartup</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>mysql-ds</code>为上一步配置的beanId，<code>createTablesOnStartup</code>是否在启动的时候自动创建数据表，默认值是true，一般是第一次启动的时候设置为true之后再改为false。</p>
<p>上诉三步都配置完后，启动ActiveMQ服务会自动创建三张表，分别为<code>activemq_msgs</code>消息表，用于保存queue和topic消息， <code>activemq_acks</code>用于存储订阅关系，如果是持久化topic，订阅者和服务器的订阅关系在这个表保存，<code>activemq_lock</code>在集群环境中才有用，保证只有一个borker可以获取消息，用于记录哪个breker是当前的master broker。</p>
<p>JDBC每次消息过来都需要去写库和读库，ActiveMQ Journal使用高速缓存写入技术大大提高了性能，克服了JDBC Store的不足。当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息，比如生产者生产了1000条消息，这1000条消息会先保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的消息，那么这个时候只需要同步剩余的10%的消息到DB。</p>
<p>使用高效的Journal，需要修改持久化配置，打开<code>activemq.xml</code>配置文件，找到<code>&lt;persistenceAdapter&gt;</code>节点，修改为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">journalPersistenceAdapterFactory</span> <span class="attr">journalLogFiles</span>=<span class="string">&quot;5&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;activemq-data&quot;</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceFactory</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h2 id="5-2-事务"><a href="#5-2-事务" class="headerlink" title="5.2 事务"></a>5.2 事务</h2><p>在上面的示例代码中，创建session时传了两个参数，<code>createSession(false, Session.AUTO_ACKNOWLEDGE)</code>，第一个参数表示<strong>是否开启事务</strong>，第二个参数表示<strong>签收方式</strong>。</p>
<p>当开启事务，即第一个参数为<code>true</code>时，对于生产者而言执行<code>send()</code>方法后，消息不会直接进入消息队列中（没有真正发送到MQ服务），只有执行<code>session.commit()</code>消息才会真正发送成功进入消息队列中；对于消费者而言，消费完消息后，只有执行了<code>session.commit()</code>消息才会从消息队列中出队，如果不执行<code>session.commit()</code>会导致消息被重复消费。</p>
<p>事务开启的意义在于，对于多条必须同批次传输的消息，如果有一条传输失败，可以将事务回滚，再次传输，保证数据的完整性。</p>
<h2 id="5-3-签收（ack）"><a href="#5-3-签收（ack）" class="headerlink" title="5.3 签收（ack）"></a>5.3 签收（ack）</h2><p>签收和事务起到的作用是一样的，事务的优先级高于签收，即如果开启了事务，签收方式不管是哪种都是不起作用的，一般事务倾向于生产者使用，签收倾向于消费者使用。</p>
<p>签收方式总共有4种，<code>AUTO_ACKNOWLEDGE</code>自动签收，<code>CLIENT_ACKNOWLEDGE</code>手动签收，<code>DUPS_OK_ACKNOWLEDGE</code>可重复的签收（不常用），<code>SESSION_TRANSACTED</code>一般表示开启了事务设置任何签收方式是无效的。</p>
<p>如果签收方式为<code>CLIENT_ACKNOWLEDGE</code>手动签收，必须执行<code>message.acknowledge()</code>，消息才能被真正的消费或者发送。</p>
<h1 id="6-高级特性"><a href="#6-高级特性" class="headerlink" title="6 高级特性"></a>6 高级特性</h1><h2 id="6-1-异步投递"><a href="#6-1-异步投递" class="headerlink" title="6.1 异步投递"></a>6.1 异步投递</h2><p>ActiveMQ支持以同步或异步模式向borker发送消息，所使用的模式对发送调用的延迟有很大的影响。由于延迟通常是生产者可以实现的吞吐量中的一个重要因素，因此使用异步发送可以显著提高系统的性能。</p>
<p>ActiveMQ默认以异步模式发送消息，以同步模式发送的情况是除非明确指定使用同步发送或者<strong>事务外部发送持久消息</strong>（即未使用事务的前提下发送持久化消息）。如果不使用事务，而是发送持久消息，那么每次发送都会同步并阻塞，直到broker向生产者发送确认消息已安全持久存储到磁盘为止，此确认机制提供了消息不会丢失的保证，但由于客户端被阻塞需要付出巨大的延迟代价。</p>
<p>异步投递可以最大化producer端的发送效率。通常在发送消息量比较密集的情况下使用异步发送，它可以很大的提升producer的吞吐量，不过这也带来了额外的问题，就是需要消耗很多的client端内存的同时也会导致broker端性能消耗增加，此外<strong>不能有效的确保消失的发送成功</strong>。在使用异步投递的情况下客户端需要容忍消息丢失的可能。</p>
<ul>
<li><p><strong>开启异步投递的三种方式</strong></p>
<ol>
<li><p>通过Connection URI后面添加参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://locahost:61616?jms.useAsyncSend=true&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ConnectionFactory对象属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory)connectionFactory).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Connection对象属性，在此级别配置将覆盖ConnectionFactory级别的设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>如何保证一部投递情况下消息不丢失</strong></p>
<p>异步发送消息丢失的情况场景是，UseAsyncSend为true，使用<code>producer.send(message)</code>持续发送消息，消息不会阻塞，生产者会认为所有的消息均会被发送到了MQ服务，如果MQ服务突然宕机，此时生产者端尚未同步到MQ服务的消息均会丢失。所以，正确的异步发送方法需要接收回调的。</p>
<p>同步发送和异步发送的区别就在于，同步发送<code>send()</code>不阻塞就代表消息发送成功，异步发送需要接收回调并由客户端再判断一次是否发送。异步投递编码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//producer.send(textMessage);</span></span><br><span class="line">            <span class="comment">//异步投递并确认消息发送结果</span></span><br><span class="line">            textMessage.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line">            String msgId = textMessage.getJMSMessageID();</span><br><span class="line">            ((ActiveMQMessageProducer) producer).send(textMessage, <span class="keyword">new</span> AsyncCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span> </span>&#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + msgId + <span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">                    <span class="comment">// 对于失败消息后续可以进行重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="6-2-定时与延时投递"><a href="#6-2-定时与延时投递" class="headerlink" title="6.2 定时与延时投递"></a>6.2 定时与延时投递</h2><p>有时候我们需要消息在某个时间点发送或者延迟一段时间发送。</p>
<p>ActiveMQ开启定时与延迟投递，首先编辑<code>activemq.xml</code>配置文件，<code>&lt;broker&gt;</code>标签内添加属性<code>schedulerSupport</code>并且设置为<code>true</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> <span class="attr">brokerName</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;$&#123;activemq.data&#125;&quot;</span> <span class="attr">schedulerSupport</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码中生产者端消息对象<code>message</code>，需要设置时间调度相关属性，主要属性如下：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AMQ_SCHEDULED_DELAY</td>
<td>long</td>
<td>延迟投递时间</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_PERIOD</td>
<td>long</td>
<td>重复投递时间间隔</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_REPEAT</td>
<td>int</td>
<td>重复投递次数</td>
</tr>
<tr>
<td>AMQ_SCHEDULED_CRON</td>
<td>String</td>
<td>cron表达式</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;队列消息：message&quot;</span> + i);</span><br><span class="line">            <span class="comment">//消息延迟3秒，每隔4秒重复发送，重复5次</span></span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, <span class="number">3000L</span>);</span><br><span class="line">            textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, <span class="number">4000L</span>);</span><br><span class="line">            textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, <span class="number">5</span>); <span class="comment">//（加上第一次实际上总共6次）</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>更多介绍参考官网 <a href="http://activemq.apache.org/delay-and-schedule-message-delivery">http://activemq.apache.org/delay-and-schedule-message-delivery</a></p>
<h2 id="6-3-消费者消息重试策略"><a href="#6-3-消费者消息重试策略" class="headerlink" title="6.3 消费者消息重试策略"></a>6.3 消费者消息重试策略</h2><p>当下列任何一种情况发生时，borker会将消息重新传送至消费端:</p>
<ul>
<li>使用事务会话并调用<code>rollback()</code>；</li>
<li>使用事务会话调用<code>commit()</code>之前关闭已处理的会话；</li>
<li>在手动签收<code>CLIENT_ACKNOWLEDGE</code>传递模式下调用<code>session.recover()</code>；</li>
<li>客户机连接超时(可能正在执行的代码比配置的超时时间更长)。</li>
</ul>
<p>默认重发时间间隔为1秒总共重发6次，超过6次即最大重发次数后，消费端会给broker返送一个<code>poison ack</code>表示这个消息有毒，告诉broker不要再发了，这个时候broker会把这个消息放到DLQ（死信队列），以便稍后对其进行分析并人工干预处理。</p>
<p>定义重发策略，编码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        ActiveMQConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(BROKER_URL);</span><br><span class="line">        RedeliveryPolicy policy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        policy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        policy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        policy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        policy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        connectionFactory.setRedeliveryPolicy(policy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从ActiveMQ v5.7.0开始，可以在每个目的地的基础上配置RedeliveryPolicy,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        Session session = connection.createSession(<span class="keyword">true</span>, Session.CLIENT_ACKNOWLEDGE);</span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME);</span><br><span class="line">        </span><br><span class="line">        RedeliveryPolicy queuePolicy = <span class="keyword">new</span> RedeliveryPolicy();</span><br><span class="line">        queuePolicy.setInitialRedeliveryDelay(<span class="number">0</span>);</span><br><span class="line">        queuePolicy.setRedeliveryDelay(<span class="number">1000</span>);</span><br><span class="line">        queuePolicy.setUseExponentialBackOff(<span class="keyword">false</span>);</span><br><span class="line">        queuePolicy.setMaximumRedeliveries(<span class="number">2</span>);</span><br><span class="line">        RedeliveryPolicyMap redeliveryPolicyMap =((ActiveMQConnection)connection).getRedeliveryPolicyMap();</span><br><span class="line">        redeliveryPolicyMap.put((ActiveMQQueue)queue, queuePolicy);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>常用重发策略配置如下：<br>|属性名称   |默认值   |描述   |<br>| ———— | ———— | ———— |<br>|collisionAvoidanceFactor|    0.15|设置防止冲突范围的正负百分比，只有启用useCollisionAvoidance参数时才生效。也就是在延迟时间上再加一个时间波动范围|<br>|initialRedeliveryDelay|    1000L|    初始重发延迟时间|<br>|maximumRedeliveries|    6|最大重发次数，达到最大重发次数后消息进入死信队列。为-1时不限制次数，为0时表示不进行重发|<br>|maximumRedeliveryDelay|    -1|    最大重发延迟时间，只有useExponentialBackOff为true时有效（v5.5）。假设首次重发间隔为10ms，倍数为2，那么第二次重发时间间隔为20ms，第三次时间间隔为40ms，当重发时间间隔的达到最大传送延迟时间，以后每次重发时间间隔都为最大传送延迟时间。为-1时不限制最大时间间隔|<br>|redeliveryDelay|    1000L | 重发延迟时间，当initialRedeliveryDelay=0生效|<br>|useCollisionAvoidance|    false|启用防止冲突功能|<br>|useExponentialBackOff|    false|启用指数倍数递增的方式增加延迟时间|<br>|backOffMultiplier|    5|重发时间间隔递增倍数，只有值大于1和启用useExponentialBackOff参数时才生效|<br>更多重发介绍参考官网 <a href="http://activemq.apache.org/redelivery-policy">http://activemq.apache.org/redelivery-policy</a></p>
<p>ActiveMQ中的默认死信队列名称为<code>ActiveMQ.DLQ</code>，所有无法交付的消息都将被发送到这个队列，这可能很难管理，因此，你也可以在<code>activemq.xml</code>配置文件为每个目的地配置单独的死信队列，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单独为每个queue目的地设置一个死信队列，前缀为DLQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Set the following policy on all queues using the &#x27;&gt;&#x27; wildcard --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Use the prefix &#x27;DLQ.&#x27; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">&quot;DLQ.&quot;</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>死信队列详细介绍参考官网 <a href="http://activemq.apache.org/message-redelivery-and-dlq-handling">http://activemq.apache.org/message-redelivery-and-dlq-handling</a></p>
<h1 id="7-内嵌broker"><a href="#7-内嵌broker" class="headerlink" title="7 内嵌broker"></a>7 内嵌broker</h1><p>使用spring boot开发web应用的时候，spring boot提供了内嵌的tomcat或者jetty服务器，使用内嵌服务器运行项目时就不用再单独启动一个servlet服务器了，类似的ActiveMQ也提供了一个内嵌broker，使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code.activemq.start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.broker.BrokerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbedBroker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">        brokerService.setUseJmx(<span class="keyword">true</span>);</span><br><span class="line">        brokerService.addConnector(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        brokerService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细介绍参考官网 <a href="https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html">https://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html</a></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（二）——方法引用</title>
    <url>/20190202/lambda2/076a298db052.html</url>
    <content><![CDATA[<p>当我们在使用lambda去表示某个函数式接口的实例时，需要在lambda表达式的主体里去编写函数式接口抽象方法的实现，如果在现有的类中已经存在与抽象方法类似的方法了，我们希望直接引用现有的方法，而不用再去重新写实现了。方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。</p>
<p>方法引用和lambda表达式拥有相同的特性，它们都需要代表一个<strong>目标类型</strong>，并需要被转化为函数式接口的实例，不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法方。<strong>法引用要使用到操作符 “::”，左边是类名或者对象名，右边是方法名或者关键字<code>new</code></strong></p>
<p>首先被引用方法的返回值类型要和函数式接口抽象方法的返回值类型一致，至于参数列表要根据每种引用方式而定。</p>
<a id="more"></a>

<h1 id="1-静态方法引用"><a href="#1-静态方法引用" class="headerlink" title="1. 静态方法引用"></a>1. 静态方法引用</h1><p>语法：<code>ClassName::staticMethodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = x -&gt; Long.valueOf(x);</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Long&gt; f = Long::valueOf;</span><br><span class="line">Long result = f.apply(<span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>静态方法引用时，静态方法要与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="2-对象方法引用"><a href="#2-对象方法引用" class="headerlink" title="2. 对象方法引用"></a>2. 对象方法引用</h1><p>语法：<code>ClassName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = (s) -&gt; s.length();</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; bpredicate = String::equals;</span><br><span class="line"><span class="keyword">boolean</span> result = bpredicate.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ToIntFunction&lt;String&gt; f = String::length;</span><br><span class="line"><span class="keyword">int</span> result2 = f.applyAsInt(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>对象方法引用时，函数式接口抽象方法的第一个参数是被引用方法的调用者，第二个参数(或者无参)是被引用方法的参数</strong></p>
<h1 id="3-外部对象方法引用"><a href="#3-外部对象方法引用" class="headerlink" title="3. 外部对象方法引用"></a>3. 外部对象方法引用</h1><p>语法：<code>objectName::methodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">Predicate&lt;String&gt; p = (s) -&gt; list.contains(s);</span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; p = list::contains; </span><br><span class="line"><span class="keyword">boolean</span> result = p.test(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>外部对象方法引用时，被引用方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4. 构造器引用"></a>4. 构造器引用</h1><p>语法：<code>ClassName::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = (millisecond) -&gt; <span class="keyword">new</span> Date(millisecond);</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Long, Date&gt; fun = Date::<span class="keyword">new</span>;</span><br><span class="line">Date date = fun.apply(<span class="number">1000000000000L</span>);</span><br></pre></td></tr></table></figure>
<p><strong>构造器引用时，被引用的构造方法与函数式接口抽象方法参数列表一致</strong></p>
<h1 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5. 数组引用"></a>5. 数组引用</h1><p>语法：<code>Type[]::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = n -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>数组引用时，函数式接口抽象方法参数(数值型)即为数组初始化大小值</strong></p>
]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式（一）——函数式接口</title>
    <url>/20190201/lambda1/c673d3a38bb1.html</url>
    <content><![CDATA[<h2 id="1-什么是lambda"><a href="#1-什么是lambda" class="headerlink" title="1.什么是lambda?"></a>1.什么是lambda?</h2><p>如果我们想要起一个线程来打印一串字符串，我们之前的写法通常是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式后，可以改写为这个样：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>我们可以看到使用lambda表达式后，代码变得更加简洁，这里的 “<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>“ 其实就相当于Runnable接口的匿名实现，你会发现Runnable的抽象方法<code>run()</code>的签名与<code>() -&gt; System.out.println(&quot;hello word!&quot;)</code>的签名是一致的（lambda表达式的签名下面会讲到）。简而言之，可以把Lambda表达式理解为<strong>简洁地表示可传递的匿名函数的一种方式，它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</strong></p>
<p>lambda表达式由三部分构成：<strong>参数列表</strong>、**-&gt;(分割符)<strong>、</strong>主体**，基本语法如下：<br><code>(parameters) -&gt; expression</code> 或者 <code>(parameters) -&gt; &#123; statements; &#125;</code></p>
<ul>
<li>参数列表：多个参数用逗号隔开，类型可以省略不写，要保证与函数式接口抽象方法的参数列表一致，如果只有一个参数”()”可以省略；</li>
<li>箭头（-&gt;）: 用于分割参数列表和主体；</li>
<li>主体：可以直接是表达式，有多条语句要用花括号括起来，如果lambda需要返回一个值，那么返回值即使expression本身所表示的值，如有使用的“{}”，需要用return关键字返回具体值。  </li>
</ul>
<p>Lambda的类型是从使用Lambda的上下文推断出来的，上下文中Lambda表达式所需要代表的类型称为<strong>目标类型</strong>，如上示例中 “<code>() -&gt; System.out.println(&quot;hello world!&quot;)</code>” 代表的是Runnable类型的实例，所以相同的lambda表达式在不同的上下文中可能代表不同类型的函数式接口</p>
<h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h2><p>假设上面的示例中，如果Runnable接口有两个抽象方法run()和run2()，那么lambda表达式该怎么表示呢，相当于重写了哪个方法呢？这种情况是不能使用lambda表达式的，只有在使用了函数式接口的地方才能使用lambda表达式，所以这里要说一下函数是接口的定义。所谓函数式接口，即：<strong>只有一个抽象方法的接口</strong>。 Java8已经为我们提供了一些常用的函数式接口，如下表：</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>函数描述符</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate&lt;T&gt;</td>
<td>T-&gt;boolean</td>
<td>IntPredicate,<br/>LongPredicate,<br/>DoublePredicate</td>
</tr>
<tr>
<td>Consumer</td>
<td>T-&gt;void</td>
<td>IntConsumer,<br/>LongConsumer,<br/>DoubleConsumer</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T-&gt;R</td>
<td>IntFunction,<br/>IntToDoubleFunction,<br/>IntToLongFunction,<br/>LongFunction,<br/>LongToDoubleFunction,<br/>LongToIntFunction,<br/>DoubleFunction,<br/>ToIntFunction,<br/>ToDoubleFunction,<br/>ToLongFunction</td>
</tr>
<tr>
<td>Supplier</td>
<td>()-&gt;T</td>
<td>BooleanSupplier,<br/>IntSupplier,<br/>LongSupplier,<br/>DoubleSupplier</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>T-&gt;T</td>
<td>IntUnaryOperator,<br/>LongUnaryOperator,<br/>DoubleUnaryOperator</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>(T,T)-&gt;T</td>
<td>IntBinaryOperator,<br/>LongBinaryOperator,<br/>DoubleBinaryOperator</td>
</tr>
<tr>
<td>BiPredicate&lt;L,R&gt;</td>
<td>(L,R)-&gt;boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>(T,U)-&gt;void</td>
<td>ObjIntConsumer,<br/>ObjLongConsumer,<br/>ObjDoubleConsumer</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>(T,U)-&gt;R</td>
<td>ToIntBiFunction&lt;T,U&gt;,<br/>ToLongBiFunction&lt;T,U&gt;,<br/>ToDoubleBiFunction&lt;T,U&gt;</td>
</tr>
</tbody></table>
<p> 函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，我们将这种抽象方法叫作<strong>函数描述符</strong>，比如 “<code>T-&gt;boolean</code>“ 表示传入一个T类型的参数并返回boolean类型的值。</p>
<p> <strong>原始类型特化</strong>是在某个函数是接口上，把输入或输出参数特化为原始类型，这样就避免了拆装箱操作，以提高性能。例如 <code>IntPredicate</code> 把输入参数特化为<code>int</code>类型，ToLongFunction把返回值特化为<code>long</code>类型。</p>
<blockquote>
<p>查看上表函数式接口的源码，会发现它们都有一个 <code>@FunctionalInterface</code> 注解，这是Java8提供的用来表示接口是否为函数式接口，但它不是必须的，只要接口只包含一个抽象方法就是函数式接口，只是如果接口上加上了<code>@FunctionalInterface</code>注解，那么往接口中添加其他抽象方法时编译就会报错，起到一个限定作用；  </p>
</blockquote>
<blockquote>
<p>特殊的void兼容规则<br>   如果一个Lambda的主体是一个语句表达式(expression)，它就和一个返回void的函数描述符兼容（当然需要参数列表一致）。例如，以下两行都是合法的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -&gt; void）所要求的void：<br>   // Predicate返回了一个boolean<br>   Predicate<String> p = s -&gt; list.add(s);<br>   // Consumer返回了一个void<br>   Consumer<String> b = s -&gt; list.add(s);  </p>
</blockquote>
<h2 id="3-lambda使用局部变量的限制"><a href="#3-lambda使用局部变量的限制" class="headerlink" title="3.lambda使用局部变量的限制"></a>3.lambda使用局部变量的限制</h2><p>lambda可以没有限制的在主体中引用实例变量和静态变量，但是引用的局部变量必须声明为<code>final</code>或者事实上是<code>final</code>。因为成员变量存储在堆中，而局部变量保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在另一个线程中使用的，则使用Lambda的线程时，可能会在分配该局部变量的线程将这个变量收回之后去访问该变量。因此，Java在访问局部变量时，实际上是在访问它的副本，而不是访问原始变量，如果局部变量仅仅赋值一次,那么副本和原始变量就没有什么区别了——因此就有了这个限制，要保证副本和原始值保持一致。<br>例如下面的代码，如果把 “//name = “jack”;” 注释去掉，就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">String name = <span class="string">&quot;tome&quot;</span>;</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;hello &quot;</span> + name));</span><br><span class="line"><span class="comment">//name = &quot;jack&quot;;</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射基础运用</title>
    <url>/20190101/reflect/b01167aa3bca.html</url>
    <content><![CDATA[<h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h2><p>反射是指在程序运行时期可以动态的加载类并访问、检测和修改对象的一种能力。 那为什么要使用反射呢？编程时一般会遇到这种情况，编译时期无法确定对象类型，只有在运行时期才能确定，比如Spring的配置中就大量使用了反射机制。通过反射能够获取到类的一切信息，访问到对象的一切属性和方法，包括private修饰的属性和方法。  </p>
<a id="more"></a>

<p>Class类与java.lang.reflect类库一起对反射进行了支持。 java.lang.reflect类库包含了Field、Method、Constructor等类，Field类：关联一个字段，Field对象可以对该字段进行操作，比如用Field的set()和get()方法可以获取和修改关联字段的值；Method类：关联一个方法，用Metond的invoke()方法可以调用Method对象关联的方法；Constructor类： 关联构造器方法，调用Constructor类的newInstance()用来创建对象。而这三个类都可以通过Class对象获得。</p>
<h2 id="2-Class类介绍"><a href="#2-Class类介绍" class="headerlink" title="2.Class类介绍"></a>2.Class类介绍</h2><p>在学习使用反射之前，我们先来了解一下Class类。什么是Class类呢？我们不妨先把Java中的对象分为两种，一种是我们通常自己定义的类型对象，即“常规”对象，另一种是class对象，而每一个类在编译是都会产生一个class对象（被保存在一个同名的.class文件中），在Java程序运行时，可以通过Class对象获得对应类型的一切信息，比如该类有哪些方法、哪些构造方法、是不是接口等信息，是一个类型的描述对象。实际上Class类也是一个普通类，但是它的对象记录着对应类的一切信息，甚至该类的所有对象也都是有他的class对象完成创建的。</p>
<h2 id="2-1-如何获取class对象"><a href="#2-1-如何获取class对象" class="headerlink" title="2.1 如何获取class对象"></a>2.1 如何获取class对象</h2><p>每一个类都会存在一个唯一的Class对象，那么该如何获取Class对象呢？ 有三种方式：    </p>
<ul>
<li><strong>Class.forName(“类全名字符串”)</strong>  </li>
<li><strong>实例对象.getClass()</strong>  </li>
<li><strong>类名.class (此方式来创建Class对象时，不会自动的初始化该Class对象)</strong>  </li>
</ul>
<p>对于基本类型也存在Class对象，基本类型的包装器类型都有一个标准字段TYPE，此TYPE字段就是对应基本类型的class对象的引用。  </p>
<h3 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a>2.2 示例代码</h3><p>首先创建一个Student类（后续示例都延用此类）：</p>
<figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">      <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在学习：&quot;</span> + course);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我正在睡觉zzz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123; name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age + <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*第一种方式：Class.forName(&quot;类全名&quot;)*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            studentClass1 = Class.forName(<span class="string">&quot;com.taicw.code.Student&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类型不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第二中种方式：类名.class*/</span></span><br><span class="line">        Class&lt;?&gt; studentClass2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第三种方式：实例对象.getClass()*/</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Class&lt;?&gt; studentClass3 = student.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;三种方式获取的Class对象是否为同一个? &quot;</span> +</span><br><span class="line">                (studentClass1 == studentClass2 &amp;&amp; studentClass2 == studentClass3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.class ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer.TYPE == Integer.class ? &quot;</span> + (Integer.TYPE == Integer.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;int.class == Integer.TYPE ? &quot;</span> + (<span class="keyword">int</span>.class == Integer.TYPE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">三种方式获取的Class对象是否为同一个? true</span></span><br><span class="line"><span class="comment">int.class == Integer.class ? false</span></span><br><span class="line"><span class="comment">Integer.TYPE == Integer.class ? false</span></span><br><span class="line"><span class="comment">int.class == Integer.TYPE ? true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h3 id="2-3-类型判断"><a href="#2-3-类型判断" class="headerlink" title="2.3 类型判断"></a>2.3 类型判断</h3><p>在程序运行时期，我们拿到Class对象后，可能还会需要判断一个对象的类型，根据不同的类型做不同的逻辑处理，判断类型的方式有三种，下面比较一下三种方式的不同点和使用：</p>
<table>
<thead>
<tr>
<th></th>
<th>instanceof</th>
<th>isInstance</th>
<th>isAssignableFrom</th>
</tr>
</thead>
<tbody><tr>
<td>表现形式</td>
<td>关键字</td>
<td>方法</td>
<td>方法</td>
</tr>
<tr>
<td>使用方法</td>
<td>obj instanceof Type</td>
<td>class.isInstance(obj)</td>
<td>class1.isAssignableFrom(class2)</td>
</tr>
<tr>
<td>作用</td>
<td>Java的关键字，用于判断一个对象（obj）是否为一个类（Type）或者该类的子类的实例</td>
<td>Class类对象的一个方法，判断一个对象是否是该Class对象所表示的类或其子类的实例。</td>
<td>Class类对象的一个方法，其参数也是Class类的对象，用于判断class1是否与class2对象为同一类型或class2的超类或接口。</td>
</tr>
</tbody></table>
<h2 id="3-反射的基本使用"><a href="#3-反射的基本使用" class="headerlink" title="3.反射的基本使用"></a>3.反射的基本使用</h2><h3 id="3-1-获取构造器信息并创建实例"><a href="#3-1-获取构造器信息并创建实例" class="headerlink" title="3.1 获取构造器信息并创建实例"></a>3.1 获取构造器信息并创建实例</h3><p>上面已经说了任何类型的对象实际上就是其对应的Calss对象创建，那么我们拿到了class对象后该如何去创建一个对象呢？  </p>
<p><strong>第一种方式：通过Class对象的newInstance()方法来创建对应类型的实例对象。</strong> class对象的newInstance()方法使用的是对应类型的默认构造方法（无参构造方法），所以该方式必须要保证Class对应类型必须要有一个无参构造方法。那么如果我们需要使用有参构造方法怎么办呢？还有另一种方式。<br><strong>第二种：先通过Class对象获取相关的Constructor对象（每一个构造方法对应一个Constructor对象），再调用Constructor对象的newInstance()方法来创建实例。</strong> 通过Class对象获取构造器对象主要有一下几个方法：  </p>
<ul>
<li><p>public Constructor&lt;?&gt;[] <code>getConstructors()</code>：获取Class对象关联类型的所有public修饰的构造器对  </p>
</li>
<li><p>public Constructor&lt;?&gt;[] <code>getDeclaredConstructors()</code>：获取Class对象关联类型的所有构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的public修饰的构造器对象  </p>
</li>
<li><p>public Constructor<T> <code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：根据参数类型获取指定的构造器对象（包括任意限定符修饰的构造方法） </p>
</li>
<li><p>public T <code>newInstance(Object ... initargs)</code>：获取构造器对象后，调用该方法并按顺序传入参数对象来创建实例  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Class对象的newInstance()方法创建实例*/</span></span><br><span class="line">        Student zhangsan =  studentClass.newInstance();</span><br><span class="line">        System.out.println(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过Constructor对象的newInstance()方法创建实例*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的public构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allPublicConstructors = studentClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allPublicConstructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有的构造器对象：&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] allConstructors = studentClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: allConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPublicConstructor = studentClass.getConstructor(String.class);</span><br><span class="line">        Student lisi = studentPublicConstructor.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定public构造器对象来创建关联类型实例：&quot;</span> + lisi);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; studentPrivateConstructor = studentClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        studentPrivateConstructor.setAccessible(<span class="keyword">true</span>); <span class="comment">/*调用是由构造器之前需要设置访问标志为true*/</span></span><br><span class="line">        Student wangwu = studentPrivateConstructor.newInstance(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据参数类型获取指定private构造器对象来创建关联类型实例：&quot;</span> + wangwu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">&#123; name:张三, age:18 &#125;</span></span><br><span class="line"><span class="comment">获取所有的public构造器对象：</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">获取所有的构造器对象：</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(java.lang.String,int)</span></span><br><span class="line"><span class="comment">private com.taicw.code.Student(int)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.taicw.code.Student()</span></span><br><span class="line"><span class="comment">根据参数类型获取指定public构造器对象来创建关联类型实例：&#123; name:李四, age:0 &#125;</span></span><br><span class="line"><span class="comment">根据参数类型获取指定private构造器对象来创建关联类型实例：&#123; name:王五, age:20 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-获取Method信息并调用其关联方法"><a href="#3-2-获取Method信息并调用其关联方法" class="headerlink" title="3.2 获取Method信息并调用其关联方法"></a>3.2 获取Method信息并调用其关联方法</h3><p>通过Class对象获取Method对象主要有以下几个方法：  </p>
<ul>
<li><p>public Method[] <code>getMethods()</code>：获取关联类型的所有公有（public）方法对象，包括其父类的所有公有方法对象  </p>
</li>
<li><p>public Method[] <code>getDeclaredMethods()</code>：获取关联类型的所有方法（包括public、protected、default、private修饰的方法）对象，但不包括其父类的方法对象  </p>
</li>
<li><p>public Method <code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的公有方法对象  </p>
</li>
<li><p>public Method <code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：根据方法名和方法参数类型获取指定的所有(不包含父类)方法对象  </p>
</li>
<li><p>public Object <code>invoke(Object obj, Object... args)</code>：通过Method对象来执行指定对象的方法，第一个参数为要执行该方法的对象，后面为方法参数，按顺序传入  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line"></span><br><span class="line">        Method[] allPublicMethods = studentClass.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allPublicMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] allMethods = studentClass.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Method m: allMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method publicMethod = studentClass.getMethod(<span class="string">&quot;study&quot;</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的公有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(publicMethod);</span><br><span class="line"></span><br><span class="line">        Method privateMethod = studentClass.getDeclaredMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据方法名和方法参数类型 获取指定的私有method对象：&quot;</span>);</span><br><span class="line">        System.out.println(privateMethod);</span><br><span class="line"></span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line">        publicMethod.invoke(obj,<span class="string">&quot;English&quot;</span>);</span><br><span class="line"></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>); <span class="comment">/*访问私有方法前，需要设置访问标志为true*/</span></span><br><span class="line">        privateMethod.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有（public）方法，包括其父类的所有公有方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">获取关联类型的所有方法（public、protected、default、private修饰的方法），但不包括其父类的方法：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.toString()</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.getName()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public int com.taicw.code.Student.getAge()</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.setAge(int)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的公有method对象：</span></span><br><span class="line"><span class="comment">public void com.taicw.code.Student.study(java.lang.String)</span></span><br><span class="line"><span class="comment">根据方法名和方法参数类型 获取指定的私有method对象：</span></span><br><span class="line"><span class="comment">private void com.taicw.code.Student.sleep()</span></span><br><span class="line"><span class="comment">我正在学习：English</span></span><br><span class="line"><span class="comment">我正在睡觉zzz</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取Field信息并操作其关联属性"><a href="#3-3-获取Field信息并操作其关联属性" class="headerlink" title="3.3 获取Field信息并操作其关联属性"></a>3.3 获取Field信息并操作其关联属性</h3><p>通过Class对象获取Field对象主要有以下几个方法：  </p>
<ul>
<li><p>public Field[] <code>getFields()</code>：获取关联类型的所有公有（public）属相对象，包括其父类的所有公有属性  </p>
</li>
<li><p>public Field[] <code>getDeclaredFields()</code>：获取关联类型的所有属性（包括public、protected、default、private修饰的属性）对象，但不包括其父类的属性  </p>
</li>
<li><p>public Field <code>getField(String name)</code>：根据属性名称获取指定的公有属性对象  </p>
</li>
<li><p>public Field <code>getDeclaredField(String name)</code>：根据属性名称获取任意的属性对象，但不包括父类的属性  </p>
</li>
</ul>
<ul>
<li><p>public void <code>set(Object obj, Object value)</code>：获取Field对象后，为指定对象属性赋值  </p>
</li>
<li><p>public Object <code>get(Object obj)</code>：通过Field对象，获取指定对象的属性值  </p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>Demo.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.taicw.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; studentClass = Student.class;</span><br><span class="line">        Object obj = studentClass.newInstance();</span><br><span class="line"></span><br><span class="line">        Field[] allPublicFields =  studentClass.getFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allPublicFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] allFields = studentClass.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (Field f: allFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取公有(public)属性，包括获取其父类的公有属性*/</span></span><br><span class="line">        Field namePublicField = studentClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        namePublicField.set(obj, <span class="string">&quot;李哈哈&quot;</span>);</span><br><span class="line">        String name = (String)namePublicField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取公有属性name：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据属性名称获取任意属性，不能获取父类的属性*/</span></span><br><span class="line">        Field agePrivateField = studentClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        agePrivateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        agePrivateField.set(obj, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">int</span> age = (<span class="keyword">int</span>)agePrivateField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;反射获取私有属性age：&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射设置并获取属性信息：&quot;</span> + obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回结果：</span></span><br><span class="line"><span class="comment">获取关联类型的所有公有属性（public修饰），包括其父类的所用公有属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">获取关联类型的所有属性（public、protected、default、private修饰的属性），但不包括其父类的属性：</span></span><br><span class="line"><span class="comment">public java.lang.String com.taicw.code.Student.name</span></span><br><span class="line"><span class="comment">private int com.taicw.code.Student.age</span></span><br><span class="line"><span class="comment">反射获取公有属性name：李哈哈</span></span><br><span class="line"><span class="comment">反射获取私有属性age：18</span></span><br><span class="line"><span class="comment">通过反射设置并获取属性信息：&#123; name:李哈哈, age:18 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
